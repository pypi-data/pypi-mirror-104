# coding: utf-8

"""
    Edge Impulse API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from edge_impulse_sdk.api_client import ApiClient
from edge_impulse_sdk.exceptions import (
    ApiTypeError,
    ApiValueError
)


class AllowsReadOnlyApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def anomaly_trained_features(self, project_id, learn_id, feature_ax1, feature_ax2, **kwargs):  # noqa: E501
        """Trained features  # noqa: E501

        Get a sample of trained features, this extracts a number of samples and their features.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.anomaly_trained_features(project_id, learn_id, feature_ax1, feature_ax2, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int learn_id: Learn Block ID, use the impulse functions to retrieve the ID (required)
        :param int feature_ax1: Feature axis 1 (required)
        :param int feature_ax2: Feature axis 2 (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnomalyTrainedFeaturesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.anomaly_trained_features_with_http_info(project_id, learn_id, feature_ax1, feature_ax2, **kwargs)  # noqa: E501

    def anomaly_trained_features_with_http_info(self, project_id, learn_id, feature_ax1, feature_ax2, **kwargs):  # noqa: E501
        """Trained features  # noqa: E501

        Get a sample of trained features, this extracts a number of samples and their features.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.anomaly_trained_features_with_http_info(project_id, learn_id, feature_ax1, feature_ax2, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int learn_id: Learn Block ID, use the impulse functions to retrieve the ID (required)
        :param int feature_ax1: Feature axis 1 (required)
        :param int feature_ax2: Feature axis 2 (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnomalyTrainedFeaturesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'learn_id', 'feature_ax1', 'feature_ax2']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method anomaly_trained_features" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `anomaly_trained_features`")  # noqa: E501
        # verify the required parameter 'learn_id' is set
        if self.api_client.client_side_validation and ('learn_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['learn_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `learn_id` when calling `anomaly_trained_features`")  # noqa: E501
        # verify the required parameter 'feature_ax1' is set
        if self.api_client.client_side_validation and ('feature_ax1' not in local_var_params or  # noqa: E501
                                                        local_var_params['feature_ax1'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feature_ax1` when calling `anomaly_trained_features`")  # noqa: E501
        # verify the required parameter 'feature_ax2' is set
        if self.api_client.client_side_validation and ('feature_ax2' not in local_var_params or  # noqa: E501
                                                        local_var_params['feature_ax2'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feature_ax2` when calling `anomaly_trained_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'learn_id' in local_var_params:
            path_params['learnId'] = local_var_params['learn_id']  # noqa: E501

        query_params = []
        if 'feature_ax1' in local_var_params and local_var_params['feature_ax1'] is not None:  # noqa: E501
            query_params.append(('featureAx1', local_var_params['feature_ax1']))  # noqa: E501
        if 'feature_ax2' in local_var_params and local_var_params['feature_ax2'] is not None:  # noqa: E501
            query_params.append(('featureAx2', local_var_params['feature_ax2']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/training/anomaly/{learnId}/features/get-graph', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnomalyTrainedFeaturesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def anomaly_trained_features_per_sample(self, project_id, learn_id, sample_id, **kwargs):  # noqa: E501
        """Trained features for sample  # noqa: E501

        Get trained features for a single sample. This runs both the DSP prerequisites and the anomaly classifier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.anomaly_trained_features_per_sample(project_id, learn_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int learn_id: Learn Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnomalyTrainedFeaturesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.anomaly_trained_features_per_sample_with_http_info(project_id, learn_id, sample_id, **kwargs)  # noqa: E501

    def anomaly_trained_features_per_sample_with_http_info(self, project_id, learn_id, sample_id, **kwargs):  # noqa: E501
        """Trained features for sample  # noqa: E501

        Get trained features for a single sample. This runs both the DSP prerequisites and the anomaly classifier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.anomaly_trained_features_per_sample_with_http_info(project_id, learn_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int learn_id: Learn Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnomalyTrainedFeaturesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'learn_id', 'sample_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method anomaly_trained_features_per_sample" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `anomaly_trained_features_per_sample`")  # noqa: E501
        # verify the required parameter 'learn_id' is set
        if self.api_client.client_side_validation and ('learn_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['learn_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `learn_id` when calling `anomaly_trained_features_per_sample`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `anomaly_trained_features_per_sample`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'learn_id' in local_var_params:
            path_params['learnId'] = local_var_params['learn_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/training/anomaly/{learnId}/features/get-graph/classification/{sampleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnomalyTrainedFeaturesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def classify_sample(self, project_id, sample_id, **kwargs):  # noqa: E501
        """Classify sample  # noqa: E501

        Classify a complete file against the current impulse. This will move the sliding window (dependent on the sliding window length and the sliding window increase parameters in the impulse) over the complete file, and classify for every window that is extracted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.classify_sample(project_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClassifySampleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.classify_sample_with_http_info(project_id, sample_id, **kwargs)  # noqa: E501

    def classify_sample_with_http_info(self, project_id, sample_id, **kwargs):  # noqa: E501
        """Classify sample  # noqa: E501

        Classify a complete file against the current impulse. This will move the sliding window (dependent on the sliding window length and the sliding window increase parameters in the impulse) over the complete file, and classify for every window that is extracted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.classify_sample_with_http_info(project_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClassifySampleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'sample_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method classify_sample" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `classify_sample`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `classify_sample`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/classify/{sampleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClassifySampleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def count_samples(self, project_id, category, **kwargs):  # noqa: E501
        """Count samples  # noqa: E501

        Count all raw data by category.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.count_samples(project_id, category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param str category: Which of the three acquisition categories to retrieve data from (required)
        :param str labels: Only include samples with a label within the given list of labels, given as a JSON string
        :param str filename: Only include samples whose filename includes the given filename
        :param int max_length: Only include samples shorter than the given length, in milliseconds
        :param int min_length: Only include samples longer than the given length, in milliseconds
        :param str signature_validity: Include samples with either valid or invalid signatures
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CountSamplesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.count_samples_with_http_info(project_id, category, **kwargs)  # noqa: E501

    def count_samples_with_http_info(self, project_id, category, **kwargs):  # noqa: E501
        """Count samples  # noqa: E501

        Count all raw data by category.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.count_samples_with_http_info(project_id, category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param str category: Which of the three acquisition categories to retrieve data from (required)
        :param str labels: Only include samples with a label within the given list of labels, given as a JSON string
        :param str filename: Only include samples whose filename includes the given filename
        :param int max_length: Only include samples shorter than the given length, in milliseconds
        :param int min_length: Only include samples longer than the given length, in milliseconds
        :param str signature_validity: Include samples with either valid or invalid signatures
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CountSamplesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'category', 'labels', 'filename', 'max_length', 'min_length', 'signature_validity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method count_samples" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `count_samples`")  # noqa: E501
        # verify the required parameter 'category' is set
        if self.api_client.client_side_validation and ('category' not in local_var_params or  # noqa: E501
                                                        local_var_params['category'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `category` when calling `count_samples`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501

        query_params = []
        if 'category' in local_var_params and local_var_params['category'] is not None:  # noqa: E501
            query_params.append(('category', local_var_params['category']))  # noqa: E501
        if 'labels' in local_var_params and local_var_params['labels'] is not None:  # noqa: E501
            query_params.append(('labels', local_var_params['labels']))  # noqa: E501
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  # noqa: E501
            query_params.append(('filename', local_var_params['filename']))  # noqa: E501
        if 'max_length' in local_var_params and local_var_params['max_length'] is not None:  # noqa: E501
            query_params.append(('maxLength', local_var_params['max_length']))  # noqa: E501
        if 'min_length' in local_var_params and local_var_params['min_length'] is not None:  # noqa: E501
            query_params.append(('minLength', local_var_params['min_length']))  # noqa: E501
        if 'signature_validity' in local_var_params and local_var_params['signature_validity'] is not None:  # noqa: E501
            query_params.append(('signatureValidity', local_var_params['signature_validity']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/raw-data/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CountSamplesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_dsp_data(self, project_id, dsp_id, category, **kwargs):  # noqa: E501
        """Download DSP data  # noqa: E501

        Download raw output from a DSP block over all data in the training set, already sliced in windows. In Numpy binary format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dsp_data(project_id, dsp_id, category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param str category: Which of the three acquisition categories to download data from (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.download_dsp_data_with_http_info(project_id, dsp_id, category, **kwargs)  # noqa: E501

    def download_dsp_data_with_http_info(self, project_id, dsp_id, category, **kwargs):  # noqa: E501
        """Download DSP data  # noqa: E501

        Download raw output from a DSP block over all data in the training set, already sliced in windows. In Numpy binary format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dsp_data_with_http_info(project_id, dsp_id, category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param str category: Which of the three acquisition categories to download data from (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'category']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_dsp_data" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `download_dsp_data`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `download_dsp_data`")  # noqa: E501
        # verify the required parameter 'category' is set
        if self.api_client.client_side_validation and ('category' not in local_var_params or  # noqa: E501
                                                        local_var_params['category'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `category` when calling `download_dsp_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'category' in local_var_params:
            path_params['category'] = local_var_params['category']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp-data/{dspId}/x/{category}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_dsp_labels(self, project_id, dsp_id, category, **kwargs):  # noqa: E501
        """Download DSP labels  # noqa: E501

        Download labels for a DSP block over all data in the training set, already sliced in windows.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dsp_labels(project_id, dsp_id, category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param str category: Which of the three acquisition categories to download data from (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.download_dsp_labels_with_http_info(project_id, dsp_id, category, **kwargs)  # noqa: E501

    def download_dsp_labels_with_http_info(self, project_id, dsp_id, category, **kwargs):  # noqa: E501
        """Download DSP labels  # noqa: E501

        Download labels for a DSP block over all data in the training set, already sliced in windows.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dsp_labels_with_http_info(project_id, dsp_id, category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param str category: Which of the three acquisition categories to download data from (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'category']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_dsp_labels" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `download_dsp_labels`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `download_dsp_labels`")  # noqa: E501
        # verify the required parameter 'category' is set
        if self.api_client.client_side_validation and ('category' not in local_var_params or  # noqa: E501
                                                        local_var_params['category'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `category` when calling `download_dsp_labels`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'category' in local_var_params:
            path_params['category'] = local_var_params['category']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp-data/{dspId}/y/{category}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_learn_model(self, project_id, learn_id, model_download_id, **kwargs):  # noqa: E501
        """Download trained model  # noqa: E501

        Download a trained model for a learning block. Depending on the block this can be a TensorFlow model, or the cluster centroids.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_learn_model(project_id, learn_id, model_download_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int learn_id: Learn Block ID, use the impulse functions to retrieve the ID (required)
        :param str model_download_id: Model download ID, which can be obtained from the project information (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.download_learn_model_with_http_info(project_id, learn_id, model_download_id, **kwargs)  # noqa: E501

    def download_learn_model_with_http_info(self, project_id, learn_id, model_download_id, **kwargs):  # noqa: E501
        """Download trained model  # noqa: E501

        Download a trained model for a learning block. Depending on the block this can be a TensorFlow model, or the cluster centroids.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_learn_model_with_http_info(project_id, learn_id, model_download_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int learn_id: Learn Block ID, use the impulse functions to retrieve the ID (required)
        :param str model_download_id: Model download ID, which can be obtained from the project information (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'learn_id', 'model_download_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_learn_model" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `download_learn_model`")  # noqa: E501
        # verify the required parameter 'learn_id' is set
        if self.api_client.client_side_validation and ('learn_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['learn_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `learn_id` when calling `download_learn_model`")  # noqa: E501
        # verify the required parameter 'model_download_id' is set
        if self.api_client.client_side_validation and ('model_download_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['model_download_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `model_download_id` when calling `download_learn_model`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'learn_id' in local_var_params:
            path_params['learnId'] = local_var_params['learn_id']  # noqa: E501
        if 'model_download_id' in local_var_params:
            path_params['modelDownloadId'] = local_var_params['model_download_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/learn-data/{learnId}/model/{modelDownloadId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dsp_get_features_for_sample(self, project_id, dsp_id, sample_id, **kwargs):  # noqa: E501
        """Features for sample  # noqa: E501

        Runs the DSP block against a sample. This will move the sliding window (dependent on the sliding window length and the sliding window increase parameters in the impulse) over the complete file, and run the DSP function for every window that is extracted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dsp_get_features_for_sample(project_id, dsp_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DspSampleFeaturesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.dsp_get_features_for_sample_with_http_info(project_id, dsp_id, sample_id, **kwargs)  # noqa: E501

    def dsp_get_features_for_sample_with_http_info(self, project_id, dsp_id, sample_id, **kwargs):  # noqa: E501
        """Features for sample  # noqa: E501

        Runs the DSP block against a sample. This will move the sliding window (dependent on the sliding window length and the sliding window increase parameters in the impulse) over the complete file, and run the DSP function for every window that is extracted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dsp_get_features_for_sample_with_http_info(project_id, dsp_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DspSampleFeaturesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'sample_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dsp_get_features_for_sample" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `dsp_get_features_for_sample`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `dsp_get_features_for_sample`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `dsp_get_features_for_sample`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/features/get-graph/classification/{sampleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DspSampleFeaturesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def dsp_sample_trained_features(self, project_id, dsp_id, feature_ax1, feature_ax2, feature_ax3, category, **kwargs):  # noqa: E501
        """Sample of trained features  # noqa: E501

        Get a sample of trained features, this extracts a number of samples and their labels. Used to visualize the current training set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dsp_sample_trained_features(project_id, dsp_id, feature_ax1, feature_ax2, feature_ax3, category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int feature_ax1: Feature axis 1 (required)
        :param int feature_ax2: Feature axis 2 (required)
        :param int feature_ax3: Feature axis 3 (required)
        :param str category: Which of the three acquisition categories to download data from (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DspTrainedFeaturesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.dsp_sample_trained_features_with_http_info(project_id, dsp_id, feature_ax1, feature_ax2, feature_ax3, category, **kwargs)  # noqa: E501

    def dsp_sample_trained_features_with_http_info(self, project_id, dsp_id, feature_ax1, feature_ax2, feature_ax3, category, **kwargs):  # noqa: E501
        """Sample of trained features  # noqa: E501

        Get a sample of trained features, this extracts a number of samples and their labels. Used to visualize the current training set.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.dsp_sample_trained_features_with_http_info(project_id, dsp_id, feature_ax1, feature_ax2, feature_ax3, category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int feature_ax1: Feature axis 1 (required)
        :param int feature_ax2: Feature axis 2 (required)
        :param int feature_ax3: Feature axis 3 (required)
        :param str category: Which of the three acquisition categories to download data from (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DspTrainedFeaturesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'feature_ax1', 'feature_ax2', 'feature_ax3', 'category']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method dsp_sample_trained_features" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `dsp_sample_trained_features`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `dsp_sample_trained_features`")  # noqa: E501
        # verify the required parameter 'feature_ax1' is set
        if self.api_client.client_side_validation and ('feature_ax1' not in local_var_params or  # noqa: E501
                                                        local_var_params['feature_ax1'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feature_ax1` when calling `dsp_sample_trained_features`")  # noqa: E501
        # verify the required parameter 'feature_ax2' is set
        if self.api_client.client_side_validation and ('feature_ax2' not in local_var_params or  # noqa: E501
                                                        local_var_params['feature_ax2'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feature_ax2` when calling `dsp_sample_trained_features`")  # noqa: E501
        # verify the required parameter 'feature_ax3' is set
        if self.api_client.client_side_validation and ('feature_ax3' not in local_var_params or  # noqa: E501
                                                        local_var_params['feature_ax3'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feature_ax3` when calling `dsp_sample_trained_features`")  # noqa: E501
        # verify the required parameter 'category' is set
        if self.api_client.client_side_validation and ('category' not in local_var_params or  # noqa: E501
                                                        local_var_params['category'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `category` when calling `dsp_sample_trained_features`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'category' in local_var_params:
            path_params['category'] = local_var_params['category']  # noqa: E501

        query_params = []
        if 'feature_ax1' in local_var_params and local_var_params['feature_ax1'] is not None:  # noqa: E501
            query_params.append(('featureAx1', local_var_params['feature_ax1']))  # noqa: E501
        if 'feature_ax2' in local_var_params and local_var_params['feature_ax2'] is not None:  # noqa: E501
            query_params.append(('featureAx2', local_var_params['feature_ax2']))  # noqa: E501
        if 'feature_ax3' in local_var_params and local_var_params['feature_ax3'] is not None:  # noqa: E501
            query_params.append(('featureAx3', local_var_params['feature_ax3']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/features/get-graph/{category}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DspTrainedFeaturesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_anomaly_metadata(self, project_id, learn_id, **kwargs):  # noqa: E501
        """Anomaly metadata  # noqa: E501

        Get metadata about a trained anomaly block. Use the impulse blocks to find the learnId.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_anomaly_metadata(project_id, learn_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int learn_id: Learn Block ID, use the impulse functions to retrieve the ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AnomalyModelMetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_anomaly_metadata_with_http_info(project_id, learn_id, **kwargs)  # noqa: E501

    def get_anomaly_metadata_with_http_info(self, project_id, learn_id, **kwargs):  # noqa: E501
        """Anomaly metadata  # noqa: E501

        Get metadata about a trained anomaly block. Use the impulse blocks to find the learnId.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_anomaly_metadata_with_http_info(project_id, learn_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int learn_id: Learn Block ID, use the impulse functions to retrieve the ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AnomalyModelMetadataResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'learn_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_anomaly_metadata" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_anomaly_metadata`")  # noqa: E501
        # verify the required parameter 'learn_id' is set
        if self.api_client.client_side_validation and ('learn_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['learn_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `learn_id` when calling `get_anomaly_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'learn_id' in local_var_params:
            path_params['learnId'] = local_var_params['learn_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/training/anomaly/{learnId}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnomalyModelMetadataResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_classify_job_result(self, project_id, **kwargs):  # noqa: E501
        """Classify job result  # noqa: E501

        Get classify job result, containing the result for the complete testing dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_classify_job_result(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ClassifyJobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_classify_job_result_with_http_info(project_id, **kwargs)  # noqa: E501

    def get_classify_job_result_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Classify job result  # noqa: E501

        Get classify job result, containing the result for the complete testing dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_classify_job_result_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ClassifyJobResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_classify_job_result" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_classify_job_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/classify/all/result', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClassifyJobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dsp_metadata(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Get metadata  # noqa: E501

        Retrieve the metadata from a generated DSP block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_metadata(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DSPMetadataResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dsp_metadata_with_http_info(project_id, dsp_id, **kwargs)  # noqa: E501

    def get_dsp_metadata_with_http_info(self, project_id, dsp_id, **kwargs):  # noqa: E501
        """Get metadata  # noqa: E501

        Retrieve the metadata from a generated DSP block.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_metadata_with_http_info(project_id, dsp_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DSPMetadataResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dsp_metadata" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_dsp_metadata`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `get_dsp_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DSPMetadataResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dsp_raw_sample(self, project_id, dsp_id, sample_id, **kwargs):  # noqa: E501
        """Get raw sample  # noqa: E501

        Get raw sample data, but with only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out. If you pass dspId = 0 this will return a raw graph without any processing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_raw_sample(project_id, dsp_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int limit_payload_values: Limit the number of payload values in the response
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetSampleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dsp_raw_sample_with_http_info(project_id, dsp_id, sample_id, **kwargs)  # noqa: E501

    def get_dsp_raw_sample_with_http_info(self, project_id, dsp_id, sample_id, **kwargs):  # noqa: E501
        """Get raw sample  # noqa: E501

        Get raw sample data, but with only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out. If you pass dspId = 0 this will return a raw graph without any processing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_raw_sample_with_http_info(project_id, dsp_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int limit_payload_values: Limit the number of payload values in the response
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetSampleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'sample_id', 'limit_payload_values']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dsp_raw_sample" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_dsp_raw_sample`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `get_dsp_raw_sample`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `get_dsp_raw_sample`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []
        if 'limit_payload_values' in local_var_params and local_var_params['limit_payload_values'] is not None:  # noqa: E501
            query_params.append(('limitPayloadValues', local_var_params['limit_payload_values']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/raw-data/{sampleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSampleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dsp_sample_slice(self, project_id, dsp_id, sample_id, slice_start, slice_end, **kwargs):  # noqa: E501
        """Get raw sample (slice)  # noqa: E501

        Get slice of raw sample data, but with only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_sample_slice(project_id, dsp_id, sample_id, slice_start, slice_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int slice_start: Begin index of the slice (required)
        :param int slice_end: End index of the slice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetSampleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dsp_sample_slice_with_http_info(project_id, dsp_id, sample_id, slice_start, slice_end, **kwargs)  # noqa: E501

    def get_dsp_sample_slice_with_http_info(self, project_id, dsp_id, sample_id, slice_start, slice_end, **kwargs):  # noqa: E501
        """Get raw sample (slice)  # noqa: E501

        Get slice of raw sample data, but with only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dsp_sample_slice_with_http_info(project_id, dsp_id, sample_id, slice_start, slice_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int slice_start: Begin index of the slice (required)
        :param int slice_end: End index of the slice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetSampleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'sample_id', 'slice_start', 'slice_end']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dsp_sample_slice" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `get_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `get_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'slice_start' is set
        if self.api_client.client_side_validation and ('slice_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['slice_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `slice_start` when calling `get_dsp_sample_slice`")  # noqa: E501
        # verify the required parameter 'slice_end' is set
        if self.api_client.client_side_validation and ('slice_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['slice_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `slice_end` when calling `get_dsp_sample_slice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []
        if 'slice_start' in local_var_params and local_var_params['slice_start'] is not None:  # noqa: E501
            query_params.append(('sliceStart', local_var_params['slice_start']))  # noqa: E501
        if 'slice_end' in local_var_params and local_var_params['slice_end'] is not None:  # noqa: E501
            query_params.append(('sliceEnd', local_var_params['slice_end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/raw-data/{sampleId}/slice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSampleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_keras_metadata(self, project_id, learn_id, **kwargs):  # noqa: E501
        """Keras metadata  # noqa: E501

        Get metadata about a trained Keras block. Use the impulse blocks to find the learnId.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_keras_metadata(project_id, learn_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int learn_id: Learn Block ID, use the impulse functions to retrieve the ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: KerasModelMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_keras_metadata_with_http_info(project_id, learn_id, **kwargs)  # noqa: E501

    def get_keras_metadata_with_http_info(self, project_id, learn_id, **kwargs):  # noqa: E501
        """Keras metadata  # noqa: E501

        Get metadata about a trained Keras block. Use the impulse blocks to find the learnId.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_keras_metadata_with_http_info(project_id, learn_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int learn_id: Learn Block ID, use the impulse functions to retrieve the ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(KerasModelMetadata, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'learn_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_keras_metadata" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_keras_metadata`")  # noqa: E501
        # verify the required parameter 'learn_id' is set
        if self.api_client.client_side_validation and ('learn_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['learn_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `learn_id` when calling `get_keras_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'learn_id' in local_var_params:
            path_params['learnId'] = local_var_params['learn_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/training/keras/{learnId}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='KerasModelMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_notes(self, project_id, **kwargs):  # noqa: E501
        """Get notes  # noqa: E501

        Get all notes in project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_notes(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetNotesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_notes_with_http_info(project_id, **kwargs)  # noqa: E501

    def get_notes_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get notes  # noqa: E501

        Get all notes in project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_notes_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetNotesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_notes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_notes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/notes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetNotesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sample(self, project_id, sample_id, **kwargs):  # noqa: E501
        """Get sample  # noqa: E501

        Get a sample.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sample(project_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param int limit_payload_values: Limit the number of payload values in the response
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetSampleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_sample_with_http_info(project_id, sample_id, **kwargs)  # noqa: E501

    def get_sample_with_http_info(self, project_id, sample_id, **kwargs):  # noqa: E501
        """Get sample  # noqa: E501

        Get a sample.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sample_with_http_info(project_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param int limit_payload_values: Limit the number of payload values in the response
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetSampleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'sample_id', 'limit_payload_values']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sample" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_sample`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `get_sample`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []
        if 'limit_payload_values' in local_var_params and local_var_params['limit_payload_values'] is not None:  # noqa: E501
            query_params.append(('limitPayloadValues', local_var_params['limit_payload_values']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/raw-data/{sampleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSampleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sample_as_audio(self, project_id, sample_id, axis_ix, **kwargs):  # noqa: E501
        """Get WAV file  # noqa: E501

        Get a sample as a WAV file. This only applies to samples with an audio axis.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sample_as_audio(project_id, sample_id, axis_ix, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param int axis_ix: Axis index (required)
        :param int slice_start: Begin index of the slice
        :param int slice_end: End index of the slice
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_sample_as_audio_with_http_info(project_id, sample_id, axis_ix, **kwargs)  # noqa: E501

    def get_sample_as_audio_with_http_info(self, project_id, sample_id, axis_ix, **kwargs):  # noqa: E501
        """Get WAV file  # noqa: E501

        Get a sample as a WAV file. This only applies to samples with an audio axis.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sample_as_audio_with_http_info(project_id, sample_id, axis_ix, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param int axis_ix: Axis index (required)
        :param int slice_start: Begin index of the slice
        :param int slice_end: End index of the slice
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'sample_id', 'axis_ix', 'slice_start', 'slice_end']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sample_as_audio" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_sample_as_audio`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `get_sample_as_audio`")  # noqa: E501
        # verify the required parameter 'axis_ix' is set
        if self.api_client.client_side_validation and ('axis_ix' not in local_var_params or  # noqa: E501
                                                        local_var_params['axis_ix'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `axis_ix` when calling `get_sample_as_audio`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []
        if 'axis_ix' in local_var_params and local_var_params['axis_ix'] is not None:  # noqa: E501
            query_params.append(('axisIx', local_var_params['axis_ix']))  # noqa: E501
        if 'slice_start' in local_var_params and local_var_params['slice_start'] is not None:  # noqa: E501
            query_params.append(('sliceStart', local_var_params['slice_start']))  # noqa: E501
        if 'slice_end' in local_var_params and local_var_params['slice_end'] is not None:  # noqa: E501
            query_params.append(('sliceEnd', local_var_params['slice_end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['audio/wav'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/raw-data/{sampleId}/wav', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sample_as_image(self, project_id, sample_id, **kwargs):  # noqa: E501
        """Get image file  # noqa: E501

        Get a sample as an image file. This only applies to samples with RGBA data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sample_as_image(project_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param bool after_input_block: Whether to process the image through the input block first
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_sample_as_image_with_http_info(project_id, sample_id, **kwargs)  # noqa: E501

    def get_sample_as_image_with_http_info(self, project_id, sample_id, **kwargs):  # noqa: E501
        """Get image file  # noqa: E501

        Get a sample as an image file. This only applies to samples with RGBA data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sample_as_image_with_http_info(project_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param bool after_input_block: Whether to process the image through the input block first
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'sample_id', 'after_input_block']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sample_as_image" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_sample_as_image`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `get_sample_as_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []
        if 'after_input_block' in local_var_params and local_var_params['after_input_block'] is not None:  # noqa: E501
            query_params.append(('afterInputBlock', local_var_params['after_input_block']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/jpeg'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/raw-data/{sampleId}/image', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sample_as_raw(self, project_id, sample_id, **kwargs):  # noqa: E501
        """Download file  # noqa: E501

        Download a sample in it's original format as uploaded to the ingestion service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sample_as_raw(project_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_sample_as_raw_with_http_info(project_id, sample_id, **kwargs)  # noqa: E501

    def get_sample_as_raw_with_http_info(self, project_id, sample_id, **kwargs):  # noqa: E501
        """Download file  # noqa: E501

        Download a sample in it's original format as uploaded to the ingestion service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sample_as_raw_with_http_info(project_id, sample_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(file, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'sample_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sample_as_raw" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_sample_as_raw`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `get_sample_as_raw`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/raw-data/{sampleId}/raw', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sample_slice(self, project_id, sample_id, slice_start, slice_end, **kwargs):  # noqa: E501
        """Get sample slice  # noqa: E501

        Get a slice of a sample.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sample_slice(project_id, sample_id, slice_start, slice_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param int slice_start: Begin index of the slice (required)
        :param int slice_end: End index of the slice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetSampleResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_sample_slice_with_http_info(project_id, sample_id, slice_start, slice_end, **kwargs)  # noqa: E501

    def get_sample_slice_with_http_info(self, project_id, sample_id, slice_start, slice_end, **kwargs):  # noqa: E501
        """Get sample slice  # noqa: E501

        Get a slice of a sample.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sample_slice_with_http_info(project_id, sample_id, slice_start, slice_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int sample_id: Sample ID (required)
        :param int slice_start: Begin index of the slice (required)
        :param int slice_end: End index of the slice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetSampleResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'sample_id', 'slice_start', 'slice_end']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sample_slice" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `get_sample_slice`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `get_sample_slice`")  # noqa: E501
        # verify the required parameter 'slice_start' is set
        if self.api_client.client_side_validation and ('slice_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['slice_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `slice_start` when calling `get_sample_slice`")  # noqa: E501
        # verify the required parameter 'slice_end' is set
        if self.api_client.client_side_validation and ('slice_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['slice_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `slice_end` when calling `get_sample_slice`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []
        if 'slice_start' in local_var_params and local_var_params['slice_start'] is not None:  # noqa: E501
            query_params.append(('sliceStart', local_var_params['slice_start']))  # noqa: E501
        if 'slice_end' in local_var_params and local_var_params['slice_end'] is not None:  # noqa: E501
            query_params.append(('sliceEnd', local_var_params['slice_end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/raw-data/{sampleId}/slice', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSampleResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_projects(self, **kwargs):  # noqa: E501
        """List active projects  # noqa: E501

        Retrieve list of active projects. If authenticating using JWT token this lists all the projects the user has access to, if authenticating using an API key, this only lists that project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ListProjectsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_projects_with_http_info(**kwargs)  # noqa: E501

    def list_projects_with_http_info(self, **kwargs):  # noqa: E501
        """List active projects  # noqa: E501

        Retrieve list of active projects. If authenticating using JWT token this lists all the projects the user has access to, if authenticating using an API key, this only lists that project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_projects_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ListProjectsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_projects" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListProjectsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_samples(self, project_id, category, **kwargs):  # noqa: E501
        """List samples  # noqa: E501

        Retrieve all raw data by category.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_samples(project_id, category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param str category: Which of the three acquisition categories to retrieve data from (required)
        :param int limit: Maximum number of results
        :param int offset: Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
        :param bool exclude_sensors: Whether to exclude sensors in the response (as these can slow down requests when you have large pages).
        :param str labels: Only include samples with a label within the given list of labels, given as a JSON string
        :param str filename: Only include samples whose filename includes the given filename
        :param int max_length: Only include samples shorter than the given length, in milliseconds
        :param int min_length: Only include samples longer than the given length, in milliseconds
        :param str signature_validity: Include samples with either valid or invalid signatures
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ListSamplesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_samples_with_http_info(project_id, category, **kwargs)  # noqa: E501

    def list_samples_with_http_info(self, project_id, category, **kwargs):  # noqa: E501
        """List samples  # noqa: E501

        Retrieve all raw data by category.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_samples_with_http_info(project_id, category, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param str category: Which of the three acquisition categories to retrieve data from (required)
        :param int limit: Maximum number of results
        :param int offset: Offset in results, can be used in conjunction with LimitResultsParameter to implement paging.
        :param bool exclude_sensors: Whether to exclude sensors in the response (as these can slow down requests when you have large pages).
        :param str labels: Only include samples with a label within the given list of labels, given as a JSON string
        :param str filename: Only include samples whose filename includes the given filename
        :param int max_length: Only include samples shorter than the given length, in milliseconds
        :param int min_length: Only include samples longer than the given length, in milliseconds
        :param str signature_validity: Include samples with either valid or invalid signatures
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ListSamplesResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'category', 'limit', 'offset', 'exclude_sensors', 'labels', 'filename', 'max_length', 'min_length', 'signature_validity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_samples" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `list_samples`")  # noqa: E501
        # verify the required parameter 'category' is set
        if self.api_client.client_side_validation and ('category' not in local_var_params or  # noqa: E501
                                                        local_var_params['category'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `category` when calling `list_samples`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501

        query_params = []
        if 'category' in local_var_params and local_var_params['category'] is not None:  # noqa: E501
            query_params.append(('category', local_var_params['category']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] is not None:  # noqa: E501
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'exclude_sensors' in local_var_params and local_var_params['exclude_sensors'] is not None:  # noqa: E501
            query_params.append(('excludeSensors', local_var_params['exclude_sensors']))  # noqa: E501
        if 'labels' in local_var_params and local_var_params['labels'] is not None:  # noqa: E501
            query_params.append(('labels', local_var_params['labels']))  # noqa: E501
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  # noqa: E501
            query_params.append(('filename', local_var_params['filename']))  # noqa: E501
        if 'max_length' in local_var_params and local_var_params['max_length'] is not None:  # noqa: E501
            query_params.append(('maxLength', local_var_params['max_length']))  # noqa: E501
        if 'min_length' in local_var_params and local_var_params['min_length'] is not None:  # noqa: E501
            query_params.append(('minLength', local_var_params['min_length']))  # noqa: E501
        if 'signature_validity' in local_var_params and local_var_params['signature_validity'] is not None:  # noqa: E501
            query_params.append(('signatureValidity', local_var_params['signature_validity']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/raw-data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListSamplesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def run_dsp_sample_slice_read_only(self, project_id, dsp_id, sample_id, slice_start, slice_end, **kwargs):  # noqa: E501
        """Get processed sample (slice)  # noqa: E501

        Get slice of sample data, and run it through the DSP block. This only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_dsp_sample_slice_read_only(project_id, dsp_id, sample_id, slice_start, slice_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int slice_start: Begin index of the slice (required)
        :param int slice_end: End index of the slice (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: DspRunResponseWithSample
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.run_dsp_sample_slice_read_only_with_http_info(project_id, dsp_id, sample_id, slice_start, slice_end, **kwargs)  # noqa: E501

    def run_dsp_sample_slice_read_only_with_http_info(self, project_id, dsp_id, sample_id, slice_start, slice_end, **kwargs):  # noqa: E501
        """Get processed sample (slice)  # noqa: E501

        Get slice of sample data, and run it through the DSP block. This only the axes selected by the DSP block. E.g. if you have selected only accX and accY as inputs for the DSP block, but the raw sample also contains accZ, accZ is filtered out.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.run_dsp_sample_slice_read_only_with_http_info(project_id, dsp_id, sample_id, slice_start, slice_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int project_id: Project ID (required)
        :param int dsp_id: DSP Block ID, use the impulse functions to retrieve the ID (required)
        :param int sample_id: Sample ID (required)
        :param int slice_start: Begin index of the slice (required)
        :param int slice_end: End index of the slice (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(DspRunResponseWithSample, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['project_id', 'dsp_id', 'sample_id', 'slice_start', 'slice_end']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_dsp_sample_slice_read_only" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'project_id' is set
        if self.api_client.client_side_validation and ('project_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['project_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `project_id` when calling `run_dsp_sample_slice_read_only`")  # noqa: E501
        # verify the required parameter 'dsp_id' is set
        if self.api_client.client_side_validation and ('dsp_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['dsp_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `dsp_id` when calling `run_dsp_sample_slice_read_only`")  # noqa: E501
        # verify the required parameter 'sample_id' is set
        if self.api_client.client_side_validation and ('sample_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['sample_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sample_id` when calling `run_dsp_sample_slice_read_only`")  # noqa: E501
        # verify the required parameter 'slice_start' is set
        if self.api_client.client_side_validation and ('slice_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['slice_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `slice_start` when calling `run_dsp_sample_slice_read_only`")  # noqa: E501
        # verify the required parameter 'slice_end' is set
        if self.api_client.client_side_validation and ('slice_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['slice_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `slice_end` when calling `run_dsp_sample_slice_read_only`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in local_var_params:
            path_params['projectId'] = local_var_params['project_id']  # noqa: E501
        if 'dsp_id' in local_var_params:
            path_params['dspId'] = local_var_params['dsp_id']  # noqa: E501
        if 'sample_id' in local_var_params:
            path_params['sampleId'] = local_var_params['sample_id']  # noqa: E501

        query_params = []
        if 'slice_start' in local_var_params and local_var_params['slice_start'] is not None:  # noqa: E501
            query_params.append(('sliceStart', local_var_params['slice_start']))  # noqa: E501
        if 'slice_end' in local_var_params and local_var_params['slice_end'] is not None:  # noqa: E501
            query_params.append(('sliceEnd', local_var_params['slice_end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuthentication', 'JWTAuthentication', 'JWTHttpHeaderAuthentication']  # noqa: E501

        return self.api_client.call_api(
            '/api/{projectId}/dsp/{dspId}/raw-data/{sampleId}/slice/run/readonly', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DspRunResponseWithSample',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
