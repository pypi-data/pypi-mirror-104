<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc 0.9.2"/>
<title>eoreader.products.optical.s3_product API documentation</title>
<meta name="description" content="Sentinel-3 products"/>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/darcula.min.css"
crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100%;padding:3em 4em;border-left:1px solid #ddd;overflow-x:hidden}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}table{display:block;overflow-x:auto;word-break:keep-all;border-collapse:separate;border-spacing:0}th{background-color:#c4d5e780;padding:5px;border-bottom:0.1px solid gray;border-right:0.1px solid gray;border-top:0.1px solid gray}td,th{margin:0}td{white-space:nowrap;border-bottom:0.1px solid gray;border-right:0.1px solid gray}td:empty{background-color:#ececec}th:nth-child(1){border-left:0.1px solid gray}td:nth-child(1){border-left:0.1px solid gray;border-right:0.1px solid gray}th:nth-child(1),td:nth-child(1){background-color:#c4d5e7;position:-webkit-sticky;position:sticky;left:0}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML"
integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"
integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eoreader.products.optical.s3_product</code></h1>
</header>
<section id="section-intro">
<p>Sentinel-3 products</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright 2021, SERTIT-ICube - France, https://sertit.unistra.fr/
# This file is part of eoreader project
#     https://github.com/sertit/eoreader
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&#34;&#34;&#34; Sentinel-3 products &#34;&#34;&#34;
import logging
import os
import tempfile
from datetime import datetime
from enum import unique
from functools import reduce
from typing import Union

import geopandas as gpd
import netCDF4
import numpy as np
import rasterio
import xarray as xr
from lxml import etree
from rasterio import features
from rasterio.enums import Resampling
from rasterio.windows import Window

from eoreader import utils
from eoreader.bands.alias import ALL_CLOUDS, CIRRUS, CLOUDS, RAW_CLOUDS
from eoreader.bands.bands import BandNames
from eoreader.bands.bands import OpticalBandNames as obn
from eoreader.env_vars import S3_DEF_RES
from eoreader.exceptions import InvalidProductError, InvalidTypeError
from eoreader.products.optical.optical_product import OpticalProduct
from eoreader.utils import DATETIME_FMT, EOREADER_NAME
from sertit import files, misc, rasters, snap, strings, vectors
from sertit.misc import ListEnum
from sertit.rasters import XDS_TYPE

LOGGER = logging.getLogger(EOREADER_NAME)
BT_BANDS = [obn.MIR, obn.TIR_1, obn.TIR_2]


@unique
class S3ProductType(ListEnum):
    &#34;&#34;&#34;Sentinel-3 products types (not exhaustive, only L1)&#34;&#34;&#34;

    OLCI_EFR = &#34;OL_1_EFR___&#34;
    &#34;&#34;&#34;OLCI EFR Product Type&#34;&#34;&#34;

    SLSTR_RBT = &#34;SL_1_RBT___&#34;
    &#34;&#34;&#34;SLSTR RBT Product Type&#34;&#34;&#34;


@unique
class S3Instrument(ListEnum):
    &#34;&#34;&#34;Sentinel-3 products types&#34;&#34;&#34;

    OLCI = &#34;OLCI&#34;
    &#34;&#34;&#34;OLCI Instrument&#34;&#34;&#34;

    SLSTR = &#34;SLSTR&#34;
    &#34;&#34;&#34;SLSTR Instrument&#34;&#34;&#34;


@unique
class S3DataTypes(ListEnum):
    &#34;&#34;&#34;Sentinel-3 data types -&gt; only considering useful ones&#34;&#34;&#34;

    EFR = &#34;EFR___&#34;
    &#34;&#34;&#34;EFR Data Type, for OLCI instrument&#34;&#34;&#34;

    RBT = &#34;RBT__&#34;
    &#34;&#34;&#34;RBT Data Type, for SLSTR instrument&#34;&#34;&#34;


class S3Product(OpticalProduct):
    &#34;&#34;&#34;
    Class of Sentinel-3 Products

    **Note**: All S3-OLCI bands won&#39;t be used in EOReader !

    **Note**: We only use NADIR rasters for S3-SLSTR bands
    &#34;&#34;&#34;

    def __init__(
        self, product_path: str, archive_path: str = None, output_path=None
    ) -&gt; None:
        self._instrument_name = None
        self._data_type = None
        self._snap_no_data = -1
        super().__init__(
            product_path, archive_path, output_path
        )  # Order is important here

    def _post_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function used to post_init the products
        (setting sensor type, band names and so on)
        &#34;&#34;&#34;
        # Post init done by the super class
        super()._post_init()

    def _set_resolution(self) -&gt; float:
        &#34;&#34;&#34;
        Set product default resolution (in meters)
        &#34;&#34;&#34;
        if self._instrument_name == S3Instrument.OLCI:
            def_res = 300.0
        else:
            def_res = 500.0
        return def_res

    def _set_product_type(self) -&gt; None:
        &#34;&#34;&#34;Get products type&#34;&#34;&#34;
        # Product type
        if self.name[7] != &#34;1&#34;:
            raise InvalidTypeError(&#34;Only L1 products are used for Sentinel-3 data.&#34;)

        if &#34;OL&#34; in self.name:
            # Instrument
            self._instrument_name = S3Instrument.OLCI

            # Data type
            if S3DataTypes.EFR.value in self.name:
                self._data_type = S3DataTypes.EFR
                self.product_type = S3ProductType.OLCI_EFR
            else:
                raise InvalidTypeError(
                    &#34;Only EFR data type is used for Sentinel-3 OLCI data.&#34;
                )

            # Bands
            self.band_names.map_bands(
                {
                    obn.CA: &#34;02&#34;,
                    obn.BLUE: &#34;03&#34;,
                    obn.GREEN: &#34;06&#34;,
                    obn.RED: &#34;08&#34;,
                    obn.VRE_1: &#34;11&#34;,
                    obn.VRE_2: &#34;12&#34;,
                    obn.VRE_3: &#34;16&#34;,
                    obn.NIR: &#34;17&#34;,
                    obn.NARROW_NIR: &#34;17&#34;,
                    obn.WV: &#34;20&#34;,
                    obn.FAR_NIR: &#34;21&#34;,
                }
            )
        elif &#34;SL&#34; in self.name:
            # Instrument
            self._instrument_name = S3Instrument.SLSTR

            # Data type
            if S3DataTypes.RBT.value in self.name:
                self._data_type = S3DataTypes.RBT
                self.product_type = S3ProductType.SLSTR_RBT
            else:
                raise InvalidTypeError(
                    &#34;Only RBT data type is used for Sentinel-3 SLSTR data.&#34;
                )

            # Bands
            self.band_names.map_bands(
                {
                    obn.GREEN: &#34;1&#34;,  # radiance, 500m
                    obn.RED: &#34;2&#34;,  # radiance, 500m
                    obn.NIR: &#34;3&#34;,  # radiance, 500m
                    obn.NARROW_NIR: &#34;3&#34;,  # radiance, 500m
                    obn.SWIR_CIRRUS: &#34;4&#34;,  # radiance, 500m
                    obn.SWIR_1: &#34;5&#34;,  # radiance, 500m
                    obn.SWIR_2: &#34;6&#34;,  # radiance, 500m
                    obn.MIR: &#34;7&#34;,  # brilliance temperature, 1km
                    obn.TIR_1: &#34;8&#34;,  # brilliance temperature, 1km
                    obn.TIR_2: &#34;9&#34;,  # brilliance temperature, 1km
                }
            )
        else:
            raise InvalidProductError(f&#34;Invalid Sentinel-3 name: {self.name}&#34;)

    def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, datetime]:
        &#34;&#34;&#34;
        Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
        datetime.datetime(2019, 11, 15, 23, 37, 22)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
        &#39;20191115T233722&#39;
        ```

        Args:
            as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

        Returns:
             Union[str, datetime.datetime]: Its acquisition datetime
        &#34;&#34;&#34;

        date = self.split_name[4]

        if as_datetime:
            date = datetime.strptime(date, DATETIME_FMT)

        return date

    def _get_snap_band_name(self, band: obn) -&gt; str:
        &#34;&#34;&#34;
        Get SNAP band name.
        Args:
            band (obn): Band as an OpticalBandNames

        Returns:
            str: Band name with SNAP format
        &#34;&#34;&#34;
        # Get band number
        band_nb = self.band_names[band]
        if band_nb is None:
            raise InvalidProductError(
                f&#34;Non existing band ({band.name}) for S3-{self._data_type.name} products&#34;
            )

        # Get band name
        if self._data_type == S3DataTypes.EFR:
            snap_bn = f&#34;Oa{band_nb}_reflectance&#34;  # Converted into reflectance previously in the graph
        elif self._data_type == S3DataTypes.RBT:
            if band in BT_BANDS:
                snap_bn = f&#34;S{band_nb}_BT_in&#34;
            else:
                snap_bn = f&#34;S{band_nb}_reflectance_an&#34;  # Conv into reflectance previously in the graph
        else:
            raise InvalidTypeError(
                f&#34;Unknown data type for Sentinel-3 data: {self._data_type}&#34;
            )

        return snap_bn

    def _get_band_from_filename(self, band_filename: str) -&gt; obn:
        &#34;&#34;&#34;
        Get band from filename
        Args:
            band_filename (str): Band filename

        Returns:
            obn: Band name with SNAP format
        &#34;&#34;&#34;
        # Get band name
        if self._data_type == S3DataTypes.EFR:
            band_nb = band_filename[2:4]
        elif self._data_type == S3DataTypes.RBT:
            band_nb = band_filename[1]
        else:
            raise InvalidTypeError(f&#34;Invalid Sentinel-3 datatype: {self._data_type}&#34;)

        # Get band
        band = list(self.band_names.keys())[
            list(self.band_names.values()).index(band_nb)
        ]

        return band

    def _get_slstr_quality_flags_name(self, band: obn) -&gt; str:
        &#34;&#34;&#34;
        Get SNAP band name.
        Args:
            band (obn): Band as an OpticalBandNames

        Returns:
            str: Quality flag name with SNAP format
        &#34;&#34;&#34;
        # Get band number
        band_nb = self.band_names[band]
        if band_nb is None:
            raise InvalidProductError(
                f&#34;Non existing band ({band.name}) for S3-{self._data_type.name} products&#34;
            )

        # Get quality flag name
        if self._data_type == S3DataTypes.RBT:
            snap_bn = f&#34;S{band_nb}_exception_{&#39;i&#39; if band in BT_BANDS else &#39;a&#39;}n&#34;
        else:
            raise InvalidTypeError(
                f&#34;This function only works for Sentinel-3 SLSTR data: {self._data_type}&#34;
            )

        return snap_bn

    def _get_band_filename(self, band: Union[obn, str]) -&gt; str:
        &#34;&#34;&#34;
        Get band filename from its band type

        Args:
            band ( Union[obn, str]): Band as an OpticalBandNames or directly the snap_name

        Returns:
            str: Band name
        &#34;&#34;&#34;
        if isinstance(band, obn):
            snap_name = self._get_snap_band_name(band)
        elif isinstance(band, str):
            snap_name = band
        else:
            raise InvalidTypeError(
                &#34;The given band should be an OpticalBandNames or directly the snap_name&#34;
            )

        # Remove _an/_in for SLSTR products
        if self._data_type == S3DataTypes.RBT:
            if &#34;cloud&#34; not in snap_name:
                snap_name = snap_name[:-3]
            elif &#34;an&#34; in snap_name:
                snap_name = snap_name[:-3] + &#34;_RAD&#34;
            else:
                # in
                snap_name = snap_name[:-3] + &#34;_BT&#34;

        return snap_name

    def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
        &#34;&#34;&#34;
        Return the paths of required bands.

        .. WARNING:: If not existing, this function will orthorectify your bands !

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
        Executing processing graph
        ...11%...21%...31%...42%...52%...62%...73%...83%... done.
        {
            &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &#39;20191115T233722_S3_SLSTR_RBT\\S1_reflectance.tif&#39;,
            &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;: &#39;20191115T233722_S3_SLSTR_RBT\\S2_reflectance.tif&#39;,
        }
        ```

        Args:
            band_list (list): List of the wanted bands
            resolution (float): Useless here

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        band_paths = {}
        use_snap = False
        for band in band_list:
            # Get standard band names
            band_name = self._get_band_filename(band)

            try:
                # Try to open converted images
                band_paths[band] = files.get_file_in_dir(
                    self._get_band_folder(), band_name + &#34;.tif&#34;
                )
            except (FileNotFoundError, TypeError):
                use_snap = True

        # If not existing (file or output), convert them
        if use_snap:
            all_band_paths = self._preprocess_s3(resolution)
            band_paths = {band: all_band_paths[band] for band in band_list}

        return band_paths

    # pylint: disable=W0613
    def _read_band(
        self,
        path: str,
        resolution: Union[tuple, list, float] = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Read band from a dataset.

        .. WARNING::
            Invalid pixels are not managed here !

        Args:
            path (str): Band dataset
            resolution (Union[tuple, list, float]): Resolution of the wanted band, in dataset resolution unit (X, Y)
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            XDS_TYPE: Band xarray

        &#34;&#34;&#34;
        # Read band
        return rasters.read(
            path, resolution=resolution, size=size, resampling=Resampling.bilinear
        )

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    def _manage_invalid_pixels(
        self,
        band_arr: XDS_TYPE,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...)

        Args:
            band_arr (XDS_TYPE): Band array
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            XDS_TYPE: Cleaned band array
        &#34;&#34;&#34;
        if self._instrument_name == S3Instrument.OLCI:
            band_arr_mask = self._manage_invalid_pixels_olci(
                band_arr, band, resolution=resolution, size=size
            )
        else:
            band_arr_mask = self._manage_invalid_pixels_slstr(
                band_arr, band, resolution=resolution, size=size
            )

        return band_arr_mask

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    def _manage_invalid_pixels_olci(
        self,
        band_arr: XDS_TYPE,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...) for OLCI data.
        See there:
        https://sentinel.esa.int/documents/247904/1872756/Sentinel-3-OLCI-Product-Data-Format-Specification-OLCI-Level-1

        QUALITY FLAGS (From end to start of the 32 bits):
        | Bit |  Flag               |
        |----|----------------------|
        | 0  |   saturated21        |
        | 1  |   saturated20        |
        | 2  |   saturated19        |
        | 3  |   saturated18        |
        | 4  |   saturated17        |
        | 5  |   saturated16        |
        | 6  |   saturated15        |
        | 7  |   saturated14        |
        | 8  |   saturated13        |
        | 9  |   saturated12        |
        | 10 |   saturated11        |
        | 11 |   saturated10        |
        | 11 |   saturated09        |
        | 12 |   saturated08        |
        | 13 |   saturated07        |
        | 14 |   saturated06        |
        | 15 |   saturated05        |
        | 16 |   saturated04        |
        | 17 |   saturated03        |
        | 18 |   saturated02        |
        | 19 |   saturated01        |
        | 20 |   dubious            |
        | 21 |   sun-glint_risk     |
        | 22 |   duplicated         |
        | 23 |   cosmetic           |
        | 24 |   invalid            |
        | 25 |   straylight_risk    |
        | 26 |   bright             |
        | 27 |   tidal_region       |
        | 28 |   fresh_inland_water |
        | 19 |   coastline          |
        | 30 |   land               |

        Args:
            band_arr (XDS_TYPE): Band array
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            XDS_TYPE: Cleaned band array
        &#34;&#34;&#34;
        nodata_true = 1
        nodata_false = 0

        # Bit ids
        band_bit_id = {
            obn.CA: 18,  # Band 2
            obn.BLUE: 17,  # Band 3
            obn.GREEN: 14,  # Band 6
            obn.RED: 12,  # Band 8
            obn.VRE_1: 10,  # Band 11
            obn.VRE_2: 9,  # Band 12
            obn.VRE_3: 5,  # Band 16
            obn.NIR: 4,  # Band 17
            obn.NARROW_NIR: 4,  # Band 17
            obn.WV: 1,  # Band 20
            obn.FAR_NIR: 0,  # Band 21
        }
        invalid_id = 24
        sat_band_id = band_bit_id[band]

        # Open quality flags
        qual_flags_path = os.path.join(self._get_band_folder(), &#34;quality_flags.tif&#34;)
        if not os.path.isfile(qual_flags_path):
            LOGGER.warning(
                &#34;Impossible to open quality flags %s. Taking the band as is.&#34;,
                qual_flags_path,
            )
            return band_arr

        # Open flag file
        qual_arr = rasters.read(
            qual_flags_path,
            resolution=resolution,
            size=size,
            resampling=Resampling.nearest,  # Nearest to keep the flags
            masked=False,
        ).astype(np.uint32)
        invalid, sat = rasters.read_bit_array(qual_arr, [invalid_id, sat_band_id])

        # Get nodata mask
        no_data = np.where(np.isnan(band_arr.data), nodata_true, nodata_false)

        # Combine masks
        mask = no_data | invalid | sat

        # DO not set 0 to epsilons as they are a part of the
        return self._set_nodata_mask(band_arr, mask)

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    def _manage_invalid_pixels_slstr(
        self,
        band_arr: XDS_TYPE,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...)

        ISP_absent pixel_absent not_decompressed no_signal saturation invalid_radiance no_parameters unfilled_pixel&#34;

        Args:
            band_arr (XDS_TYPE): Band array
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            XDS_TYPE: Cleaned band array
        &#34;&#34;&#34;
        nodata_true = 1
        nodata_false = 0

        # Open quality flags (discard _an/_in)
        qual_flags_path = os.path.join(
            self._get_band_folder(),
            self._get_slstr_quality_flags_name(band)[:-3] + &#34;.tif&#34;,
        )
        if not os.path.isfile(qual_flags_path):
            LOGGER.warning(
                &#34;Impossible to open quality flags %s. Taking the band as is.&#34;,
                qual_flags_path,
            )
            return band_arr

        # Open flag file
        qual_arr = rasters.read(
            qual_flags_path,
            resolution=resolution,
            size=size,
            resampling=Resampling.nearest,  # Nearest to keep the flags
            masked=False,
        )

        # Set no data for everything (except ISP) that caused an exception
        exception = np.where(qual_arr.data &gt; 2, nodata_true, nodata_false)

        # Get nodata mask
        no_data = np.where(np.isnan(band_arr.data), nodata_true, nodata_false)

        # Combine masks
        mask = no_data | exception

        # DO not set 0 to epsilons as they are a part of the
        return self._set_nodata_mask(band_arr, mask)

    def _load_bands(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load bands as numpy arrays with the same resolution (and same metadata).

        Args:
            bands (list): List of the wanted bands
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        # Return empty if no band are specified
        if not bands:
            return {}

        # Get band paths
        if not isinstance(bands, list):
            bands = [bands]
        band_paths = self.get_band_paths(bands)

        # Open bands and get array (resampled if needed)
        band_arrays = self._open_bands(band_paths, resolution=resolution, size=size)

        return band_arrays

    def _preprocess_s3(self, resolution: float = None):
        &#34;&#34;&#34;
        pre-process S3 bands (orthorectify...)

        Args:
            resolution (float): Resolution

        Returns:
            dict: Dictionary containing {band: path}
        &#34;&#34;&#34;

        band_paths = {}

        # DIM in tmp files
        with tempfile.TemporaryDirectory() as tmp_dir:
            # out_dim = os.path.join(self.output, self.condensed_name + &#34;.dim&#34;)  # DEBUG OPTION
            out_dim = os.path.join(tmp_dir, self.condensed_name + &#34;.dim&#34;)

            # Run GPT graph
            processed_bands = self._run_s3_gpt_cli(out_dim, resolution)

            # Save all processed bands and quality flags into GeoTIFFs
            for snap_band_name in processed_bands:
                # Get standard band names
                band_name = self._get_band_filename(snap_band_name)

                # Remove tif if already existing
                # (if we are here, sth has failed when creating them, so delete them all)
                out_tif = os.path.join(self.output, band_name + &#34;.tif&#34;)
                if os.path.isfile(out_tif):
                    files.remove(out_tif)

                # Convert to geotiffs and set no data with only keeping the first band
                arr = rasters.read(rasters.get_dim_img_path(out_dim, snap_band_name))
                arr = rasters.set_nodata(
                    xr.where(arr == self._snap_no_data, self.nodata, arr), self.nodata
                )
                rasters.write(arr, out_tif, dtype=np.float32)

        # Get the wanted bands (not the quality flags here !)
        for band in processed_bands:
            filename = self._get_band_filename(band)
            if &#34;exception&#34; not in filename:
                out_tif = os.path.join(self.output, filename + &#34;.tif&#34;)
                if not os.path.isfile(out_tif):
                    raise FileNotFoundError(
                        f&#34;Error when processing S3 bands with SNAP. Couldn&#39;t find {out_tif}&#34;
                    )

                # Quality flags will crash here
                try:
                    band_paths[self._get_band_from_filename(filename)] = out_tif
                except ValueError:
                    pass

        return band_paths

    def _run_s3_gpt_cli(self, out_dim: str, resolution: float = None) -&gt; list:
        &#34;&#34;&#34;
        Construct GPT command line to reproject S3 images and quality flags

        Args:
            out_dim (str): Out DIMAP name
            resolution (float): Resolution

        Returns:
            list: Processed band name
        &#34;&#34;&#34;
        # Default resolution
        def_res = os.environ.get(S3_DEF_RES, self.resolution)

        # Construct GPT graph
        graph_path = os.path.join(utils.get_data_dir(), &#34;preprocess_s3.xml&#34;)
        snap_bands = &#34;,&#34;.join(
            [
                self._get_snap_band_name(band)
                for band, band_nb in self.band_names.items()
                if band_nb
            ]
        )
        if self._instrument_name == S3Instrument.OLCI:
            sensor = &#34;OLCI&#34;
            fmt = &#34;Sen3&#34;
            snap_bands += &#34;,quality_flags&#34;
        else:
            sensor = &#34;SLSTR_500m&#34;
            fmt = &#34;Sen3_SLSTRL1B_500m&#34;
            exception_bands = &#34;,&#34;.join(
                [
                    self._get_slstr_quality_flags_name(band)
                    for band, band_nb in self.band_names.items()
                    if band_nb
                ]
            )
            snap_bands += f&#34;,{exception_bands},cloud_an,cloud_in&#34;

        # Run GPT graph
        cmd_list = snap.get_gpt_cli(
            graph_path,
            [
                f&#34;-Pin={strings.to_cmd_string(self.path)}&#34;,
                f&#34;-Pbands={snap_bands}&#34;,
                f&#34;-Psensor={sensor}&#34;,
                f&#34;-Pformat={fmt}&#34;,
                f&#34;-Pno_data={self._snap_no_data}&#34;,
                f&#34;-Pres_m={resolution if resolution else def_res}&#34;,
                f&#34;-Pout={strings.to_cmd_string(out_dim)}&#34;,
            ],
            display_snap_opt=LOGGER.level == logging.DEBUG,
        )
        LOGGER.debug(&#34;Converting %s&#34;, self.name)
        misc.run_cli(cmd_list)

        return snap_bands.split(&#34;,&#34;)

    def extent(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        Get UTM extent of the tile, managing the case with not orthorectified bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.utm_extent()
                                                    geometry
        0  POLYGON ((1488846.028 6121896.451, 1488846.028...
        ```

        Returns:
            gpd.GeoDataFrame: Footprint in UTM
        &#34;&#34;&#34;
        try:
            extent = super().extent()

        except (FileNotFoundError, TypeError) as ex:

            def get_min_max(substr: str, subdatasets: list) -&gt; (float, float):
                &#34;&#34;&#34;
                Get min/max of a subdataset array
                Args:
                    substr: Substring to identfy the subdataset
                    subdatasets: List of subdatasets

                Returns:
                    float, float: min/max of the subdataset
                &#34;&#34;&#34;
                path = [path for path in subdatasets if substr in path][0]
                with rasterio.open(path, &#34;r&#34;) as sub_ds:
                    # Open the 4 corners of the array
                    height = sub_ds.height
                    width = sub_ds.width
                    scales = sub_ds.scales
                    pt1 = sub_ds.read(1, window=Window(0, 0, 1, 1)) * scales
                    pt2 = sub_ds.read(1, window=Window(width - 1, 0, width, 1)) * scales
                    pt3 = (
                        sub_ds.read(1, window=Window(0, height - 1, 1, height)) * scales
                    )
                    pt4 = (
                        sub_ds.read(
                            1, window=Window(width - 1, height - 1, width, height)
                        )
                        * scales
                    )
                    pt_list = [pt1, pt2, pt3, pt4]

                    # Return min and max
                    return np.min(pt_list), np.max(pt_list)

            if self.product_type == S3ProductType.OLCI_EFR:
                # Open geodetic_an.nc
                geom_file = os.path.join(
                    self.path, &#34;geo_coordinates.nc&#34;
                )  # Only use nadir files

                with rasterio.open(geom_file, &#34;r&#34;) as geom_ds:
                    lat_min, lat_max = get_min_max(&#34;latitude&#34;, geom_ds.subdatasets)
                    lon_min, lon_max = get_min_max(&#34;longitude&#34;, geom_ds.subdatasets)

            elif self.product_type == S3ProductType.SLSTR_RBT:
                # Open geodetic_an.nc
                geom_file = os.path.join(
                    self.path, &#34;geodetic_an.nc&#34;
                )  # Only use nadir files

                with rasterio.open(geom_file, &#34;r&#34;) as geom_ds:
                    lat_min, lat_max = get_min_max(&#34;latitude_an&#34;, geom_ds.subdatasets)
                    lon_min, lon_max = get_min_max(&#34;longitude_an&#34;, geom_ds.subdatasets)
            else:
                raise InvalidTypeError(
                    f&#34;Invalid products type {self.product_type}&#34;
                ) from ex

            # Create wgs84 extent (left, bottom, right, top)
            extent_wgs84 = gpd.GeoDataFrame(
                geometry=[
                    vectors.from_bounds_to_polygon(lon_min, lat_min, lon_max, lat_max)
                ],
                crs=vectors.WGS84,
            )

            # Get upper-left corner and deduce UTM proj from it
            utm = vectors.corresponding_utm_projection(
                extent_wgs84.bounds.minx, extent_wgs84.bounds.maxy
            )
            extent = extent_wgs84.to_crs(utm)

        return extent

    def _get_condensed_name(self) -&gt; str:
        &#34;&#34;&#34;
        Get S2 products condensed name ({date}_S2_{tile]_{product_type}).

        Returns:
            str: Condensed S2 name
        &#34;&#34;&#34;
        return f&#34;{self.get_datetime()}_S3_{self.product_type.name}&#34;

    def get_mean_sun_angles(self) -&gt; (float, float):
        &#34;&#34;&#34;
        Get Mean Sun angles (Azimuth and Zenith angles)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_mean_sun_angles()
        (78.55043955912154, 31.172127033319388)
        ```

        Returns:
            (float, float): Mean Azimuth and Zenith angle
        &#34;&#34;&#34;
        if self._data_type == S3DataTypes.EFR:
            geom_file = os.path.join(self.path, &#34;tie_geometries.nc&#34;)
            sun_az = &#34;SAA&#34;
            sun_ze = &#34;SZA&#34;
        elif self._data_type == S3DataTypes.RBT:
            geom_file = os.path.join(
                self.path, &#34;geometry_tn.nc&#34;
            )  # Only use nadir files
            sun_az = &#34;solar_azimuth_tn&#34;
            sun_ze = &#34;solar_zenith_tn&#34;
        else:
            raise InvalidTypeError(
                f&#34;Unknown/Unsupported data type for Sentinel-3 data: {self._data_type}&#34;
            )

        # Open file
        if os.path.isfile(geom_file):
            # Bug pylint with netCDF4
            # pylint: disable=E1101
            netcdf_ds = netCDF4.Dataset(geom_file)

            # Get variables
            sun_az_var = netcdf_ds.variables[sun_az]
            sun_ze_var = netcdf_ds.variables[sun_ze]

            # Get sun angles as the mean of whole arrays
            azimuth_angle = float(np.mean(sun_az_var[:]))
            zenith_angle = float(np.mean(sun_ze_var[:]))

            # Close dataset
            netcdf_ds.close()
        else:
            raise InvalidProductError(f&#34;Geometry file {geom_file} not found&#34;)

        return azimuth_angle, zenith_angle

    def read_mtd(self) -&gt; (etree._Element, str):
        &#34;&#34;&#34;
        Read metadata and outputs the metadata XML root and its namespace

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.read_mtd()
        (&lt;Element level1Product at 0x1b845b7ab88&gt;, &#39;&#39;)
        ```

        Returns:
            (etree._Element, str): Metadata XML root and its namespace
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;Sentinel-3 products don&#39;t have XML metadata. &#34;
            &#34;Please check directly into NetCDF files&#34;
        )

    def _has_cloud_band(self, band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?

        - SLSTR does
        - OLCI does not provide any cloud mask
        ```
        &#34;&#34;&#34;
        if self._instrument_name == S3Instrument.SLSTR and band in [
            RAW_CLOUDS,
            ALL_CLOUDS,
            CLOUDS,
            CIRRUS,
        ]:
            has_band = True
        else:
            has_band = False

        return has_band

    def _load_clouds(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read S3 SLSTR clouds from the flags file:cloud netcdf file.
        https://sentinels.copernicus.eu/web/sentinel/technical-guides/sentinel-3-slstr/level-1/cloud-identification

        bit_id  flag_masks (ushort)     flag_meanings
        ===     ===                     ===
        0       1US                     visible
        1       2US                     1.37_threshold
        2       4US                     1.6_small_histogram
        3       8US                     1.6_large_histogram
        4       16US                    2.25_small_histogram
        5       32US                    2.25_large_histogram
        6       64US                    11_spatial_coherence
        7       128US                   gross_cloud
        8       256US                   thin_cirrus
        9       512US                   medium_high
        10      1024US                  fog_low_stratus
        11      2048US                  11_12_view_difference
        12      4096US                  3.7_11_view_difference
        13      8192US                  thermal_histogram
        14      16384US                 spare
        15      32768US                 spare

        Args:
            bands (list): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        band_dict = {}

        if bands:
            if self._instrument_name == S3Instrument.OLCI:
                raise InvalidTypeError(
                    &#34;Sentinel-3 OLCI sensor does not provide any cloud file.&#34;
                )

            all_ids = list(np.arange(0, 14))
            cir_id = 8
            cloud_ids = [id for id in all_ids if id != cir_id]

            try:
                cloud_path = files.get_file_in_dir(
                    self._get_band_folder(), &#34;cloud_RAD.tif&#34;
                )
            except FileNotFoundError:
                self._preprocess_s3(resolution)
                cloud_path = files.get_file_in_dir(self.output, &#34;cloud_RAD.tif&#34;)

            if not cloud_path:
                raise FileNotFoundError(
                    f&#34;Unable to find the cloud mask for {self.path}&#34;
                )

            # Open cloud file
            clouds_array = rasters.read(
                cloud_path,
                resolution=resolution,
                size=size,
                resampling=Resampling.nearest,
                masked=False,
            ).astype(np.uint16)

            # Get nodata mask
            # nodata = np.where(np.isnan(clouds_array), 1, 0)
            nodata = np.where(clouds_array == 65535, 1, 0)

            for band in bands:
                if band == ALL_CLOUDS:
                    band_dict[band] = self._create_mask(clouds_array, all_ids, nodata)
                elif band == CLOUDS:
                    band_dict[band] = self._create_mask(clouds_array, cloud_ids, nodata)
                elif band == CIRRUS:
                    band_dict[band] = self._create_mask(clouds_array, cir_id, nodata)
                elif band == RAW_CLOUDS:
                    band_dict[band] = clouds_array
                else:
                    raise InvalidTypeError(
                        f&#34;Non existing cloud band for Sentinel-3 SLSTR: {band}&#34;
                    )

        return band_dict

    def _create_mask(
        self,
        bit_array: xr.DataArray,
        bit_ids: Union[int, list],
        nodata: np.ndarray,
    ) -&gt; xr.DataArray:
        &#34;&#34;&#34;
        Create a mask masked array (uint8) from a bit array, bit IDs and a nodata mask.

        Args:
            bit_array (xr.DataArray): Conditional array
            bit_ids (Union[int, list]): Bit IDs
            nodata (np.ndarray): Nodata mask

        Returns:
            xr.DataArray: Mask masked array

        &#34;&#34;&#34;
        if not isinstance(bit_ids, list):
            bit_ids = [bit_ids]
        conds = rasters.read_bit_array(bit_array, bit_ids)
        cond = reduce(lambda x, y: x | y, conds)  # Use every conditions (bitwise or)

        cond_arr = np.where(cond, self._mask_true, self._mask_false).astype(np.uint8)
        cond_arr = np.squeeze(cond_arr)
        cond_arr = features.sieve(cond_arr, size=10, connectivity=4)
        cond_arr = np.expand_dims(cond_arr, axis=0)

        return super()._create_mask(bit_array, cond_arr, nodata)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eoreader.products.optical.s3_product.S3ProductType"><code class="flex name class">
<span>class <span class="ident">S3ProductType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Sentinel-3 products types (not exhaustive, only L1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class S3ProductType(ListEnum):
    &#34;&#34;&#34;Sentinel-3 products types (not exhaustive, only L1)&#34;&#34;&#34;

    OLCI_EFR = &#34;OL_1_EFR___&#34;
    &#34;&#34;&#34;OLCI EFR Product Type&#34;&#34;&#34;

    SLSTR_RBT = &#34;SL_1_RBT___&#34;
    &#34;&#34;&#34;SLSTR RBT Product Type&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sertit.misc.ListEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eoreader.products.optical.s3_product.S3ProductType.OLCI_EFR"><code class="name">var <span class="ident">OLCI_EFR</span></code>
</dt>
<dd>
<div class="desc"><p>OLCI EFR Product Type</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3ProductType.SLSTR_RBT"><code class="name">var <span class="ident">SLSTR_RBT</span></code>
</dt>
<dd>
<div class="desc"><p>SLSTR RBT Product Type</p></div>
</dd>
</dl>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Instrument"><code class="flex name class">
<span>class <span class="ident">S3Instrument</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Sentinel-3 products types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class S3Instrument(ListEnum):
    &#34;&#34;&#34;Sentinel-3 products types&#34;&#34;&#34;

    OLCI = &#34;OLCI&#34;
    &#34;&#34;&#34;OLCI Instrument&#34;&#34;&#34;

    SLSTR = &#34;SLSTR&#34;
    &#34;&#34;&#34;SLSTR Instrument&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sertit.misc.ListEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eoreader.products.optical.s3_product.S3Instrument.OLCI"><code class="name">var <span class="ident">OLCI</span></code>
</dt>
<dd>
<div class="desc"><p>OLCI Instrument</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Instrument.SLSTR"><code class="name">var <span class="ident">SLSTR</span></code>
</dt>
<dd>
<div class="desc"><p>SLSTR Instrument</p></div>
</dd>
</dl>
</dd>
<dt id="eoreader.products.optical.s3_product.S3DataTypes"><code class="flex name class">
<span>class <span class="ident">S3DataTypes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Sentinel-3 data types -&gt; only considering useful ones</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class S3DataTypes(ListEnum):
    &#34;&#34;&#34;Sentinel-3 data types -&gt; only considering useful ones&#34;&#34;&#34;

    EFR = &#34;EFR___&#34;
    &#34;&#34;&#34;EFR Data Type, for OLCI instrument&#34;&#34;&#34;

    RBT = &#34;RBT__&#34;
    &#34;&#34;&#34;RBT Data Type, for SLSTR instrument&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sertit.misc.ListEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eoreader.products.optical.s3_product.S3DataTypes.EFR"><code class="name">var <span class="ident">EFR</span></code>
</dt>
<dd>
<div class="desc"><p>EFR Data Type, for OLCI instrument</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3DataTypes.RBT"><code class="name">var <span class="ident">RBT</span></code>
</dt>
<dd>
<div class="desc"><p>RBT Data Type, for SLSTR instrument</p></div>
</dd>
</dl>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product"><code class="flex name class">
<span>class <span class="ident">S3Product</span></span>
<span>(</span><span>product_path, archive_path=None, output_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class of Sentinel-3 Products</p>
<p><strong>Note</strong>: All S3-OLCI bands won't be used in EOReader !</p>
<p><strong>Note</strong>: We only use NADIR rasters for S3-SLSTR bands</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class S3Product(OpticalProduct):
    &#34;&#34;&#34;
    Class of Sentinel-3 Products

    **Note**: All S3-OLCI bands won&#39;t be used in EOReader !

    **Note**: We only use NADIR rasters for S3-SLSTR bands
    &#34;&#34;&#34;

    def __init__(
        self, product_path: str, archive_path: str = None, output_path=None
    ) -&gt; None:
        self._instrument_name = None
        self._data_type = None
        self._snap_no_data = -1
        super().__init__(
            product_path, archive_path, output_path
        )  # Order is important here

    def _post_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function used to post_init the products
        (setting sensor type, band names and so on)
        &#34;&#34;&#34;
        # Post init done by the super class
        super()._post_init()

    def _set_resolution(self) -&gt; float:
        &#34;&#34;&#34;
        Set product default resolution (in meters)
        &#34;&#34;&#34;
        if self._instrument_name == S3Instrument.OLCI:
            def_res = 300.0
        else:
            def_res = 500.0
        return def_res

    def _set_product_type(self) -&gt; None:
        &#34;&#34;&#34;Get products type&#34;&#34;&#34;
        # Product type
        if self.name[7] != &#34;1&#34;:
            raise InvalidTypeError(&#34;Only L1 products are used for Sentinel-3 data.&#34;)

        if &#34;OL&#34; in self.name:
            # Instrument
            self._instrument_name = S3Instrument.OLCI

            # Data type
            if S3DataTypes.EFR.value in self.name:
                self._data_type = S3DataTypes.EFR
                self.product_type = S3ProductType.OLCI_EFR
            else:
                raise InvalidTypeError(
                    &#34;Only EFR data type is used for Sentinel-3 OLCI data.&#34;
                )

            # Bands
            self.band_names.map_bands(
                {
                    obn.CA: &#34;02&#34;,
                    obn.BLUE: &#34;03&#34;,
                    obn.GREEN: &#34;06&#34;,
                    obn.RED: &#34;08&#34;,
                    obn.VRE_1: &#34;11&#34;,
                    obn.VRE_2: &#34;12&#34;,
                    obn.VRE_3: &#34;16&#34;,
                    obn.NIR: &#34;17&#34;,
                    obn.NARROW_NIR: &#34;17&#34;,
                    obn.WV: &#34;20&#34;,
                    obn.FAR_NIR: &#34;21&#34;,
                }
            )
        elif &#34;SL&#34; in self.name:
            # Instrument
            self._instrument_name = S3Instrument.SLSTR

            # Data type
            if S3DataTypes.RBT.value in self.name:
                self._data_type = S3DataTypes.RBT
                self.product_type = S3ProductType.SLSTR_RBT
            else:
                raise InvalidTypeError(
                    &#34;Only RBT data type is used for Sentinel-3 SLSTR data.&#34;
                )

            # Bands
            self.band_names.map_bands(
                {
                    obn.GREEN: &#34;1&#34;,  # radiance, 500m
                    obn.RED: &#34;2&#34;,  # radiance, 500m
                    obn.NIR: &#34;3&#34;,  # radiance, 500m
                    obn.NARROW_NIR: &#34;3&#34;,  # radiance, 500m
                    obn.SWIR_CIRRUS: &#34;4&#34;,  # radiance, 500m
                    obn.SWIR_1: &#34;5&#34;,  # radiance, 500m
                    obn.SWIR_2: &#34;6&#34;,  # radiance, 500m
                    obn.MIR: &#34;7&#34;,  # brilliance temperature, 1km
                    obn.TIR_1: &#34;8&#34;,  # brilliance temperature, 1km
                    obn.TIR_2: &#34;9&#34;,  # brilliance temperature, 1km
                }
            )
        else:
            raise InvalidProductError(f&#34;Invalid Sentinel-3 name: {self.name}&#34;)

    def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, datetime]:
        &#34;&#34;&#34;
        Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
        datetime.datetime(2019, 11, 15, 23, 37, 22)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
        &#39;20191115T233722&#39;
        ```

        Args:
            as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

        Returns:
             Union[str, datetime.datetime]: Its acquisition datetime
        &#34;&#34;&#34;

        date = self.split_name[4]

        if as_datetime:
            date = datetime.strptime(date, DATETIME_FMT)

        return date

    def _get_snap_band_name(self, band: obn) -&gt; str:
        &#34;&#34;&#34;
        Get SNAP band name.
        Args:
            band (obn): Band as an OpticalBandNames

        Returns:
            str: Band name with SNAP format
        &#34;&#34;&#34;
        # Get band number
        band_nb = self.band_names[band]
        if band_nb is None:
            raise InvalidProductError(
                f&#34;Non existing band ({band.name}) for S3-{self._data_type.name} products&#34;
            )

        # Get band name
        if self._data_type == S3DataTypes.EFR:
            snap_bn = f&#34;Oa{band_nb}_reflectance&#34;  # Converted into reflectance previously in the graph
        elif self._data_type == S3DataTypes.RBT:
            if band in BT_BANDS:
                snap_bn = f&#34;S{band_nb}_BT_in&#34;
            else:
                snap_bn = f&#34;S{band_nb}_reflectance_an&#34;  # Conv into reflectance previously in the graph
        else:
            raise InvalidTypeError(
                f&#34;Unknown data type for Sentinel-3 data: {self._data_type}&#34;
            )

        return snap_bn

    def _get_band_from_filename(self, band_filename: str) -&gt; obn:
        &#34;&#34;&#34;
        Get band from filename
        Args:
            band_filename (str): Band filename

        Returns:
            obn: Band name with SNAP format
        &#34;&#34;&#34;
        # Get band name
        if self._data_type == S3DataTypes.EFR:
            band_nb = band_filename[2:4]
        elif self._data_type == S3DataTypes.RBT:
            band_nb = band_filename[1]
        else:
            raise InvalidTypeError(f&#34;Invalid Sentinel-3 datatype: {self._data_type}&#34;)

        # Get band
        band = list(self.band_names.keys())[
            list(self.band_names.values()).index(band_nb)
        ]

        return band

    def _get_slstr_quality_flags_name(self, band: obn) -&gt; str:
        &#34;&#34;&#34;
        Get SNAP band name.
        Args:
            band (obn): Band as an OpticalBandNames

        Returns:
            str: Quality flag name with SNAP format
        &#34;&#34;&#34;
        # Get band number
        band_nb = self.band_names[band]
        if band_nb is None:
            raise InvalidProductError(
                f&#34;Non existing band ({band.name}) for S3-{self._data_type.name} products&#34;
            )

        # Get quality flag name
        if self._data_type == S3DataTypes.RBT:
            snap_bn = f&#34;S{band_nb}_exception_{&#39;i&#39; if band in BT_BANDS else &#39;a&#39;}n&#34;
        else:
            raise InvalidTypeError(
                f&#34;This function only works for Sentinel-3 SLSTR data: {self._data_type}&#34;
            )

        return snap_bn

    def _get_band_filename(self, band: Union[obn, str]) -&gt; str:
        &#34;&#34;&#34;
        Get band filename from its band type

        Args:
            band ( Union[obn, str]): Band as an OpticalBandNames or directly the snap_name

        Returns:
            str: Band name
        &#34;&#34;&#34;
        if isinstance(band, obn):
            snap_name = self._get_snap_band_name(band)
        elif isinstance(band, str):
            snap_name = band
        else:
            raise InvalidTypeError(
                &#34;The given band should be an OpticalBandNames or directly the snap_name&#34;
            )

        # Remove _an/_in for SLSTR products
        if self._data_type == S3DataTypes.RBT:
            if &#34;cloud&#34; not in snap_name:
                snap_name = snap_name[:-3]
            elif &#34;an&#34; in snap_name:
                snap_name = snap_name[:-3] + &#34;_RAD&#34;
            else:
                # in
                snap_name = snap_name[:-3] + &#34;_BT&#34;

        return snap_name

    def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
        &#34;&#34;&#34;
        Return the paths of required bands.

        .. WARNING:: If not existing, this function will orthorectify your bands !

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
        Executing processing graph
        ...11%...21%...31%...42%...52%...62%...73%...83%... done.
        {
            &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &#39;20191115T233722_S3_SLSTR_RBT\\S1_reflectance.tif&#39;,
            &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;: &#39;20191115T233722_S3_SLSTR_RBT\\S2_reflectance.tif&#39;,
        }
        ```

        Args:
            band_list (list): List of the wanted bands
            resolution (float): Useless here

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        band_paths = {}
        use_snap = False
        for band in band_list:
            # Get standard band names
            band_name = self._get_band_filename(band)

            try:
                # Try to open converted images
                band_paths[band] = files.get_file_in_dir(
                    self._get_band_folder(), band_name + &#34;.tif&#34;
                )
            except (FileNotFoundError, TypeError):
                use_snap = True

        # If not existing (file or output), convert them
        if use_snap:
            all_band_paths = self._preprocess_s3(resolution)
            band_paths = {band: all_band_paths[band] for band in band_list}

        return band_paths

    # pylint: disable=W0613
    def _read_band(
        self,
        path: str,
        resolution: Union[tuple, list, float] = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Read band from a dataset.

        .. WARNING::
            Invalid pixels are not managed here !

        Args:
            path (str): Band dataset
            resolution (Union[tuple, list, float]): Resolution of the wanted band, in dataset resolution unit (X, Y)
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            XDS_TYPE: Band xarray

        &#34;&#34;&#34;
        # Read band
        return rasters.read(
            path, resolution=resolution, size=size, resampling=Resampling.bilinear
        )

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    def _manage_invalid_pixels(
        self,
        band_arr: XDS_TYPE,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...)

        Args:
            band_arr (XDS_TYPE): Band array
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            XDS_TYPE: Cleaned band array
        &#34;&#34;&#34;
        if self._instrument_name == S3Instrument.OLCI:
            band_arr_mask = self._manage_invalid_pixels_olci(
                band_arr, band, resolution=resolution, size=size
            )
        else:
            band_arr_mask = self._manage_invalid_pixels_slstr(
                band_arr, band, resolution=resolution, size=size
            )

        return band_arr_mask

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    def _manage_invalid_pixels_olci(
        self,
        band_arr: XDS_TYPE,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...) for OLCI data.
        See there:
        https://sentinel.esa.int/documents/247904/1872756/Sentinel-3-OLCI-Product-Data-Format-Specification-OLCI-Level-1

        QUALITY FLAGS (From end to start of the 32 bits):
        | Bit |  Flag               |
        |----|----------------------|
        | 0  |   saturated21        |
        | 1  |   saturated20        |
        | 2  |   saturated19        |
        | 3  |   saturated18        |
        | 4  |   saturated17        |
        | 5  |   saturated16        |
        | 6  |   saturated15        |
        | 7  |   saturated14        |
        | 8  |   saturated13        |
        | 9  |   saturated12        |
        | 10 |   saturated11        |
        | 11 |   saturated10        |
        | 11 |   saturated09        |
        | 12 |   saturated08        |
        | 13 |   saturated07        |
        | 14 |   saturated06        |
        | 15 |   saturated05        |
        | 16 |   saturated04        |
        | 17 |   saturated03        |
        | 18 |   saturated02        |
        | 19 |   saturated01        |
        | 20 |   dubious            |
        | 21 |   sun-glint_risk     |
        | 22 |   duplicated         |
        | 23 |   cosmetic           |
        | 24 |   invalid            |
        | 25 |   straylight_risk    |
        | 26 |   bright             |
        | 27 |   tidal_region       |
        | 28 |   fresh_inland_water |
        | 19 |   coastline          |
        | 30 |   land               |

        Args:
            band_arr (XDS_TYPE): Band array
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            XDS_TYPE: Cleaned band array
        &#34;&#34;&#34;
        nodata_true = 1
        nodata_false = 0

        # Bit ids
        band_bit_id = {
            obn.CA: 18,  # Band 2
            obn.BLUE: 17,  # Band 3
            obn.GREEN: 14,  # Band 6
            obn.RED: 12,  # Band 8
            obn.VRE_1: 10,  # Band 11
            obn.VRE_2: 9,  # Band 12
            obn.VRE_3: 5,  # Band 16
            obn.NIR: 4,  # Band 17
            obn.NARROW_NIR: 4,  # Band 17
            obn.WV: 1,  # Band 20
            obn.FAR_NIR: 0,  # Band 21
        }
        invalid_id = 24
        sat_band_id = band_bit_id[band]

        # Open quality flags
        qual_flags_path = os.path.join(self._get_band_folder(), &#34;quality_flags.tif&#34;)
        if not os.path.isfile(qual_flags_path):
            LOGGER.warning(
                &#34;Impossible to open quality flags %s. Taking the band as is.&#34;,
                qual_flags_path,
            )
            return band_arr

        # Open flag file
        qual_arr = rasters.read(
            qual_flags_path,
            resolution=resolution,
            size=size,
            resampling=Resampling.nearest,  # Nearest to keep the flags
            masked=False,
        ).astype(np.uint32)
        invalid, sat = rasters.read_bit_array(qual_arr, [invalid_id, sat_band_id])

        # Get nodata mask
        no_data = np.where(np.isnan(band_arr.data), nodata_true, nodata_false)

        # Combine masks
        mask = no_data | invalid | sat

        # DO not set 0 to epsilons as they are a part of the
        return self._set_nodata_mask(band_arr, mask)

    # pylint: disable=R0913
    # R0913: Too many arguments (6/5) (too-many-arguments)
    def _manage_invalid_pixels_slstr(
        self,
        band_arr: XDS_TYPE,
        band: obn,
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Manage invalid pixels (Nodata, saturated, defective...)

        ISP_absent pixel_absent not_decompressed no_signal saturation invalid_radiance no_parameters unfilled_pixel&#34;

        Args:
            band_arr (XDS_TYPE): Band array
            band (obn): Band name as an OpticalBandNames
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            XDS_TYPE: Cleaned band array
        &#34;&#34;&#34;
        nodata_true = 1
        nodata_false = 0

        # Open quality flags (discard _an/_in)
        qual_flags_path = os.path.join(
            self._get_band_folder(),
            self._get_slstr_quality_flags_name(band)[:-3] + &#34;.tif&#34;,
        )
        if not os.path.isfile(qual_flags_path):
            LOGGER.warning(
                &#34;Impossible to open quality flags %s. Taking the band as is.&#34;,
                qual_flags_path,
            )
            return band_arr

        # Open flag file
        qual_arr = rasters.read(
            qual_flags_path,
            resolution=resolution,
            size=size,
            resampling=Resampling.nearest,  # Nearest to keep the flags
            masked=False,
        )

        # Set no data for everything (except ISP) that caused an exception
        exception = np.where(qual_arr.data &gt; 2, nodata_true, nodata_false)

        # Get nodata mask
        no_data = np.where(np.isnan(band_arr.data), nodata_true, nodata_false)

        # Combine masks
        mask = no_data | exception

        # DO not set 0 to epsilons as they are a part of the
        return self._set_nodata_mask(band_arr, mask)

    def _load_bands(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load bands as numpy arrays with the same resolution (and same metadata).

        Args:
            bands (list): List of the wanted bands
            resolution (float): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        # Return empty if no band are specified
        if not bands:
            return {}

        # Get band paths
        if not isinstance(bands, list):
            bands = [bands]
        band_paths = self.get_band_paths(bands)

        # Open bands and get array (resampled if needed)
        band_arrays = self._open_bands(band_paths, resolution=resolution, size=size)

        return band_arrays

    def _preprocess_s3(self, resolution: float = None):
        &#34;&#34;&#34;
        pre-process S3 bands (orthorectify...)

        Args:
            resolution (float): Resolution

        Returns:
            dict: Dictionary containing {band: path}
        &#34;&#34;&#34;

        band_paths = {}

        # DIM in tmp files
        with tempfile.TemporaryDirectory() as tmp_dir:
            # out_dim = os.path.join(self.output, self.condensed_name + &#34;.dim&#34;)  # DEBUG OPTION
            out_dim = os.path.join(tmp_dir, self.condensed_name + &#34;.dim&#34;)

            # Run GPT graph
            processed_bands = self._run_s3_gpt_cli(out_dim, resolution)

            # Save all processed bands and quality flags into GeoTIFFs
            for snap_band_name in processed_bands:
                # Get standard band names
                band_name = self._get_band_filename(snap_band_name)

                # Remove tif if already existing
                # (if we are here, sth has failed when creating them, so delete them all)
                out_tif = os.path.join(self.output, band_name + &#34;.tif&#34;)
                if os.path.isfile(out_tif):
                    files.remove(out_tif)

                # Convert to geotiffs and set no data with only keeping the first band
                arr = rasters.read(rasters.get_dim_img_path(out_dim, snap_band_name))
                arr = rasters.set_nodata(
                    xr.where(arr == self._snap_no_data, self.nodata, arr), self.nodata
                )
                rasters.write(arr, out_tif, dtype=np.float32)

        # Get the wanted bands (not the quality flags here !)
        for band in processed_bands:
            filename = self._get_band_filename(band)
            if &#34;exception&#34; not in filename:
                out_tif = os.path.join(self.output, filename + &#34;.tif&#34;)
                if not os.path.isfile(out_tif):
                    raise FileNotFoundError(
                        f&#34;Error when processing S3 bands with SNAP. Couldn&#39;t find {out_tif}&#34;
                    )

                # Quality flags will crash here
                try:
                    band_paths[self._get_band_from_filename(filename)] = out_tif
                except ValueError:
                    pass

        return band_paths

    def _run_s3_gpt_cli(self, out_dim: str, resolution: float = None) -&gt; list:
        &#34;&#34;&#34;
        Construct GPT command line to reproject S3 images and quality flags

        Args:
            out_dim (str): Out DIMAP name
            resolution (float): Resolution

        Returns:
            list: Processed band name
        &#34;&#34;&#34;
        # Default resolution
        def_res = os.environ.get(S3_DEF_RES, self.resolution)

        # Construct GPT graph
        graph_path = os.path.join(utils.get_data_dir(), &#34;preprocess_s3.xml&#34;)
        snap_bands = &#34;,&#34;.join(
            [
                self._get_snap_band_name(band)
                for band, band_nb in self.band_names.items()
                if band_nb
            ]
        )
        if self._instrument_name == S3Instrument.OLCI:
            sensor = &#34;OLCI&#34;
            fmt = &#34;Sen3&#34;
            snap_bands += &#34;,quality_flags&#34;
        else:
            sensor = &#34;SLSTR_500m&#34;
            fmt = &#34;Sen3_SLSTRL1B_500m&#34;
            exception_bands = &#34;,&#34;.join(
                [
                    self._get_slstr_quality_flags_name(band)
                    for band, band_nb in self.band_names.items()
                    if band_nb
                ]
            )
            snap_bands += f&#34;,{exception_bands},cloud_an,cloud_in&#34;

        # Run GPT graph
        cmd_list = snap.get_gpt_cli(
            graph_path,
            [
                f&#34;-Pin={strings.to_cmd_string(self.path)}&#34;,
                f&#34;-Pbands={snap_bands}&#34;,
                f&#34;-Psensor={sensor}&#34;,
                f&#34;-Pformat={fmt}&#34;,
                f&#34;-Pno_data={self._snap_no_data}&#34;,
                f&#34;-Pres_m={resolution if resolution else def_res}&#34;,
                f&#34;-Pout={strings.to_cmd_string(out_dim)}&#34;,
            ],
            display_snap_opt=LOGGER.level == logging.DEBUG,
        )
        LOGGER.debug(&#34;Converting %s&#34;, self.name)
        misc.run_cli(cmd_list)

        return snap_bands.split(&#34;,&#34;)

    def extent(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        Get UTM extent of the tile, managing the case with not orthorectified bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.utm_extent()
                                                    geometry
        0  POLYGON ((1488846.028 6121896.451, 1488846.028...
        ```

        Returns:
            gpd.GeoDataFrame: Footprint in UTM
        &#34;&#34;&#34;
        try:
            extent = super().extent()

        except (FileNotFoundError, TypeError) as ex:

            def get_min_max(substr: str, subdatasets: list) -&gt; (float, float):
                &#34;&#34;&#34;
                Get min/max of a subdataset array
                Args:
                    substr: Substring to identfy the subdataset
                    subdatasets: List of subdatasets

                Returns:
                    float, float: min/max of the subdataset
                &#34;&#34;&#34;
                path = [path for path in subdatasets if substr in path][0]
                with rasterio.open(path, &#34;r&#34;) as sub_ds:
                    # Open the 4 corners of the array
                    height = sub_ds.height
                    width = sub_ds.width
                    scales = sub_ds.scales
                    pt1 = sub_ds.read(1, window=Window(0, 0, 1, 1)) * scales
                    pt2 = sub_ds.read(1, window=Window(width - 1, 0, width, 1)) * scales
                    pt3 = (
                        sub_ds.read(1, window=Window(0, height - 1, 1, height)) * scales
                    )
                    pt4 = (
                        sub_ds.read(
                            1, window=Window(width - 1, height - 1, width, height)
                        )
                        * scales
                    )
                    pt_list = [pt1, pt2, pt3, pt4]

                    # Return min and max
                    return np.min(pt_list), np.max(pt_list)

            if self.product_type == S3ProductType.OLCI_EFR:
                # Open geodetic_an.nc
                geom_file = os.path.join(
                    self.path, &#34;geo_coordinates.nc&#34;
                )  # Only use nadir files

                with rasterio.open(geom_file, &#34;r&#34;) as geom_ds:
                    lat_min, lat_max = get_min_max(&#34;latitude&#34;, geom_ds.subdatasets)
                    lon_min, lon_max = get_min_max(&#34;longitude&#34;, geom_ds.subdatasets)

            elif self.product_type == S3ProductType.SLSTR_RBT:
                # Open geodetic_an.nc
                geom_file = os.path.join(
                    self.path, &#34;geodetic_an.nc&#34;
                )  # Only use nadir files

                with rasterio.open(geom_file, &#34;r&#34;) as geom_ds:
                    lat_min, lat_max = get_min_max(&#34;latitude_an&#34;, geom_ds.subdatasets)
                    lon_min, lon_max = get_min_max(&#34;longitude_an&#34;, geom_ds.subdatasets)
            else:
                raise InvalidTypeError(
                    f&#34;Invalid products type {self.product_type}&#34;
                ) from ex

            # Create wgs84 extent (left, bottom, right, top)
            extent_wgs84 = gpd.GeoDataFrame(
                geometry=[
                    vectors.from_bounds_to_polygon(lon_min, lat_min, lon_max, lat_max)
                ],
                crs=vectors.WGS84,
            )

            # Get upper-left corner and deduce UTM proj from it
            utm = vectors.corresponding_utm_projection(
                extent_wgs84.bounds.minx, extent_wgs84.bounds.maxy
            )
            extent = extent_wgs84.to_crs(utm)

        return extent

    def _get_condensed_name(self) -&gt; str:
        &#34;&#34;&#34;
        Get S2 products condensed name ({date}_S2_{tile]_{product_type}).

        Returns:
            str: Condensed S2 name
        &#34;&#34;&#34;
        return f&#34;{self.get_datetime()}_S3_{self.product_type.name}&#34;

    def get_mean_sun_angles(self) -&gt; (float, float):
        &#34;&#34;&#34;
        Get Mean Sun angles (Azimuth and Zenith angles)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_mean_sun_angles()
        (78.55043955912154, 31.172127033319388)
        ```

        Returns:
            (float, float): Mean Azimuth and Zenith angle
        &#34;&#34;&#34;
        if self._data_type == S3DataTypes.EFR:
            geom_file = os.path.join(self.path, &#34;tie_geometries.nc&#34;)
            sun_az = &#34;SAA&#34;
            sun_ze = &#34;SZA&#34;
        elif self._data_type == S3DataTypes.RBT:
            geom_file = os.path.join(
                self.path, &#34;geometry_tn.nc&#34;
            )  # Only use nadir files
            sun_az = &#34;solar_azimuth_tn&#34;
            sun_ze = &#34;solar_zenith_tn&#34;
        else:
            raise InvalidTypeError(
                f&#34;Unknown/Unsupported data type for Sentinel-3 data: {self._data_type}&#34;
            )

        # Open file
        if os.path.isfile(geom_file):
            # Bug pylint with netCDF4
            # pylint: disable=E1101
            netcdf_ds = netCDF4.Dataset(geom_file)

            # Get variables
            sun_az_var = netcdf_ds.variables[sun_az]
            sun_ze_var = netcdf_ds.variables[sun_ze]

            # Get sun angles as the mean of whole arrays
            azimuth_angle = float(np.mean(sun_az_var[:]))
            zenith_angle = float(np.mean(sun_ze_var[:]))

            # Close dataset
            netcdf_ds.close()
        else:
            raise InvalidProductError(f&#34;Geometry file {geom_file} not found&#34;)

        return azimuth_angle, zenith_angle

    def read_mtd(self) -&gt; (etree._Element, str):
        &#34;&#34;&#34;
        Read metadata and outputs the metadata XML root and its namespace

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.read_mtd()
        (&lt;Element level1Product at 0x1b845b7ab88&gt;, &#39;&#39;)
        ```

        Returns:
            (etree._Element, str): Metadata XML root and its namespace
        &#34;&#34;&#34;
        raise NotImplementedError(
            &#34;Sentinel-3 products don&#39;t have XML metadata. &#34;
            &#34;Please check directly into NetCDF files&#34;
        )

    def _has_cloud_band(self, band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?

        - SLSTR does
        - OLCI does not provide any cloud mask
        ```
        &#34;&#34;&#34;
        if self._instrument_name == S3Instrument.SLSTR and band in [
            RAW_CLOUDS,
            ALL_CLOUDS,
            CLOUDS,
            CIRRUS,
        ]:
            has_band = True
        else:
            has_band = False

        return has_band

    def _load_clouds(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load cloud files as numpy arrays with the same resolution (and same metadata).

        Read S3 SLSTR clouds from the flags file:cloud netcdf file.
        https://sentinels.copernicus.eu/web/sentinel/technical-guides/sentinel-3-slstr/level-1/cloud-identification

        bit_id  flag_masks (ushort)     flag_meanings
        ===     ===                     ===
        0       1US                     visible
        1       2US                     1.37_threshold
        2       4US                     1.6_small_histogram
        3       8US                     1.6_large_histogram
        4       16US                    2.25_small_histogram
        5       32US                    2.25_large_histogram
        6       64US                    11_spatial_coherence
        7       128US                   gross_cloud
        8       256US                   thin_cirrus
        9       512US                   medium_high
        10      1024US                  fog_low_stratus
        11      2048US                  11_12_view_difference
        12      4096US                  3.7_11_view_difference
        13      8192US                  thermal_histogram
        14      16384US                 spare
        15      32768US                 spare

        Args:
            bands (list): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        band_dict = {}

        if bands:
            if self._instrument_name == S3Instrument.OLCI:
                raise InvalidTypeError(
                    &#34;Sentinel-3 OLCI sensor does not provide any cloud file.&#34;
                )

            all_ids = list(np.arange(0, 14))
            cir_id = 8
            cloud_ids = [id for id in all_ids if id != cir_id]

            try:
                cloud_path = files.get_file_in_dir(
                    self._get_band_folder(), &#34;cloud_RAD.tif&#34;
                )
            except FileNotFoundError:
                self._preprocess_s3(resolution)
                cloud_path = files.get_file_in_dir(self.output, &#34;cloud_RAD.tif&#34;)

            if not cloud_path:
                raise FileNotFoundError(
                    f&#34;Unable to find the cloud mask for {self.path}&#34;
                )

            # Open cloud file
            clouds_array = rasters.read(
                cloud_path,
                resolution=resolution,
                size=size,
                resampling=Resampling.nearest,
                masked=False,
            ).astype(np.uint16)

            # Get nodata mask
            # nodata = np.where(np.isnan(clouds_array), 1, 0)
            nodata = np.where(clouds_array == 65535, 1, 0)

            for band in bands:
                if band == ALL_CLOUDS:
                    band_dict[band] = self._create_mask(clouds_array, all_ids, nodata)
                elif band == CLOUDS:
                    band_dict[band] = self._create_mask(clouds_array, cloud_ids, nodata)
                elif band == CIRRUS:
                    band_dict[band] = self._create_mask(clouds_array, cir_id, nodata)
                elif band == RAW_CLOUDS:
                    band_dict[band] = clouds_array
                else:
                    raise InvalidTypeError(
                        f&#34;Non existing cloud band for Sentinel-3 SLSTR: {band}&#34;
                    )

        return band_dict

    def _create_mask(
        self,
        bit_array: xr.DataArray,
        bit_ids: Union[int, list],
        nodata: np.ndarray,
    ) -&gt; xr.DataArray:
        &#34;&#34;&#34;
        Create a mask masked array (uint8) from a bit array, bit IDs and a nodata mask.

        Args:
            bit_array (xr.DataArray): Conditional array
            bit_ids (Union[int, list]): Bit IDs
            nodata (np.ndarray): Nodata mask

        Returns:
            xr.DataArray: Mask masked array

        &#34;&#34;&#34;
        if not isinstance(bit_ids, list):
            bit_ids = [bit_ids]
        conds = rasters.read_bit_array(bit_array, bit_ids)
        cond = reduce(lambda x, y: x | y, conds)  # Use every conditions (bitwise or)

        cond_arr = np.where(cond, self._mask_true, self._mask_false).astype(np.uint8)
        cond_arr = np.squeeze(cond_arr)
        cond_arr = features.sieve(cond_arr, size=10, connectivity=4)
        cond_arr = np.expand_dims(cond_arr, axis=0)

        return super()._create_mask(bit_array, cond_arr, nodata)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></li>
<li><a title="eoreader.products.product.Product" href="../product.html#eoreader.products.product.Product">Product</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="eoreader.products.optical.s3_product.S3Product.output"><code class="name">var <span class="ident">output</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.output" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.output">output</a></code>
</p>
<div class="desc inherited"><p>Output directory of the product, to write orthorectified data for example.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.name"><code class="name">var <span class="ident">name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.name">name</a></code>
</p>
<div class="desc inherited"><p>Product name (its filename without any extension).</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.split_name"><code class="name">var <span class="ident">split_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.split_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.split_name">split_name</a></code>
</p>
<div class="desc inherited"><p>Split name, to retrieve every information from its filename (dates, tile, product type&hellip;).</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.archive_path"><code class="name">var <span class="ident">archive_path</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.archive_path" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.archive_path">archive_path</a></code>
</p>
<div class="desc inherited"><p>Archive path, same as the product path if not specified.
Useful when you want to know where both the extracted and archived version of your product …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.path"><code class="name">var <span class="ident">path</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.path" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.path">path</a></code>
</p>
<div class="desc inherited"><p>Usable path to the product, either extracted or archived path, according to the satellite.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.is_archived"><code class="name">var <span class="ident">is_archived</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.is_archived" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.is_archived">is_archived</a></code>
</p>
<div class="desc inherited"><p>Is the archived product is processed
(a products is considered as archived if its products path is a directory).</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.needs_extraction"><code class="name">var <span class="ident">needs_extraction</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.needs_extraction" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.needs_extraction">needs_extraction</a></code>
</p>
<div class="desc inherited"><p>Does this products needs to be extracted to be processed ? (<code>True</code> by default).</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.date"><code class="name">var <span class="ident">date</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.date" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.date">date</a></code>
</p>
<div class="desc inherited"><p>Acquisition date.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.datetime"><code class="name">var <span class="ident">datetime</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.datetime" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.datetime">datetime</a></code>
</p>
<div class="desc inherited"><p>Acquisition datetime.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.tile_name"><code class="name">var <span class="ident">tile_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.tile_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.tile_name">tile_name</a></code>
</p>
<div class="desc inherited"><p>Tile if possible (for data that can be piled, for example S2 and Landsats).</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.sensor_type"><code class="name">var <span class="ident">sensor_type</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.sensor_type" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.sensor_type">sensor_type</a></code>
</p>
<div class="desc inherited"><p>Sensor type, SAR or optical.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.product_type"><code class="name">var <span class="ident">product_type</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.product_type" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.product_type">product_type</a></code>
</p>
<div class="desc inherited"><p>Product type, satellite-related field, such as L1C or L2A for Sentinel-2 data.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.band_names"><code class="name">var <span class="ident">band_names</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.band_names" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.band_names">band_names</a></code>
</p>
<div class="desc inherited"><p>Band mapping between band wrapping names such as <code>GREEN</code> and band real number such as <code>03</code> for Sentinel-2.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.is_reference"><code class="name">var <span class="ident">is_reference</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.is_reference" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.is_reference">is_reference</a></code>
</p>
<div class="desc inherited"><p>If the product is a reference, used for algorithms that need pre and post data, such as fire detection.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.corresponding_ref"><code class="name">var <span class="ident">corresponding_ref</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.corresponding_ref" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.corresponding_ref">corresponding_ref</a></code>
</p>
<div class="desc inherited"><p>The corresponding reference products to the current one
(if the product is not a reference but has a reference data corresponding to it).
A list …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.nodata"><code class="name">var <span class="ident">nodata</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.nodata" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.nodata">nodata</a></code>
</p>
<div class="desc inherited"><p>Product nodata, set to 0 by default. Please do not touch this or all index will fail.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.platform"><code class="name">var <span class="ident">platform</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.platform" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.platform">platform</a></code>
</p>
<div class="desc inherited"><p>Product platform, such as Sentinel-2</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.resolution"><code class="name">var <span class="ident">resolution</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.resolution" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.resolution">resolution</a></code>
</p>
<div class="desc inherited"><p>Default resolution in meters of the current product.
For SAR product, we use Ground Range resolution as we will automatically orthorectify the tiles.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.condensed_name"><code class="name">var <span class="ident">condensed_name</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.condensed_name" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.condensed_name">condensed_name</a></code>
</p>
<div class="desc inherited"><p>Condensed name, the filename with only useful data to keep the name unique
(ie. <code>20191215T110441_S2_30TXP_L2A_122756</code>).
Used to shorten names and paths.</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.sat_id"><code class="name">var <span class="ident">sat_id</span></code>
</dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.sat_id" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.sat_id">sat_id</a></code>
</p>
<div class="desc inherited"><p>Satellite ID, i.e. <code>S2</code> for Sentinel-2</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eoreader.products.optical.s3_product.S3Product.get_datetime"><code class="name flex">
<p>def <span class="ident">get_datetime</span>(</p><p>self, <br>as_datetime=False)</p>
</code></dt>
<dd>
<div class="desc"><p>Get the product's acquisition datetime, with format <code>YYYYMMDDTHHMMSS</code> &lt;-&gt; <code>%Y%m%dT%H%M%S</code></p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = &quot;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_datetime(as_datetime=True)
datetime.datetime(2019, 11, 15, 23, 37, 22)
&gt;&gt;&gt; prod.get_datetime(as_datetime=False)
'20191115T233722'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>as_datetime</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return the date as a datetime.datetime. If false, returns a string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, datetime.datetime]</code></dt>
<dd>Its acquisition datetime</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, datetime]:
    &#34;&#34;&#34;
    Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
    datetime.datetime(2019, 11, 15, 23, 37, 22)
    &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
    &#39;20191115T233722&#39;
    ```

    Args:
        as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

    Returns:
         Union[str, datetime.datetime]: Its acquisition datetime
    &#34;&#34;&#34;

    date = self.split_name[4]

    if as_datetime:
        date = datetime.strptime(date, DATETIME_FMT)

    return date</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.get_band_paths"><code class="name flex">
<p>def <span class="ident">get_band_paths</span>(</p><p>self, <br>band_list, <br>resolution=None)</p>
</code></dt>
<dd>
<div class="desc"><p>Return the paths of required bands.</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;If not existing, this function will orthorectify your bands !</p>
</div>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; from eoreader.bands.alias import *
&gt;&gt;&gt; path = &quot;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
Executing processing graph
...11%...21%...31%...42%...52%...62%...73%...83%... done.
{
    &lt;OpticalBandNames.GREEN: 'GREEN'&gt;: '20191115T233722_S3_SLSTR_RBT\S1_reflectance.tif',
    &lt;OpticalBandNames.RED: 'RED'&gt;: '20191115T233722_S3_SLSTR_RBT\S2_reflectance.tif',
}
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>band_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the wanted bands</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Useless here</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing the path of each queried band</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
    &#34;&#34;&#34;
    Return the paths of required bands.

    .. WARNING:: If not existing, this function will orthorectify your bands !

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; from eoreader.bands.alias import *
    &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
    Executing processing graph
    ...11%...21%...31%...42%...52%...62%...73%...83%... done.
    {
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &#39;20191115T233722_S3_SLSTR_RBT\\S1_reflectance.tif&#39;,
        &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;: &#39;20191115T233722_S3_SLSTR_RBT\\S2_reflectance.tif&#39;,
    }
    ```

    Args:
        band_list (list): List of the wanted bands
        resolution (float): Useless here

    Returns:
        dict: Dictionary containing the path of each queried band
    &#34;&#34;&#34;
    band_paths = {}
    use_snap = False
    for band in band_list:
        # Get standard band names
        band_name = self._get_band_filename(band)

        try:
            # Try to open converted images
            band_paths[band] = files.get_file_in_dir(
                self._get_band_folder(), band_name + &#34;.tif&#34;
            )
        except (FileNotFoundError, TypeError):
            use_snap = True

    # If not existing (file or output), convert them
    if use_snap:
        all_band_paths = self._preprocess_s3(resolution)
        band_paths = {band: all_band_paths[band] for band in band_list}

    return band_paths</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.extent"><code class="name flex">
<p>def <span class="ident">extent</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get UTM extent of the tile, managing the case with not orthorectified bands.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = &quot;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.utm_extent()
                                            geometry
0  POLYGON ((1488846.028 6121896.451, 1488846.028...
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Footprint in UTM</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extent(self) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get UTM extent of the tile, managing the case with not orthorectified bands.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.utm_extent()
                                                geometry
    0  POLYGON ((1488846.028 6121896.451, 1488846.028...
    ```

    Returns:
        gpd.GeoDataFrame: Footprint in UTM
    &#34;&#34;&#34;
    try:
        extent = super().extent()

    except (FileNotFoundError, TypeError) as ex:

        def get_min_max(substr: str, subdatasets: list) -&gt; (float, float):
            &#34;&#34;&#34;
            Get min/max of a subdataset array
            Args:
                substr: Substring to identfy the subdataset
                subdatasets: List of subdatasets

            Returns:
                float, float: min/max of the subdataset
            &#34;&#34;&#34;
            path = [path for path in subdatasets if substr in path][0]
            with rasterio.open(path, &#34;r&#34;) as sub_ds:
                # Open the 4 corners of the array
                height = sub_ds.height
                width = sub_ds.width
                scales = sub_ds.scales
                pt1 = sub_ds.read(1, window=Window(0, 0, 1, 1)) * scales
                pt2 = sub_ds.read(1, window=Window(width - 1, 0, width, 1)) * scales
                pt3 = (
                    sub_ds.read(1, window=Window(0, height - 1, 1, height)) * scales
                )
                pt4 = (
                    sub_ds.read(
                        1, window=Window(width - 1, height - 1, width, height)
                    )
                    * scales
                )
                pt_list = [pt1, pt2, pt3, pt4]

                # Return min and max
                return np.min(pt_list), np.max(pt_list)

        if self.product_type == S3ProductType.OLCI_EFR:
            # Open geodetic_an.nc
            geom_file = os.path.join(
                self.path, &#34;geo_coordinates.nc&#34;
            )  # Only use nadir files

            with rasterio.open(geom_file, &#34;r&#34;) as geom_ds:
                lat_min, lat_max = get_min_max(&#34;latitude&#34;, geom_ds.subdatasets)
                lon_min, lon_max = get_min_max(&#34;longitude&#34;, geom_ds.subdatasets)

        elif self.product_type == S3ProductType.SLSTR_RBT:
            # Open geodetic_an.nc
            geom_file = os.path.join(
                self.path, &#34;geodetic_an.nc&#34;
            )  # Only use nadir files

            with rasterio.open(geom_file, &#34;r&#34;) as geom_ds:
                lat_min, lat_max = get_min_max(&#34;latitude_an&#34;, geom_ds.subdatasets)
                lon_min, lon_max = get_min_max(&#34;longitude_an&#34;, geom_ds.subdatasets)
        else:
            raise InvalidTypeError(
                f&#34;Invalid products type {self.product_type}&#34;
            ) from ex

        # Create wgs84 extent (left, bottom, right, top)
        extent_wgs84 = gpd.GeoDataFrame(
            geometry=[
                vectors.from_bounds_to_polygon(lon_min, lat_min, lon_max, lat_max)
            ],
            crs=vectors.WGS84,
        )

        # Get upper-left corner and deduce UTM proj from it
        utm = vectors.corresponding_utm_projection(
            extent_wgs84.bounds.minx, extent_wgs84.bounds.maxy
        )
        extent = extent_wgs84.to_crs(utm)

    return extent</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.get_mean_sun_angles"><code class="name flex">
<p>def <span class="ident">get_mean_sun_angles</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get Mean Sun angles (Azimuth and Zenith angles)</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = &quot;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_mean_sun_angles()
(78.55043955912154, 31.172127033319388)
</code></pre>
<h2 id="returns">Returns</h2>
<p>(float, float): Mean Azimuth and Zenith angle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mean_sun_angles(self) -&gt; (float, float):
    &#34;&#34;&#34;
    Get Mean Sun angles (Azimuth and Zenith angles)

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_mean_sun_angles()
    (78.55043955912154, 31.172127033319388)
    ```

    Returns:
        (float, float): Mean Azimuth and Zenith angle
    &#34;&#34;&#34;
    if self._data_type == S3DataTypes.EFR:
        geom_file = os.path.join(self.path, &#34;tie_geometries.nc&#34;)
        sun_az = &#34;SAA&#34;
        sun_ze = &#34;SZA&#34;
    elif self._data_type == S3DataTypes.RBT:
        geom_file = os.path.join(
            self.path, &#34;geometry_tn.nc&#34;
        )  # Only use nadir files
        sun_az = &#34;solar_azimuth_tn&#34;
        sun_ze = &#34;solar_zenith_tn&#34;
    else:
        raise InvalidTypeError(
            f&#34;Unknown/Unsupported data type for Sentinel-3 data: {self._data_type}&#34;
        )

    # Open file
    if os.path.isfile(geom_file):
        # Bug pylint with netCDF4
        # pylint: disable=E1101
        netcdf_ds = netCDF4.Dataset(geom_file)

        # Get variables
        sun_az_var = netcdf_ds.variables[sun_az]
        sun_ze_var = netcdf_ds.variables[sun_ze]

        # Get sun angles as the mean of whole arrays
        azimuth_angle = float(np.mean(sun_az_var[:]))
        zenith_angle = float(np.mean(sun_ze_var[:]))

        # Close dataset
        netcdf_ds.close()
    else:
        raise InvalidProductError(f&#34;Geometry file {geom_file} not found&#34;)

    return azimuth_angle, zenith_angle</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.read_mtd"><code class="name flex">
<p>def <span class="ident">read_mtd</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Read metadata and outputs the metadata XML root and its namespace</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = &quot;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.read_mtd()
(&lt;Element level1Product at 0x1b845b7ab88&gt;, '')
</code></pre>
<h2 id="returns">Returns</h2>
<p>(etree._Element, str): Metadata XML root and its namespace</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mtd(self) -&gt; (etree._Element, str):
    &#34;&#34;&#34;
    Read metadata and outputs the metadata XML root and its namespace

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = &#34;S3B_SL_1_RBT____20191115T233722_20191115T234022_20191117T031722_0179_032_144_3420_LN2_O_NT_003.SEN3&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.read_mtd()
    (&lt;Element level1Product at 0x1b845b7ab88&gt;, &#39;&#39;)
    ```

    Returns:
        (etree._Element, str): Metadata XML root and its namespace
    &#34;&#34;&#34;
    raise NotImplementedError(
        &#34;Sentinel-3 products don&#39;t have XML metadata. &#34;
        &#34;Please check directly into NetCDF files&#34;
    )</code></pre>
</details>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.get_default_band"><code class="name flex">
<p>def <span class="ident">get_default_band</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_default_band" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_default_band">get_default_band</a></code>
</p>
<div class="desc inherited"><p>Get default band: <code>GREEN</code> for optical data as every optical satellite has a GREEN band …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.get_default_band_path"><code class="name flex">
<p>def <span class="ident">get_default_band_path</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_default_band_path" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_default_band_path">get_default_band_path</a></code>
</p>
<div class="desc inherited"><p>Get default band (<code>GREEN</code> for optical data) path …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.crs"><code class="name flex">
<p>def <span class="ident">crs</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.crs" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.crs">crs</a></code>
</p>
<div class="desc inherited"><p>Get UTM projection of the tile …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.get_existing_bands"><code class="name flex">
<p>def <span class="ident">get_existing_bands</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_existing_bands" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_existing_bands">get_existing_bands</a></code>
</p>
<div class="desc inherited"><p>Return the existing band paths …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.get_existing_band_paths"><code class="name flex">
<p>def <span class="ident">get_existing_band_paths</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_existing_band_paths" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct.get_existing_band_paths">get_existing_band_paths</a></code>
</p>
<div class="desc inherited"><p>Return the existing band paths …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.footprint"><code class="name flex">
<p>def <span class="ident">footprint</span>(</p><p>self)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.footprint" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.footprint">footprint</a></code>
</p>
<div class="desc inherited"><p>Get UTM footprint of the products (without nodata, <em>in french == emprise utile</em>) …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.get_date"><code class="name flex">
<p>def <span class="ident">get_date</span>(</p><p>self, <br>as_date=False)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.get_date" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.get_date">get_date</a></code>
</p>
<div class="desc inherited"><p>Get the product's acquisition date …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.load"><code class="name flex">
<p>def <span class="ident">load</span>(</p><p>self, <br>bands, <br>resolution=None, <br>size=None)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.load" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.load">load</a></code>
</p>
<div class="desc inherited"><p>Open the bands and compute the wanted index …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.has_band"><code class="name flex">
<p>def <span class="ident">has_band</span>(</p><p>self, <br>band)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.has_band" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.has_band">has_band</a></code>
</p>
<div class="desc inherited"><p>Does this products has the specified band ? …</p></div>
</dd>
<dt id="eoreader.products.optical.s3_product.S3Product.stack"><code class="name flex">
<p>def <span class="ident">stack</span>(</p><p>self, <br>bands, <br>resolution=None, <br>stack_path=None, <br>save_as_int=False)</p>
</code></dt>
<dd>
<p class="inheritance">
<em>Inherited from:</em>
<code><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></code>.<code><a title="eoreader.products.optical.optical_product.OpticalProduct.stack" href="../product.html#eoreader.products.optical.optical_product.OpticalProduct.stack">stack</a></code>
</p>
<div class="desc inherited"><p>Stack bands and index of a products …</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Home" href="/eoreader/">
<img src="https://github.com/sertit/eoreader/blob/master/docs/eoreader.png?raw=True"
alt="logo"
style="width:40%;"/>
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eoreader.products.optical" href="index.html">eoreader.products.optical</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eoreader.products.optical.s3_product.S3ProductType" href="#eoreader.products.optical.s3_product.S3ProductType">S3ProductType</a></code></h4>
<ul>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.optical.s3_product.S3ProductType.OLCI_EFR" href="#eoreader.products.optical.s3_product.S3ProductType.OLCI_EFR">OLCI_EFR</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3ProductType.SLSTR_RBT" href="#eoreader.products.optical.s3_product.S3ProductType.SLSTR_RBT">SLSTR_RBT</a></code></li>
</ul>
</li>
</ul>
</li>
<li>
<h4><code><a title="eoreader.products.optical.s3_product.S3Instrument" href="#eoreader.products.optical.s3_product.S3Instrument">S3Instrument</a></code></h4>
<ul>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.optical.s3_product.S3Instrument.OLCI" href="#eoreader.products.optical.s3_product.S3Instrument.OLCI">OLCI</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Instrument.SLSTR" href="#eoreader.products.optical.s3_product.S3Instrument.SLSTR">SLSTR</a></code></li>
</ul>
</li>
</ul>
</li>
<li>
<h4><code><a title="eoreader.products.optical.s3_product.S3DataTypes" href="#eoreader.products.optical.s3_product.S3DataTypes">S3DataTypes</a></code></h4>
<ul>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.optical.s3_product.S3DataTypes.EFR" href="#eoreader.products.optical.s3_product.S3DataTypes.EFR">EFR</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3DataTypes.RBT" href="#eoreader.products.optical.s3_product.S3DataTypes.RBT">RBT</a></code></li>
</ul>
</li>
</ul>
</li>
<li>
<h4><code><a title="eoreader.products.optical.s3_product.S3Product" href="#eoreader.products.optical.s3_product.S3Product">S3Product</a></code></h4>
<ul>
<li>
<h4><code>Functions</code></h4>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.optical.s3_product.S3Product.get_datetime" href="#eoreader.products.optical.s3_product.S3Product.get_datetime">get_datetime</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.get_band_paths" href="#eoreader.products.optical.s3_product.S3Product.get_band_paths">get_band_paths</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.extent" href="#eoreader.products.optical.s3_product.S3Product.extent">extent</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.get_mean_sun_angles" href="#eoreader.products.optical.s3_product.S3Product.get_mean_sun_angles">get_mean_sun_angles</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.read_mtd" href="#eoreader.products.optical.s3_product.S3Product.read_mtd">read_mtd</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.get_default_band" href="optical_product.html#eoreader.products.optical.s3_product.S3Product.get_default_band">get_default_band</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.get_default_band_path" href="optical_product.html#eoreader.products.optical.s3_product.S3Product.get_default_band_path">get_default_band_path</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.crs" href="optical_product.html#eoreader.products.optical.s3_product.S3Product.crs">crs</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.get_existing_bands" href="optical_product.html#eoreader.products.optical.s3_product.S3Product.get_existing_bands">get_existing_bands</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.get_existing_band_paths" href="optical_product.html#eoreader.products.optical.s3_product.S3Product.get_existing_band_paths">get_existing_band_paths</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.footprint" href="../product.html#eoreader.products.optical.s3_product.S3Product.footprint">footprint</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.get_date" href="../product.html#eoreader.products.optical.s3_product.S3Product.get_date">get_date</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.load" href="../product.html#eoreader.products.optical.s3_product.S3Product.load">load</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.has_band" href="../product.html#eoreader.products.optical.s3_product.S3Product.has_band">has_band</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.stack" href="../product.html#eoreader.products.optical.s3_product.S3Product.stack">stack</a></code></li>
</ul>
</li>
<li>
<h4><code>Variables</code></h4>
</li>
<li>
<ul class="two-column">
<li><code><a title="eoreader.products.optical.s3_product.S3Product.output" href="../product.html#eoreader.products.optical.s3_product.S3Product.output">output</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.name" href="../product.html#eoreader.products.optical.s3_product.S3Product.name">name</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.split_name" href="../product.html#eoreader.products.optical.s3_product.S3Product.split_name">split_name</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.archive_path" href="../product.html#eoreader.products.optical.s3_product.S3Product.archive_path">archive_path</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.path" href="../product.html#eoreader.products.optical.s3_product.S3Product.path">path</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.is_archived" href="../product.html#eoreader.products.optical.s3_product.S3Product.is_archived">is_archived</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.needs_extraction" href="../product.html#eoreader.products.optical.s3_product.S3Product.needs_extraction">needs_extraction</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.date" href="../product.html#eoreader.products.optical.s3_product.S3Product.date">date</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.datetime" href="../product.html#eoreader.products.optical.s3_product.S3Product.datetime">datetime</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.tile_name" href="../product.html#eoreader.products.optical.s3_product.S3Product.tile_name">tile_name</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.sensor_type" href="../product.html#eoreader.products.optical.s3_product.S3Product.sensor_type">sensor_type</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.product_type" href="../product.html#eoreader.products.optical.s3_product.S3Product.product_type">product_type</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.band_names" href="../product.html#eoreader.products.optical.s3_product.S3Product.band_names">band_names</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.is_reference" href="../product.html#eoreader.products.optical.s3_product.S3Product.is_reference">is_reference</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.corresponding_ref" href="../product.html#eoreader.products.optical.s3_product.S3Product.corresponding_ref">corresponding_ref</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.nodata" href="../product.html#eoreader.products.optical.s3_product.S3Product.nodata">nodata</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.platform" href="../product.html#eoreader.products.optical.s3_product.S3Product.platform">platform</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.resolution" href="../product.html#eoreader.products.optical.s3_product.S3Product.resolution">resolution</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.condensed_name" href="../product.html#eoreader.products.optical.s3_product.S3Product.condensed_name">condensed_name</a></code></li>
<li><code><a title="eoreader.products.optical.s3_product.S3Product.sat_id" href="../product.html#eoreader.products.optical.s3_product.S3Product.sat_id">sat_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>