<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc 0.9.2"/>
<title>eoreader.products.product API documentation</title>
<meta name="description" content="Product, superclass of all EOReader satellites products"/>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/darcula.min.css"
crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100%;padding:3em 4em;border-left:1px solid #ddd;overflow-x:hidden}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}table{display:block;overflow-x:auto;word-break:keep-all;border-collapse:separate;border-spacing:0}th{background-color:#c4d5e780;padding:5px;border-bottom:0.1px solid gray;border-right:0.1px solid gray;border-top:0.1px solid gray}td,th{margin:0}td{white-space:nowrap;border-bottom:0.1px solid gray;border-right:0.1px solid gray}td:empty{background-color:#ececec}th:nth-child(1){border-left:0.1px solid gray}td:nth-child(1){border-left:0.1px solid gray;border-right:0.1px solid gray}th:nth-child(1),td:nth-child(1){background-color:#c4d5e7;position:-webkit-sticky;position:sticky;left:0}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML"
integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"
integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eoreader.products.product</code></h1>
</header>
<section id="section-intro">
<p>Product, superclass of all EOReader satellites products</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright 2021, SERTIT-ICube - France, https://sertit.unistra.fr/
# This file is part of eoreader project
#     https://github.com/sertit/eoreader
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&#34;&#34;&#34; Product, superclass of all EOReader satellites products &#34;&#34;&#34;
# pylint: disable=W0107
from __future__ import annotations

import datetime as dt
import logging
import os
import tempfile
from abc import abstractmethod
from enum import unique
from functools import wraps
from typing import Any, Callable, Union

import geopandas as gpd
import numpy as np
import rasterio
import xarray as xr
from rasterio import crs as riocrs
from rasterio import warp
from rasterio.enums import Resampling

from eoreader.bands import index
from eoreader.bands.alias import *
from eoreader.bands.bands import BandNames
from eoreader.env_vars import CI_EOREADER_BAND_FOLDER, DEM_PATH
from eoreader.reader import Platform, Reader
from eoreader.utils import EOREADER_NAME
from sertit import files, misc, rasters, strings
from sertit.misc import ListEnum
from sertit.rasters import XDS_TYPE
from sertit.snap import MAX_CORES

LOGGER = logging.getLogger(EOREADER_NAME)
PRODUCT_FACTORY = Reader()


def path_or_dst(method: Callable) -&gt; Callable:
    &#34;&#34;&#34;
    Path or dataset decorator: allows a function to ingest a path or a rasterio dataset

    ```python
    &gt;&gt;&gt; # Create mock function
    &gt;&gt;&gt; @path_or_dst
    &gt;&gt;&gt; def fct(dst):
    &gt;&gt;&gt;     read(dst)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Test the two ways
    &gt;&gt;&gt; read1 = fct(&#34;path\\to\\raster.tif&#34;)
    &gt;&gt;&gt; with rasterio.open(&#34;path\\to\\raster.tif&#34;) as dst:
    &gt;&gt;&gt;     read2 = fct(dst)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Test
    &gt;&gt;&gt; read1 == read2
    True
    ```
    Args:
        method (Callable): Function to decorate

    Returns:
        Callable: decorated function
    &#34;&#34;&#34;

    @wraps(method)
    def path_or_dst_wrapper(
        self, path_or_ds: Union[str, rasterio.DatasetReader], *args, **kwargs
    ) -&gt; Any:
        &#34;&#34;&#34;
        Path or dataset wrapper
        Args:
            self: Class
            path_or_ds (Union[str, rasterio.DatasetReader]): Raster path or its dataset
            *args: args
            **kwargs: kwargs

        Returns:
            Any: regular output
        &#34;&#34;&#34;
        if isinstance(path_or_ds, str):
            with rasterio.open(path_or_ds) as dst:
                out = method(self, dst, *args, **kwargs)
        else:
            out = method(self, path_or_ds, *args, **kwargs)
        return out

    return path_or_dst_wrapper


@unique
class SensorType(ListEnum):
    &#34;&#34;&#34;
    Sensor type of the products, optical or SAR
    &#34;&#34;&#34;

    OPTICAL = &#34;Optical&#34;
    &#34;&#34;&#34;For optical data&#34;&#34;&#34;

    SAR = &#34;SAR&#34;
    &#34;&#34;&#34;For SAR data&#34;&#34;&#34;


class Product:
    &#34;&#34;&#34;Super class of EOReader Products&#34;&#34;&#34;

    def __init__(
        self, product_path: str, archive_path: str = None, output_path: str = None
    ) -&gt; None:
        self.name = files.get_filename(product_path)
        &#34;&#34;&#34;Product name (its filename without any extension).&#34;&#34;&#34;

        self.split_name = self._get_split_name()
        &#34;&#34;&#34;Split name, to retrieve every information from its filename (dates, tile, product type...).&#34;&#34;&#34;

        self.archive_path = archive_path if archive_path else product_path
        &#34;&#34;&#34;Archive path, same as the product path if not specified.
        Useful when you want to know where both the extracted and archived version of your product are stored.&#34;&#34;&#34;

        self.path = product_path
        &#34;&#34;&#34;Usable path to the product, either extracted or archived path, according to the satellite.&#34;&#34;&#34;

        self.is_archived = os.path.isfile(self.path)
        &#34;&#34;&#34; Is the archived product is processed
        (a products is considered as archived if its products path is a directory).&#34;&#34;&#34;

        self.needs_extraction = True
        &#34;&#34;&#34;Does this products needs to be extracted to be processed ? (`True` by default).&#34;&#34;&#34;

        # The output will be given later
        if output_path:
            self._tmp = None
            self._output = output_path
            os.makedirs(output_path, exist_ok=True)
        else:
            self._tmp = tempfile.TemporaryDirectory()
            self._output = self._tmp.name
        &#34;&#34;&#34;Output directory of the product, to write orthorectified data for example.&#34;&#34;&#34;

        # Get the products date and datetime
        self.date = self.get_date(as_date=True)
        &#34;&#34;&#34;Acquisition date.&#34;&#34;&#34;
        self.datetime = self.get_datetime(as_datetime=True)
        &#34;&#34;&#34;Acquisition datetime.&#34;&#34;&#34;

        self.tile_name = None
        &#34;&#34;&#34;Tile if possible (for data that can be piled, for example S2 and Landsats).&#34;&#34;&#34;

        self.sensor_type = None
        &#34;&#34;&#34;Sensor type, SAR or optical.&#34;&#34;&#34;

        self.product_type = None
        &#34;&#34;&#34;Product type, satellite-related field, such as L1C or L2A for Sentinel-2 data.&#34;&#34;&#34;

        self.band_names = None
        &#34;&#34;&#34;Band mapping between band wrapping names such as `GREEN` and band real number such as `03` for Sentinel-2.&#34;&#34;&#34;

        self.is_reference = False
        &#34;&#34;&#34;If the product is a reference, used for algorithms that need pre and post data, such as fire detection.&#34;&#34;&#34;

        self.corresponding_ref = []
        &#34;&#34;&#34;The corresponding reference products to the current one
         (if the product is not a reference but has a reference data corresponding to it).
         A list because of multiple ref in case of non-stackable products (S3, S1...)&#34;&#34;&#34;

        self.nodata = -9999
        &#34;&#34;&#34; Product nodata, set to 0 by default. Please do not touch this or all index will fail. &#34;&#34;&#34;

        # Mask values
        self._mask_true = 1
        self._mask_false = 0

        self.platform = self._get_platform()
        &#34;&#34;&#34;Product platform, such as Sentinel-2&#34;&#34;&#34;

        # Post initialization
        self._post_init()

        # Set product type, needs to be done after the post-initialization
        self._set_product_type()

        # Set the resolution, needs to be done when knowing the product type
        self.resolution = self._set_resolution()
        &#34;&#34;&#34;
        Default resolution in meters of the current product.
        For SAR product, we use Ground Range resolution as we will automatically orthorectify the tiles.
        &#34;&#34;&#34;

        self.condensed_name = self._get_condensed_name()
        &#34;&#34;&#34;
        Condensed name, the filename with only useful data to keep the name unique
        (ie. `20191215T110441_S2_30TXP_L2A_122756`).
        Used to shorten names and paths.
        &#34;&#34;&#34;

        self.sat_id = self.platform.name
        &#34;&#34;&#34;Satellite ID, i.e. `S2` for Sentinel-2&#34;&#34;&#34;

        # TODO: manage self.needs_extraction

    def __del__(self):
        &#34;&#34;&#34;Cleaning up _tmp directory&#34;&#34;&#34;
        if self._tmp:
            self._tmp.cleanup()

    @abstractmethod
    def _post_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function used to post_init the products
        (setting sensor type, band names and so on)
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def footprint(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        Get UTM footprint of the products (without nodata, *in french == emprise utile*)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.footprint()
           index                                           geometry
        0      0  POLYGON ((199980.000 4500000.000, 199980.000 4...
        ```

        Returns:
            gpd.GeoDataFrame: Footprint as a GeoDataFrame
        &#34;&#34;&#34;
        def_band = self.get_default_band()
        default_xda = self.load(def_band)[
            def_band
        ]  # Forced to load as the nodata may not be positioned by default
        return rasters.get_footprint(default_xda)

    @abstractmethod
    def extent(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        Get UTM extent of the tile

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.utm_extent()
                                                    geometry
        0  POLYGON ((309780.000 4390200.000, 309780.000 4...
        ```

        Returns:
            gpd.GeoDataFrame: Footprint in UTM
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def crs(self) -&gt; riocrs.CRS:
        &#34;&#34;&#34;
        Get UTM projection of the tile

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.utm_crs()
        CRS.from_epsg(32630)
        ```

        Returns:
            crs.CRS: CRS object
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _get_band_folder(self):
        &#34;&#34;&#34;Manage the case of CI SNAP Bands&#34;&#34;&#34;

        # Manage CI SNAP band
        ci_band_folder = os.environ.get(CI_EOREADER_BAND_FOLDER)
        if ci_band_folder and os.path.isdir(ci_band_folder):
            band_folder = ci_band_folder
        else:
            band_folder = self.output

        return band_folder

    @abstractmethod
    def _set_resolution(self) -&gt; float:
        &#34;&#34;&#34;
        Set product default resolution (in meters)
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def _set_product_type(self) -&gt; None:
        &#34;&#34;&#34;
        Set product type
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @classmethod
    def _get_platform(cls) -&gt; Platform:
        class_module = cls.__module__.split(&#34;.&#34;)[-1]
        sat_id = class_module.split(&#34;_&#34;)[0].upper()
        return getattr(Platform, sat_id)

    @abstractmethod
    def _get_condensed_name(self) -&gt; str:
        &#34;&#34;&#34;
        Set product condensed name.

        Returns:
            str: Condensed name
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _get_split_name(self) -&gt; list:
        &#34;&#34;&#34;
        Get split name (erasing empty strings in it by precaution, especially for S1 and S3 data)

        Returns:
            list: Split products name
        &#34;&#34;&#34;
        return [x for x in self.name.split(&#34;_&#34;) if x]

    @abstractmethod
    def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, dt.datetime]:
        &#34;&#34;&#34;
        Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
        datetime.datetime(2020, 8, 24, 11, 6, 31)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
        &#39;20200824T110631&#39;
        ```

        Args:
            as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

        Returns:
             Union[str, datetime.datetime]: Its acquisition datetime
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def get_date(self, as_date: bool = False) -&gt; Union[str, dt.date]:
        &#34;&#34;&#34;
        Get the product&#39;s acquisition date.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_date(as_date=True)
        datetime.datetime(2020, 8, 24, 0, 0)
        &gt;&gt;&gt; prod.get_date(as_date=False)
        &#39;20200824&#39;
        ```

        Args:
            as_date (bool): Return the date as a datetime.date. If false, returns a string.

        Returns:
            str: Its acquisition date
        &#34;&#34;&#34;
        date = self.get_datetime().split(&#34;T&#34;)[0]

        if as_date:
            date = strings.str_to_date(date, date_format=&#34;%Y%m%d&#34;)

        return date

    @abstractmethod
    def get_default_band_path(self) -&gt; str:
        &#34;&#34;&#34;
        Get default band path (among the existing ones).

        Usually `GREEN` band for optical data and the first existing one between `VV` and `HH` for SAR data.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_default_band_path()
        &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2&#39;
        ```
        Returns:
            str: Default band path
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def get_default_band(self) -&gt; BandNames:
        &#34;&#34;&#34;
        Get default band:
        Usually `GREEN` band for optical data and the first existing one between `VV` and `HH` for SAR data.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_default_band()
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;
        ```

        Returns:
            str: Default band
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def get_existing_bands(self) -&gt; list:
        &#34;&#34;&#34;
        Return the existing bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_existing_bands()
        [&lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;,
        &lt;OpticalBandNames.BLUE: &#39;BLUE&#39;&gt;,
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;,
        &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;,
        &lt;OpticalBandNames.VRE_1: &#39;VEGETATION_RED_EDGE_1&#39;&gt;,
        &lt;OpticalBandNames.VRE_2: &#39;VEGETATION_RED_EDGE_2&#39;&gt;,
        &lt;OpticalBandNames.VRE_3: &#39;VEGETATION_RED_EDGE_3&#39;&gt;,
        &lt;OpticalBandNames.NIR: &#39;NIR&#39;&gt;,
        &lt;OpticalBandNames.NNIR: &#39;NARROW_NIR&#39;&gt;,
        &lt;OpticalBandNames.WV: &#39;WATER_VAPOUR&#39;&gt;,
        &lt;OpticalBandNames.CIRRUS: &#39;CIRRUS&#39;&gt;,
        &lt;OpticalBandNames.SWIR_1: &#39;SWIR_1&#39;&gt;,
        &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;]
        ```

        Returns:
            list: List of existing bands in the products
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def get_existing_band_paths(self) -&gt; dict:
        &#34;&#34;&#34;
        Return the existing band paths.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_existing_band_paths()
        {
            &lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B01.jp2&#39;,
            ...,
            &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B12.jp2&#39;
        }
        ```

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
        &#34;&#34;&#34;
        Return the paths of required bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
        {
            &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2&#39;,
            &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B04.jp2&#39;
        }
        ```

        Args:
            band_list (list): List of the wanted bands
            resolution (float): Band resolution

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def read_mtd(self) -&gt; Any:
        &#34;&#34;&#34;
        Read metadata and outputs the metadata XML root and its namespace most of the time,
        except from L8-collection 1 data which outputs a pandas DataFrame

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S1A_IW_GRDH_1SDV_20191215T060906_20191215T060931_030355_0378F7_3696.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.read_mtd()
        (&lt;Element product at 0x1832895d788&gt;, &#39;&#39;)
        ```

        Returns:
            Any: Metadata XML root and its namespace or pd.DataFrame
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    # pylint: disable=W0613
    @path_or_dst
    def _read_band(
        self,
        dataset,
        resolution: Union[tuple, list, float] = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Read band from disk.

        .. WARNING::
            For optical data, invalid pixels are not managed here

        Args:
            dataset (Dataset): Band dataset
            resolution (Union[tuple, list, float]): Resolution of the wanted band, in dataset resolution unit (X, Y)
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            XDS_TYPE: Band xarray

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def _load_bands(
        self, band_list: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load bands as numpy arrays with the same resolution (and same metadata).

        Args:
            band_list (list): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _load_dem(
        self, band_list: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load bands as numpy arrays with the same resolution (and same metadata).

        Args:
            band_list (list): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        dem_bands = {}
        if band_list:
            dem_path = os.environ.get(DEM_PATH)
            if not dem_path:
                LOGGER.warning(
                    f&#34;Dem path not set, unable to compute DEM bands ! &#34;
                    f&#34;Please set the environment variable {DEM_PATH}.&#34;
                )
            else:
                for band in band_list:
                    assert is_dem(band)
                    if band == DEM:
                        path = self._warp_dem(
                            dem_path, resolution=resolution, size=size
                        )
                    elif band == SLOPE:
                        path = self._compute_slope(
                            dem_path, resolution=resolution, size=size
                        )
                    elif band == HILLSHADE:
                        path = self._compute_hillshade(
                            dem_path, resolution=resolution, size=size
                        )
                    else:
                        raise InvalidTypeError(f&#34;Unknown DEM band: {band}&#34;)

                    dem_bands[band] = rasters.read(
                        path, resolution=resolution, size=size
                    )

        return dem_bands

    def load(
        self,
        bands: Union[list, BandNames, Callable],
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Open the bands and compute the wanted index.

        The bands will be purged of nodata and invalid pixels,
        the nodata will be set to 0 and the bands will be masked arrays in float.

        Bands that come out this function at the same time are collocated and therefore have the same shapes.
        This can be broken if you load data separately. Its is best to always load DEM data with some real bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; bands = prod.load([GREEN, NDVI], resolution=20)
        &gt;&gt;&gt; bands
        &#39;&#39;&#39;
        {
            &lt;function NDVI at 0x000001EFFFF5DD08&gt;: &lt;xarray.DataArray &#39;NDVI&#39; (band: 1, y: 5490, x: 5490)&gt;
            array([[[0.949506  , 0.92181516, 0.9279379 , ..., 1.8002278 ,
                     1.5424857 , 1.6747767 ],
                    [0.95369846, 0.91685396, 0.8957871 , ..., 1.5847116 ,
                     1.5248713 , 1.5011379 ],
                    [2.9928885 , 1.3031474 , 1.0076253 , ..., 1.5969834 ,
                     1.5590671 , 1.5018653 ],
                    ...,
                    [1.4245619 , 1.6115025 , 1.6201663 , ..., 1.2387121 ,
                     1.4025431 , 1.800678  ],
                    [1.5627214 , 1.822388  , 1.7245892 , ..., 1.1694248 ,
                     1.2573677 , 1.5767351 ],
                    [1.653781  , 1.6424649 , 1.5923225 , ..., 1.3072611 ,
                     1.2181134 , 1.2478763 ]]], dtype=float32)
            Coordinates:
              * band         (band) int32 1
              * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
              * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
                spatial_ref  int32 0,
            &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &lt;xarray.DataArray (band: 1, y: 5490, x: 5490)&gt;
            array([[[0.0615  , 0.061625, 0.061   , ..., 0.12085 , 0.120225,
                     0.113575],
                    [0.061075, 0.06045 , 0.06025 , ..., 0.114625, 0.119625,
                     0.117625],
                    [0.06475 , 0.06145 , 0.060925, ..., 0.111475, 0.114925,
                     0.115175],
                    ...,
                    [0.1516  , 0.14195 , 0.1391  , ..., 0.159975, 0.14145 ,
                     0.127075],
                    [0.140325, 0.125975, 0.131875, ..., 0.18245 , 0.1565  ,
                     0.13015 ],
                    [0.133475, 0.1341  , 0.13345 , ..., 0.15565 , 0.170675,
                     0.16405 ]]], dtype=float32)
            Coordinates:
              * band         (band) int32 1
              * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
              * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
                spatial_ref  int32 0
        }
        &#39;&#39;&#39;
        ```

        Args:
            bands (Union[list, BandNames, Callable]): Band list
            resolution (float): Resolution of the band, in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            dict: {band_name, band xarray}
        &#34;&#34;&#34;
        if not resolution and not size:
            resolution = self.resolution

        # Check if all bands are valid
        if not isinstance(bands, list):
            bands = [bands]

        band_dict = self._load(bands, resolution, size)

        # Manage the case of arrays of different size -&gt; collocate arrays if needed
        band_dict = self._collocate_bands(band_dict)

        # Convert to xarray dataset when all the bands have the same size
        # TODO: cannot convert as we have non-string index
        # xds = xr.Dataset(band_dict)

        # Sort bands to the asked order
        # xds.reindex({&#34;band&#34;: bands})

        return band_dict

    @abstractmethod
    def _load(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Core function loading data bands

        Args:
            bands (list): Band list
            resolution (float): Resolution of the band, in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def has_band(self, band: Union[BandNames, Callable]) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified band ?

        By band, we mean:

        - satellite band
        - index
        - DEM band
        - cloud band

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.has_band(GREEN)
        True
        &gt;&gt;&gt; prod.has_band(TIR_2)
        False
        &gt;&gt;&gt; prod.has_band(NDVI)
        True
        &gt;&gt;&gt; prod.has_band(SHADOWS)
        False
        &gt;&gt;&gt; prod.has_band(HILLSHADE)
        True
        ```

        Args:
            band (Union[obn, sbn]): Optical or SAR band

        Returns:
            bool: True if the products has the specified band
        &#34;&#34;&#34;
        if is_dem(band):
            if self.sensor_type == SensorType.SAR and band == HILLSHADE:
                has_band = False
            else:
                has_band = True
        elif is_clouds(band):
            has_band = self._has_cloud_band(band)
        elif is_index(band):
            has_band = self._has_index(band)
        else:
            has_band = band in self.get_existing_bands()

        return has_band

    def _has_cloud_band(self, band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.has_cloud_band(CLOUDS)
        True
        ```
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _has_index(self, idx: Callable) -&gt; bool:
        &#34;&#34;&#34;
        Cen the specified index be computed from this products ?

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.has_index(NDVI)
        True
        ```

        Args:
            idx (Callable): Index

        Returns:
            bool: True if the specified index can be computed with this products&#39;s bands
        &#34;&#34;&#34;
        index_bands = index.get_needed_bands(idx)
        return all(np.isin(index_bands, self.get_existing_bands()))

    def __gt__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired after the other

        &#34;&#34;&#34;
        return self.date &gt; other.date

    def __ge__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired after or in the same time than the other

        &#34;&#34;&#34;
        return self.date &gt;= other.date

    def __eq__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired in the same time than the other

        &#34;&#34;&#34;
        return self.date == other.date

    def __ne__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired not in the same time than the other

        &#34;&#34;&#34;
        return self.date != other.date

    def __le__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired before or in the same time than the other

        &#34;&#34;&#34;
        return self.date &lt;= other.date

    def __lt__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired before the other

        &#34;&#34;&#34;
        return self.date &lt; other.date

    @property
    def output(self) -&gt; str:
        &#34;&#34;&#34;Output directory of the product, to write orthorectified data for example.&#34;&#34;&#34;
        return self._output

    @output.setter
    def output(self, value: str):
        &#34;&#34;&#34;Output directory of the product, to write orthorectified data for example.&#34;&#34;&#34;
        self._output = value
        if not os.path.isdir(self._output):
            os.makedirs(self._output, exist_ok=True)

    def _warp_dem(
        self,
        dem_path: str = &#34;&#34;,
        resolution: Union[float, tuple] = None,
        size: Union[list, tuple] = None,
        resampling: Resampling = Resampling.bilinear,
    ) -&gt; str:
        &#34;&#34;&#34;
        Get this products DEM, warped to this products footprint and CRS.

        If no DEM is giving (or non existing or non intersecting the products):

        - Using EUDEM over Europe
        - Using MERIT DEM everwhere else

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.warp_dem(resolution=20)  # In meters
        &#39;/path/to/20200824T110631_S2_T30TTK_L1C_150432_DEM.tif&#39;
        ```

        Args:
            dem_path (str): DEM path, using EUDEM/MERIT DEM if none
            resolution (Union[float, tuple]): Resolution in meters. If not specified, use the product resolution.
            resampling (Resampling): Resampling method
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            str: DEM path (as a VRT)
        &#34;&#34;&#34;
        warped_dem_path = os.path.join(
            self._get_band_folder(), f&#34;{self.condensed_name}_DEM.tif&#34;
        )
        if os.path.isfile(warped_dem_path):
            LOGGER.debug(&#34;Already existing DEM for %s. Skipping process.&#34;, self.name)
        else:
            LOGGER.debug(&#34;Warping DEM for %s&#34;, self.name)

            # Check existence (SRTM)
            if not os.path.isfile(dem_path):
                raise FileNotFoundError(f&#34;DEM file does not exist here: {dem_path}&#34;)

            # Reproject DEM into products CRS
            with rasterio.open(self.get_default_band_path()) as prod_dst:
                LOGGER.debug(&#34;Using DEM: %s&#34;, dem_path)
                with rasterio.open(dem_path) as dem_ds:
                    # Get adjusted transform and shape (with new resolution)
                    if size is not None and resolution is None:
                        try:

                            # Get destination transform
                            out_h = size[1]
                            out_w = size[0]

                            # Get destination transform
                            coeff_x = prod_dst.width / out_w
                            coeff_y = prod_dst.height / out_h
                            dst_tr = prod_dst.transform
                            dst_tr *= dst_tr.scale(coeff_x, coeff_y)

                        except (TypeError, KeyError):
                            raise ValueError(
                                f&#34;Size should exist (as resolution is None)&#34;
                                f&#34; and castable to a list: {size}&#34;
                            )

                    else:
                        # Refine resolution
                        if resolution is None:
                            resolution = self.resolution
                        res_x = (
                            resolution[0]
                            if isinstance(resolution, (tuple, list))
                            else resolution
                        )
                        res_y = (
                            resolution[1]
                            if isinstance(resolution, (tuple, list))
                            else resolution
                        )

                        # Get destination transform
                        dst_tr = prod_dst.transform
                        coeff_x = np.abs(res_x / dst_tr.a)
                        coeff_y = np.abs(res_y / dst_tr.e)
                        dst_tr *= dst_tr.scale(coeff_x, coeff_y)

                        # Get destination transform
                        out_w = int(np.round(prod_dst.width / coeff_x))
                        out_h = int(np.round(prod_dst.height / coeff_y))

                    # Get empty output
                    reprojected_array = np.zeros(
                        (prod_dst.count, out_h, out_w), dtype=np.float32
                    )

                    # Write reprojected DEM: here do not use utils.write()
                    out_meta = prod_dst.meta.copy()
                    out_meta[&#34;dtype&#34;] = reprojected_array.dtype
                    out_meta[&#34;transform&#34;] = dst_tr
                    out_meta[&#34;driver&#34;] = &#34;GTiff&#34;
                    out_meta[&#34;width&#34;] = out_w
                    out_meta[&#34;height&#34;] = out_h
                    with rasterio.open(warped_dem_path, &#34;w&#34;, **out_meta) as out_dst:
                        out_dst.write(reprojected_array)

                        # Reproject
                        warp.reproject(
                            source=rasterio.band(dem_ds, range(1, dem_ds.count + 1)),
                            destination=rasterio.band(
                                out_dst, range(1, out_dst.count + 1)
                            ),
                            resampling=resampling,
                            num_threads=MAX_CORES,
                        )

        return warped_dem_path

    @abstractmethod
    def _compute_hillshade(
        self,
        dem_path: str = &#34;&#34;,
        resolution: Union[float, tuple] = None,
        size: Union[list, tuple] = None,
        resampling: Resampling = Resampling.bilinear,
    ) -&gt; str:
        &#34;&#34;&#34;
        Compute Hillshade mask

        Args:
            dem_path (str): DEM path, using EUDEM/MERIT DEM if none
            resolution (Union[float, tuple]): Resolution in meters. If not specified, use the product resolution.
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
            resampling (Resampling): Resampling method

        Returns:
            str: Hillshade mask path

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _compute_slope(
        self,
        dem_path: str = &#34;&#34;,
        resolution: Union[float, tuple] = None,
        size: Union[list, tuple] = None,
        resampling: Resampling = Resampling.bilinear,
    ) -&gt; str:
        &#34;&#34;&#34;
        Compute slope mask

        Args:
            dem_path (str): DEM path, using EUDEM/MERIT DEM if none
            resolution (Union[float, tuple]): Resolution in meters. If not specified, use the product resolution.
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
            resampling (Resampling): Resampling method

        Returns:
            str: Slope mask path

        &#34;&#34;&#34;
        # Warp DEM
        warped_dem_path = self._warp_dem(dem_path, resolution, size, resampling)

        # Get slope path
        slope_dem = os.path.join(self.output, f&#34;{self.condensed_name}_SLOPE.tif&#34;)
        if os.path.isfile(slope_dem):
            LOGGER.debug(
                &#34;Already existing slope DEM for %s. Skipping process.&#34;, self.name
            )
        else:
            LOGGER.debug(&#34;Computing slope for %s&#34;, self.name)
            cmd_slope = [
                &#34;gdaldem&#34;,
                &#34;--config&#34;,
                &#34;NUM_THREADS&#34;,
                MAX_CORES,
                &#34;slope&#34;,
                &#34;-compute_edges&#34;,
                strings.to_cmd_string(warped_dem_path),
                strings.to_cmd_string(slope_dem),
                &#34;-p&#34;,
            ]

            # Run command
            misc.run_cli(cmd_slope)

        return slope_dem

    @staticmethod
    def _collocate_bands(bands: dict, master_xds: XDS_TYPE = None) -&gt; dict:
        &#34;&#34;&#34;
        Collocate all bands from a dict if needed (if a raster shape is different)

        Args:
            bands (dict): Dict of bands to collocate if needed

        Returns:
            dict: Collocated bands
        &#34;&#34;&#34;
        for band_id, band in bands.items():
            if master_xds is None:
                master_xds = band  # Master array is the first one in this case

            if band.shape != master_xds.shape:
                bands[band_id] = rasters.collocate(
                    master_xds=master_xds, slave_xds=band
                )

            bands[band_id] = bands[band_id].assign_coords(
                {
                    &#34;x&#34;: master_xds.x,
                    &#34;y&#34;: master_xds.y,
                }
            )  # Bug for now, tiny difference in coords

        return bands

    # pylint: disable=R0913
    # Too many arguments (6/5)
    def stack(
        self,
        bands: list,
        resolution: float = None,
        stack_path: str = None,
        save_as_int: bool = False,
    ) -&gt; xr.DataArray:
        &#34;&#34;&#34;
        Stack bands and index of a products.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; stack = prod.stack([NDVI, MNDWI, GREEN], resolution=20)  # In meters
        &gt;&gt;&gt; stack
        &#39;&#39;&#39;
        &lt;xarray.DataArray &#39;NDVI_MNDWI_GREEN&#39; (z: 3, y: 5490, x: 5490)&gt;
        array([[[ 0.949506  ,  0.92181516,  0.9279379 , ...,  1.8002278 ,
                  1.5424857 ,  1.6747767 ],
                [ 0.95369846,  0.91685396,  0.8957871 , ...,  1.5847116 ,
                  1.5248713 ,  1.5011379 ],
                [ 2.9928885 ,  1.3031474 ,  1.0076253 , ...,  1.5969834 ,
                  1.5590671 ,  1.5018653 ],
                ...,
                [ 1.4245619 ,  1.6115025 ,  1.6201663 , ...,  1.2387121 ,
                  1.4025431 ,  1.800678  ],
                [ 1.5627214 ,  1.822388  ,  1.7245892 , ...,  1.1694248 ,
                  1.2573677 ,  1.5767351 ],
                [ 1.653781  ,  1.6424649 ,  1.5923225 , ...,  1.3072611 ,
                  1.2181134 ,  1.2478763 ]],
               [[ 0.27066118,  0.23466069,  0.18792598, ..., -0.4611526 ,
                 -0.49751845, -0.4865216 ],
                [ 0.22425456,  0.28004232,  0.27851456, ..., -0.5032771 ,
                 -0.501796  , -0.502669  ],
                [-0.07466951,  0.06360884,  0.1207174 , ..., -0.50617427,
                 -0.50219285, -0.5034222 ],
                [-0.47076276, -0.4705828 , -0.4747971 , ..., -0.32138503,
                 -0.36619243, -0.37428448],
                [-0.4826967 , -0.5032287 , -0.48544118, ..., -0.278925  ,
                 -0.31404778, -0.36052078],
                [-0.488381  , -0.48253912, -0.4697526 , ..., -0.38105175,
                 -0.30813277, -0.27739233]],
               [[ 0.0615    ,  0.061625  ,  0.061     , ...,  0.12085   ,
                  0.120225  ,  0.113575  ],
                [ 0.061075  ,  0.06045   ,  0.06025   , ...,  0.114625  ,
                  0.119625  ,  0.117625  ],
                [ 0.06475   ,  0.06145   ,  0.060925  , ...,  0.111475  ,
                  0.114925  ,  0.115175  ],
                ...,
                [ 0.1516    ,  0.14195   ,  0.1391    , ...,  0.159975  ,
                  0.14145   ,  0.127075  ],
                [ 0.140325  ,  0.125975  ,  0.131875  , ...,  0.18245   ,
                  0.1565    ,  0.13015   ],
                [ 0.133475  ,  0.1341    ,  0.13345   , ...,  0.15565   ,
                  0.170675  ,  0.16405   ]]], dtype=float32)
        Coordinates:
          * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
          * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
            spatial_ref  int32 0
          * z            (z) MultiIndex
          - variable     (z) object &#39;NDVI&#39; &#39;MNDWI&#39; &#39;GREEN&#39;
          - band         (z) int64 1 1 1
        -Attributes:
            long_name:  [&#39;NDVI&#39;, &#39;MNDWI&#39;, &#39;GREEN&#39;]
        &#39;&#39;&#39;
        ```

        Args:
            bands (list): Bands and index combination
            resolution (float): Stack resolution. . If not specified, use the product resolution.
            stack_path (str): Stack path
            save_as_int (bool): Save stack as integers (uint16 and therefore multiply the values by 10.000)

        Returns:
            xr.DataArray: Stack as a DataArray
        &#34;&#34;&#34;
        if not resolution:
            resolution = self.resolution

        # Create the analysis stack
        band_dict = self.load(bands, resolution)

        # Convert into dataset with str as names
        xds = xr.Dataset(
            data_vars={to_str(key)[0]: val for key, val in band_dict.items()},
            coords=band_dict[bands[0]].coords,
        )

        # Force nodata
        stack = xds.to_stacked_array(new_dim=&#34;z&#34;, sample_dims=(&#34;x&#34;, &#34;y&#34;))
        stack = stack.transpose(&#34;z&#34;, &#34;y&#34;, &#34;x&#34;)

        # Save as integer
        if save_as_int:
            dtype = np.uint16
            stack = (stack * 10000).astype(dtype)
        else:
            dtype = np.float32
            stack = stack.astype(dtype)

        # Some updates
        stack = rasters.set_nodata(stack, self.nodata)
        band_list = to_str(list(band_dict.keys()))
        stack.attrs[&#34;long_name&#34;] = band_list
        stack = stack.rename(&#34;_&#34;.join(band_list))

        # Write on disk
        if stack_path:
            rasters.write(stack, stack_path, dtype=dtype)

        # Close datasets
        for val in band_dict.values():
            val.close()

        return stack</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="eoreader.products.product.path_or_dst"><code class="name flex">
<p>def <span class="ident">path_or_dst</span>(</p><p>method)</p>
</code></dt>
<dd>
<div class="desc"><p>Path or dataset decorator: allows a function to ingest a path or a rasterio dataset</p>
<pre><code class="language-python">&gt;&gt;&gt; # Create mock function
&gt;&gt;&gt; @path_or_dst
&gt;&gt;&gt; def fct(dst):
&gt;&gt;&gt;     read(dst)
&gt;&gt;&gt;
&gt;&gt;&gt; # Test the two ways
&gt;&gt;&gt; read1 = fct(&quot;path\to\raster.tif&quot;)
&gt;&gt;&gt; with rasterio.open(&quot;path\to\raster.tif&quot;) as dst:
&gt;&gt;&gt;     read2 = fct(dst)
&gt;&gt;&gt;
&gt;&gt;&gt; # Test
&gt;&gt;&gt; read1 == read2
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Function to decorate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable</code></dt>
<dd>decorated function</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def path_or_dst(method: Callable) -&gt; Callable:
    &#34;&#34;&#34;
    Path or dataset decorator: allows a function to ingest a path or a rasterio dataset

    ```python
    &gt;&gt;&gt; # Create mock function
    &gt;&gt;&gt; @path_or_dst
    &gt;&gt;&gt; def fct(dst):
    &gt;&gt;&gt;     read(dst)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Test the two ways
    &gt;&gt;&gt; read1 = fct(&#34;path\\to\\raster.tif&#34;)
    &gt;&gt;&gt; with rasterio.open(&#34;path\\to\\raster.tif&#34;) as dst:
    &gt;&gt;&gt;     read2 = fct(dst)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Test
    &gt;&gt;&gt; read1 == read2
    True
    ```
    Args:
        method (Callable): Function to decorate

    Returns:
        Callable: decorated function
    &#34;&#34;&#34;

    @wraps(method)
    def path_or_dst_wrapper(
        self, path_or_ds: Union[str, rasterio.DatasetReader], *args, **kwargs
    ) -&gt; Any:
        &#34;&#34;&#34;
        Path or dataset wrapper
        Args:
            self: Class
            path_or_ds (Union[str, rasterio.DatasetReader]): Raster path or its dataset
            *args: args
            **kwargs: kwargs

        Returns:
            Any: regular output
        &#34;&#34;&#34;
        if isinstance(path_or_ds, str):
            with rasterio.open(path_or_ds) as dst:
                out = method(self, dst, *args, **kwargs)
        else:
            out = method(self, path_or_ds, *args, **kwargs)
        return out

    return path_or_dst_wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eoreader.products.product.SensorType"><code class="flex name class">
<span>class <span class="ident">SensorType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Sensor type of the products, optical or SAR</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensorType(ListEnum):
    &#34;&#34;&#34;
    Sensor type of the products, optical or SAR
    &#34;&#34;&#34;

    OPTICAL = &#34;Optical&#34;
    &#34;&#34;&#34;For optical data&#34;&#34;&#34;

    SAR = &#34;SAR&#34;
    &#34;&#34;&#34;For SAR data&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sertit.misc.ListEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eoreader.products.product.SensorType.OPTICAL"><code class="name">var <span class="ident">OPTICAL</span></code>
</dt>
<dd>
<div class="desc"><p>For optical data</p></div>
</dd>
<dt id="eoreader.products.product.SensorType.SAR"><code class="name">var <span class="ident">SAR</span></code>
</dt>
<dd>
<div class="desc"><p>For SAR data</p></div>
</dd>
</dl>
</dd>
<dt id="eoreader.products.product.Product"><code class="flex name class">
<span>class <span class="ident">Product</span></span>
<span>(</span><span>product_path, archive_path=None, output_path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Super class of EOReader Products</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Product:
    &#34;&#34;&#34;Super class of EOReader Products&#34;&#34;&#34;

    def __init__(
        self, product_path: str, archive_path: str = None, output_path: str = None
    ) -&gt; None:
        self.name = files.get_filename(product_path)
        &#34;&#34;&#34;Product name (its filename without any extension).&#34;&#34;&#34;

        self.split_name = self._get_split_name()
        &#34;&#34;&#34;Split name, to retrieve every information from its filename (dates, tile, product type...).&#34;&#34;&#34;

        self.archive_path = archive_path if archive_path else product_path
        &#34;&#34;&#34;Archive path, same as the product path if not specified.
        Useful when you want to know where both the extracted and archived version of your product are stored.&#34;&#34;&#34;

        self.path = product_path
        &#34;&#34;&#34;Usable path to the product, either extracted or archived path, according to the satellite.&#34;&#34;&#34;

        self.is_archived = os.path.isfile(self.path)
        &#34;&#34;&#34; Is the archived product is processed
        (a products is considered as archived if its products path is a directory).&#34;&#34;&#34;

        self.needs_extraction = True
        &#34;&#34;&#34;Does this products needs to be extracted to be processed ? (`True` by default).&#34;&#34;&#34;

        # The output will be given later
        if output_path:
            self._tmp = None
            self._output = output_path
            os.makedirs(output_path, exist_ok=True)
        else:
            self._tmp = tempfile.TemporaryDirectory()
            self._output = self._tmp.name
        &#34;&#34;&#34;Output directory of the product, to write orthorectified data for example.&#34;&#34;&#34;

        # Get the products date and datetime
        self.date = self.get_date(as_date=True)
        &#34;&#34;&#34;Acquisition date.&#34;&#34;&#34;
        self.datetime = self.get_datetime(as_datetime=True)
        &#34;&#34;&#34;Acquisition datetime.&#34;&#34;&#34;

        self.tile_name = None
        &#34;&#34;&#34;Tile if possible (for data that can be piled, for example S2 and Landsats).&#34;&#34;&#34;

        self.sensor_type = None
        &#34;&#34;&#34;Sensor type, SAR or optical.&#34;&#34;&#34;

        self.product_type = None
        &#34;&#34;&#34;Product type, satellite-related field, such as L1C or L2A for Sentinel-2 data.&#34;&#34;&#34;

        self.band_names = None
        &#34;&#34;&#34;Band mapping between band wrapping names such as `GREEN` and band real number such as `03` for Sentinel-2.&#34;&#34;&#34;

        self.is_reference = False
        &#34;&#34;&#34;If the product is a reference, used for algorithms that need pre and post data, such as fire detection.&#34;&#34;&#34;

        self.corresponding_ref = []
        &#34;&#34;&#34;The corresponding reference products to the current one
         (if the product is not a reference but has a reference data corresponding to it).
         A list because of multiple ref in case of non-stackable products (S3, S1...)&#34;&#34;&#34;

        self.nodata = -9999
        &#34;&#34;&#34; Product nodata, set to 0 by default. Please do not touch this or all index will fail. &#34;&#34;&#34;

        # Mask values
        self._mask_true = 1
        self._mask_false = 0

        self.platform = self._get_platform()
        &#34;&#34;&#34;Product platform, such as Sentinel-2&#34;&#34;&#34;

        # Post initialization
        self._post_init()

        # Set product type, needs to be done after the post-initialization
        self._set_product_type()

        # Set the resolution, needs to be done when knowing the product type
        self.resolution = self._set_resolution()
        &#34;&#34;&#34;
        Default resolution in meters of the current product.
        For SAR product, we use Ground Range resolution as we will automatically orthorectify the tiles.
        &#34;&#34;&#34;

        self.condensed_name = self._get_condensed_name()
        &#34;&#34;&#34;
        Condensed name, the filename with only useful data to keep the name unique
        (ie. `20191215T110441_S2_30TXP_L2A_122756`).
        Used to shorten names and paths.
        &#34;&#34;&#34;

        self.sat_id = self.platform.name
        &#34;&#34;&#34;Satellite ID, i.e. `S2` for Sentinel-2&#34;&#34;&#34;

        # TODO: manage self.needs_extraction

    def __del__(self):
        &#34;&#34;&#34;Cleaning up _tmp directory&#34;&#34;&#34;
        if self._tmp:
            self._tmp.cleanup()

    @abstractmethod
    def _post_init(self) -&gt; None:
        &#34;&#34;&#34;
        Function used to post_init the products
        (setting sensor type, band names and so on)
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def footprint(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        Get UTM footprint of the products (without nodata, *in french == emprise utile*)

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.footprint()
           index                                           geometry
        0      0  POLYGON ((199980.000 4500000.000, 199980.000 4...
        ```

        Returns:
            gpd.GeoDataFrame: Footprint as a GeoDataFrame
        &#34;&#34;&#34;
        def_band = self.get_default_band()
        default_xda = self.load(def_band)[
            def_band
        ]  # Forced to load as the nodata may not be positioned by default
        return rasters.get_footprint(default_xda)

    @abstractmethod
    def extent(self) -&gt; gpd.GeoDataFrame:
        &#34;&#34;&#34;
        Get UTM extent of the tile

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.utm_extent()
                                                    geometry
        0  POLYGON ((309780.000 4390200.000, 309780.000 4...
        ```

        Returns:
            gpd.GeoDataFrame: Footprint in UTM
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def crs(self) -&gt; riocrs.CRS:
        &#34;&#34;&#34;
        Get UTM projection of the tile

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.utm_crs()
        CRS.from_epsg(32630)
        ```

        Returns:
            crs.CRS: CRS object
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _get_band_folder(self):
        &#34;&#34;&#34;Manage the case of CI SNAP Bands&#34;&#34;&#34;

        # Manage CI SNAP band
        ci_band_folder = os.environ.get(CI_EOREADER_BAND_FOLDER)
        if ci_band_folder and os.path.isdir(ci_band_folder):
            band_folder = ci_band_folder
        else:
            band_folder = self.output

        return band_folder

    @abstractmethod
    def _set_resolution(self) -&gt; float:
        &#34;&#34;&#34;
        Set product default resolution (in meters)
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def _set_product_type(self) -&gt; None:
        &#34;&#34;&#34;
        Set product type
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @classmethod
    def _get_platform(cls) -&gt; Platform:
        class_module = cls.__module__.split(&#34;.&#34;)[-1]
        sat_id = class_module.split(&#34;_&#34;)[0].upper()
        return getattr(Platform, sat_id)

    @abstractmethod
    def _get_condensed_name(self) -&gt; str:
        &#34;&#34;&#34;
        Set product condensed name.

        Returns:
            str: Condensed name
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _get_split_name(self) -&gt; list:
        &#34;&#34;&#34;
        Get split name (erasing empty strings in it by precaution, especially for S1 and S3 data)

        Returns:
            list: Split products name
        &#34;&#34;&#34;
        return [x for x in self.name.split(&#34;_&#34;) if x]

    @abstractmethod
    def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, dt.datetime]:
        &#34;&#34;&#34;
        Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
        datetime.datetime(2020, 8, 24, 11, 6, 31)
        &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
        &#39;20200824T110631&#39;
        ```

        Args:
            as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

        Returns:
             Union[str, datetime.datetime]: Its acquisition datetime
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def get_date(self, as_date: bool = False) -&gt; Union[str, dt.date]:
        &#34;&#34;&#34;
        Get the product&#39;s acquisition date.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_date(as_date=True)
        datetime.datetime(2020, 8, 24, 0, 0)
        &gt;&gt;&gt; prod.get_date(as_date=False)
        &#39;20200824&#39;
        ```

        Args:
            as_date (bool): Return the date as a datetime.date. If false, returns a string.

        Returns:
            str: Its acquisition date
        &#34;&#34;&#34;
        date = self.get_datetime().split(&#34;T&#34;)[0]

        if as_date:
            date = strings.str_to_date(date, date_format=&#34;%Y%m%d&#34;)

        return date

    @abstractmethod
    def get_default_band_path(self) -&gt; str:
        &#34;&#34;&#34;
        Get default band path (among the existing ones).

        Usually `GREEN` band for optical data and the first existing one between `VV` and `HH` for SAR data.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_default_band_path()
        &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2&#39;
        ```
        Returns:
            str: Default band path
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def get_default_band(self) -&gt; BandNames:
        &#34;&#34;&#34;
        Get default band:
        Usually `GREEN` band for optical data and the first existing one between `VV` and `HH` for SAR data.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_default_band()
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;
        ```

        Returns:
            str: Default band
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def get_existing_bands(self) -&gt; list:
        &#34;&#34;&#34;
        Return the existing bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_existing_bands()
        [&lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;,
        &lt;OpticalBandNames.BLUE: &#39;BLUE&#39;&gt;,
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;,
        &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;,
        &lt;OpticalBandNames.VRE_1: &#39;VEGETATION_RED_EDGE_1&#39;&gt;,
        &lt;OpticalBandNames.VRE_2: &#39;VEGETATION_RED_EDGE_2&#39;&gt;,
        &lt;OpticalBandNames.VRE_3: &#39;VEGETATION_RED_EDGE_3&#39;&gt;,
        &lt;OpticalBandNames.NIR: &#39;NIR&#39;&gt;,
        &lt;OpticalBandNames.NNIR: &#39;NARROW_NIR&#39;&gt;,
        &lt;OpticalBandNames.WV: &#39;WATER_VAPOUR&#39;&gt;,
        &lt;OpticalBandNames.CIRRUS: &#39;CIRRUS&#39;&gt;,
        &lt;OpticalBandNames.SWIR_1: &#39;SWIR_1&#39;&gt;,
        &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;]
        ```

        Returns:
            list: List of existing bands in the products
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def get_existing_band_paths(self) -&gt; dict:
        &#34;&#34;&#34;
        Return the existing band paths.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_existing_band_paths()
        {
            &lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B01.jp2&#39;,
            ...,
            &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B12.jp2&#39;
        }
        ```

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
        &#34;&#34;&#34;
        Return the paths of required bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
        {
            &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2&#39;,
            &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B04.jp2&#39;
        }
        ```

        Args:
            band_list (list): List of the wanted bands
            resolution (float): Band resolution

        Returns:
            dict: Dictionary containing the path of each queried band
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def read_mtd(self) -&gt; Any:
        &#34;&#34;&#34;
        Read metadata and outputs the metadata XML root and its namespace most of the time,
        except from L8-collection 1 data which outputs a pandas DataFrame

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S1A_IW_GRDH_1SDV_20191215T060906_20191215T060931_030355_0378F7_3696.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.read_mtd()
        (&lt;Element product at 0x1832895d788&gt;, &#39;&#39;)
        ```

        Returns:
            Any: Metadata XML root and its namespace or pd.DataFrame
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    # pylint: disable=W0613
    @path_or_dst
    def _read_band(
        self,
        dataset,
        resolution: Union[tuple, list, float] = None,
        size: Union[list, tuple] = None,
    ) -&gt; XDS_TYPE:
        &#34;&#34;&#34;
        Read band from disk.

        .. WARNING::
            For optical data, invalid pixels are not managed here

        Args:
            dataset (Dataset): Band dataset
            resolution (Union[tuple, list, float]): Resolution of the wanted band, in dataset resolution unit (X, Y)
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            XDS_TYPE: Band xarray

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    @abstractmethod
    def _load_bands(
        self, band_list: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load bands as numpy arrays with the same resolution (and same metadata).

        Args:
            band_list (list): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _load_dem(
        self, band_list: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Load bands as numpy arrays with the same resolution (and same metadata).

        Args:
            band_list (list): List of the wanted bands
            resolution (int): Band resolution in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
        Returns:
            dict: Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        dem_bands = {}
        if band_list:
            dem_path = os.environ.get(DEM_PATH)
            if not dem_path:
                LOGGER.warning(
                    f&#34;Dem path not set, unable to compute DEM bands ! &#34;
                    f&#34;Please set the environment variable {DEM_PATH}.&#34;
                )
            else:
                for band in band_list:
                    assert is_dem(band)
                    if band == DEM:
                        path = self._warp_dem(
                            dem_path, resolution=resolution, size=size
                        )
                    elif band == SLOPE:
                        path = self._compute_slope(
                            dem_path, resolution=resolution, size=size
                        )
                    elif band == HILLSHADE:
                        path = self._compute_hillshade(
                            dem_path, resolution=resolution, size=size
                        )
                    else:
                        raise InvalidTypeError(f&#34;Unknown DEM band: {band}&#34;)

                    dem_bands[band] = rasters.read(
                        path, resolution=resolution, size=size
                    )

        return dem_bands

    def load(
        self,
        bands: Union[list, BandNames, Callable],
        resolution: float = None,
        size: Union[list, tuple] = None,
    ) -&gt; dict:
        &#34;&#34;&#34;
        Open the bands and compute the wanted index.

        The bands will be purged of nodata and invalid pixels,
        the nodata will be set to 0 and the bands will be masked arrays in float.

        Bands that come out this function at the same time are collocated and therefore have the same shapes.
        This can be broken if you load data separately. Its is best to always load DEM data with some real bands.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; bands = prod.load([GREEN, NDVI], resolution=20)
        &gt;&gt;&gt; bands
        &#39;&#39;&#39;
        {
            &lt;function NDVI at 0x000001EFFFF5DD08&gt;: &lt;xarray.DataArray &#39;NDVI&#39; (band: 1, y: 5490, x: 5490)&gt;
            array([[[0.949506  , 0.92181516, 0.9279379 , ..., 1.8002278 ,
                     1.5424857 , 1.6747767 ],
                    [0.95369846, 0.91685396, 0.8957871 , ..., 1.5847116 ,
                     1.5248713 , 1.5011379 ],
                    [2.9928885 , 1.3031474 , 1.0076253 , ..., 1.5969834 ,
                     1.5590671 , 1.5018653 ],
                    ...,
                    [1.4245619 , 1.6115025 , 1.6201663 , ..., 1.2387121 ,
                     1.4025431 , 1.800678  ],
                    [1.5627214 , 1.822388  , 1.7245892 , ..., 1.1694248 ,
                     1.2573677 , 1.5767351 ],
                    [1.653781  , 1.6424649 , 1.5923225 , ..., 1.3072611 ,
                     1.2181134 , 1.2478763 ]]], dtype=float32)
            Coordinates:
              * band         (band) int32 1
              * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
              * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
                spatial_ref  int32 0,
            &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &lt;xarray.DataArray (band: 1, y: 5490, x: 5490)&gt;
            array([[[0.0615  , 0.061625, 0.061   , ..., 0.12085 , 0.120225,
                     0.113575],
                    [0.061075, 0.06045 , 0.06025 , ..., 0.114625, 0.119625,
                     0.117625],
                    [0.06475 , 0.06145 , 0.060925, ..., 0.111475, 0.114925,
                     0.115175],
                    ...,
                    [0.1516  , 0.14195 , 0.1391  , ..., 0.159975, 0.14145 ,
                     0.127075],
                    [0.140325, 0.125975, 0.131875, ..., 0.18245 , 0.1565  ,
                     0.13015 ],
                    [0.133475, 0.1341  , 0.13345 , ..., 0.15565 , 0.170675,
                     0.16405 ]]], dtype=float32)
            Coordinates:
              * band         (band) int32 1
              * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
              * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
                spatial_ref  int32 0
        }
        &#39;&#39;&#39;
        ```

        Args:
            bands (Union[list, BandNames, Callable]): Band list
            resolution (float): Resolution of the band, in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            dict: {band_name, band xarray}
        &#34;&#34;&#34;
        if not resolution and not size:
            resolution = self.resolution

        # Check if all bands are valid
        if not isinstance(bands, list):
            bands = [bands]

        band_dict = self._load(bands, resolution, size)

        # Manage the case of arrays of different size -&gt; collocate arrays if needed
        band_dict = self._collocate_bands(band_dict)

        # Convert to xarray dataset when all the bands have the same size
        # TODO: cannot convert as we have non-string index
        # xds = xr.Dataset(band_dict)

        # Sort bands to the asked order
        # xds.reindex({&#34;band&#34;: bands})

        return band_dict

    @abstractmethod
    def _load(
        self, bands: list, resolution: float = None, size: Union[list, tuple] = None
    ) -&gt; dict:
        &#34;&#34;&#34;
        Core function loading data bands

        Args:
            bands (list): Band list
            resolution (float): Resolution of the band, in meters
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            Dictionary {band_name, band_xarray}
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def has_band(self, band: Union[BandNames, Callable]) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified band ?

        By band, we mean:

        - satellite band
        - index
        - DEM band
        - cloud band

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.has_band(GREEN)
        True
        &gt;&gt;&gt; prod.has_band(TIR_2)
        False
        &gt;&gt;&gt; prod.has_band(NDVI)
        True
        &gt;&gt;&gt; prod.has_band(SHADOWS)
        False
        &gt;&gt;&gt; prod.has_band(HILLSHADE)
        True
        ```

        Args:
            band (Union[obn, sbn]): Optical or SAR band

        Returns:
            bool: True if the products has the specified band
        &#34;&#34;&#34;
        if is_dem(band):
            if self.sensor_type == SensorType.SAR and band == HILLSHADE:
                has_band = False
            else:
                has_band = True
        elif is_clouds(band):
            has_band = self._has_cloud_band(band)
        elif is_index(band):
            has_band = self._has_index(band)
        else:
            has_band = band in self.get_existing_bands()

        return has_band

    def _has_cloud_band(self, band: BandNames) -&gt; bool:
        &#34;&#34;&#34;
        Does this products has the specified cloud band ?

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.has_cloud_band(CLOUDS)
        True
        ```
        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _has_index(self, idx: Callable) -&gt; bool:
        &#34;&#34;&#34;
        Cen the specified index be computed from this products ?

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.has_index(NDVI)
        True
        ```

        Args:
            idx (Callable): Index

        Returns:
            bool: True if the specified index can be computed with this products&#39;s bands
        &#34;&#34;&#34;
        index_bands = index.get_needed_bands(idx)
        return all(np.isin(index_bands, self.get_existing_bands()))

    def __gt__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired after the other

        &#34;&#34;&#34;
        return self.date &gt; other.date

    def __ge__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired after or in the same time than the other

        &#34;&#34;&#34;
        return self.date &gt;= other.date

    def __eq__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired in the same time than the other

        &#34;&#34;&#34;
        return self.date == other.date

    def __ne__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired not in the same time than the other

        &#34;&#34;&#34;
        return self.date != other.date

    def __le__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired before or in the same time than the other

        &#34;&#34;&#34;
        return self.date &lt;= other.date

    def __lt__(self, other: Product) -&gt; bool:
        &#34;&#34;&#34;
        Overload greater than for eoreader -&gt; compare the dates:
        The greater products is the one acquired the last.

        Args:
            other (Product): Other products to be compared with this one

        Returns:
            bool: True if this products has been acquired before the other

        &#34;&#34;&#34;
        return self.date &lt; other.date

    @property
    def output(self) -&gt; str:
        &#34;&#34;&#34;Output directory of the product, to write orthorectified data for example.&#34;&#34;&#34;
        return self._output

    @output.setter
    def output(self, value: str):
        &#34;&#34;&#34;Output directory of the product, to write orthorectified data for example.&#34;&#34;&#34;
        self._output = value
        if not os.path.isdir(self._output):
            os.makedirs(self._output, exist_ok=True)

    def _warp_dem(
        self,
        dem_path: str = &#34;&#34;,
        resolution: Union[float, tuple] = None,
        size: Union[list, tuple] = None,
        resampling: Resampling = Resampling.bilinear,
    ) -&gt; str:
        &#34;&#34;&#34;
        Get this products DEM, warped to this products footprint and CRS.

        If no DEM is giving (or non existing or non intersecting the products):

        - Using EUDEM over Europe
        - Using MERIT DEM everwhere else

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; prod.warp_dem(resolution=20)  # In meters
        &#39;/path/to/20200824T110631_S2_T30TTK_L1C_150432_DEM.tif&#39;
        ```

        Args:
            dem_path (str): DEM path, using EUDEM/MERIT DEM if none
            resolution (Union[float, tuple]): Resolution in meters. If not specified, use the product resolution.
            resampling (Resampling): Resampling method
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

        Returns:
            str: DEM path (as a VRT)
        &#34;&#34;&#34;
        warped_dem_path = os.path.join(
            self._get_band_folder(), f&#34;{self.condensed_name}_DEM.tif&#34;
        )
        if os.path.isfile(warped_dem_path):
            LOGGER.debug(&#34;Already existing DEM for %s. Skipping process.&#34;, self.name)
        else:
            LOGGER.debug(&#34;Warping DEM for %s&#34;, self.name)

            # Check existence (SRTM)
            if not os.path.isfile(dem_path):
                raise FileNotFoundError(f&#34;DEM file does not exist here: {dem_path}&#34;)

            # Reproject DEM into products CRS
            with rasterio.open(self.get_default_band_path()) as prod_dst:
                LOGGER.debug(&#34;Using DEM: %s&#34;, dem_path)
                with rasterio.open(dem_path) as dem_ds:
                    # Get adjusted transform and shape (with new resolution)
                    if size is not None and resolution is None:
                        try:

                            # Get destination transform
                            out_h = size[1]
                            out_w = size[0]

                            # Get destination transform
                            coeff_x = prod_dst.width / out_w
                            coeff_y = prod_dst.height / out_h
                            dst_tr = prod_dst.transform
                            dst_tr *= dst_tr.scale(coeff_x, coeff_y)

                        except (TypeError, KeyError):
                            raise ValueError(
                                f&#34;Size should exist (as resolution is None)&#34;
                                f&#34; and castable to a list: {size}&#34;
                            )

                    else:
                        # Refine resolution
                        if resolution is None:
                            resolution = self.resolution
                        res_x = (
                            resolution[0]
                            if isinstance(resolution, (tuple, list))
                            else resolution
                        )
                        res_y = (
                            resolution[1]
                            if isinstance(resolution, (tuple, list))
                            else resolution
                        )

                        # Get destination transform
                        dst_tr = prod_dst.transform
                        coeff_x = np.abs(res_x / dst_tr.a)
                        coeff_y = np.abs(res_y / dst_tr.e)
                        dst_tr *= dst_tr.scale(coeff_x, coeff_y)

                        # Get destination transform
                        out_w = int(np.round(prod_dst.width / coeff_x))
                        out_h = int(np.round(prod_dst.height / coeff_y))

                    # Get empty output
                    reprojected_array = np.zeros(
                        (prod_dst.count, out_h, out_w), dtype=np.float32
                    )

                    # Write reprojected DEM: here do not use utils.write()
                    out_meta = prod_dst.meta.copy()
                    out_meta[&#34;dtype&#34;] = reprojected_array.dtype
                    out_meta[&#34;transform&#34;] = dst_tr
                    out_meta[&#34;driver&#34;] = &#34;GTiff&#34;
                    out_meta[&#34;width&#34;] = out_w
                    out_meta[&#34;height&#34;] = out_h
                    with rasterio.open(warped_dem_path, &#34;w&#34;, **out_meta) as out_dst:
                        out_dst.write(reprojected_array)

                        # Reproject
                        warp.reproject(
                            source=rasterio.band(dem_ds, range(1, dem_ds.count + 1)),
                            destination=rasterio.band(
                                out_dst, range(1, out_dst.count + 1)
                            ),
                            resampling=resampling,
                            num_threads=MAX_CORES,
                        )

        return warped_dem_path

    @abstractmethod
    def _compute_hillshade(
        self,
        dem_path: str = &#34;&#34;,
        resolution: Union[float, tuple] = None,
        size: Union[list, tuple] = None,
        resampling: Resampling = Resampling.bilinear,
    ) -&gt; str:
        &#34;&#34;&#34;
        Compute Hillshade mask

        Args:
            dem_path (str): DEM path, using EUDEM/MERIT DEM if none
            resolution (Union[float, tuple]): Resolution in meters. If not specified, use the product resolution.
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
            resampling (Resampling): Resampling method

        Returns:
            str: Hillshade mask path

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)

    def _compute_slope(
        self,
        dem_path: str = &#34;&#34;,
        resolution: Union[float, tuple] = None,
        size: Union[list, tuple] = None,
        resampling: Resampling = Resampling.bilinear,
    ) -&gt; str:
        &#34;&#34;&#34;
        Compute slope mask

        Args:
            dem_path (str): DEM path, using EUDEM/MERIT DEM if none
            resolution (Union[float, tuple]): Resolution in meters. If not specified, use the product resolution.
            size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.
            resampling (Resampling): Resampling method

        Returns:
            str: Slope mask path

        &#34;&#34;&#34;
        # Warp DEM
        warped_dem_path = self._warp_dem(dem_path, resolution, size, resampling)

        # Get slope path
        slope_dem = os.path.join(self.output, f&#34;{self.condensed_name}_SLOPE.tif&#34;)
        if os.path.isfile(slope_dem):
            LOGGER.debug(
                &#34;Already existing slope DEM for %s. Skipping process.&#34;, self.name
            )
        else:
            LOGGER.debug(&#34;Computing slope for %s&#34;, self.name)
            cmd_slope = [
                &#34;gdaldem&#34;,
                &#34;--config&#34;,
                &#34;NUM_THREADS&#34;,
                MAX_CORES,
                &#34;slope&#34;,
                &#34;-compute_edges&#34;,
                strings.to_cmd_string(warped_dem_path),
                strings.to_cmd_string(slope_dem),
                &#34;-p&#34;,
            ]

            # Run command
            misc.run_cli(cmd_slope)

        return slope_dem

    @staticmethod
    def _collocate_bands(bands: dict, master_xds: XDS_TYPE = None) -&gt; dict:
        &#34;&#34;&#34;
        Collocate all bands from a dict if needed (if a raster shape is different)

        Args:
            bands (dict): Dict of bands to collocate if needed

        Returns:
            dict: Collocated bands
        &#34;&#34;&#34;
        for band_id, band in bands.items():
            if master_xds is None:
                master_xds = band  # Master array is the first one in this case

            if band.shape != master_xds.shape:
                bands[band_id] = rasters.collocate(
                    master_xds=master_xds, slave_xds=band
                )

            bands[band_id] = bands[band_id].assign_coords(
                {
                    &#34;x&#34;: master_xds.x,
                    &#34;y&#34;: master_xds.y,
                }
            )  # Bug for now, tiny difference in coords

        return bands

    # pylint: disable=R0913
    # Too many arguments (6/5)
    def stack(
        self,
        bands: list,
        resolution: float = None,
        stack_path: str = None,
        save_as_int: bool = False,
    ) -&gt; xr.DataArray:
        &#34;&#34;&#34;
        Stack bands and index of a products.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; from eoreader.bands.alias import *
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; prod = Reader().open(path)
        &gt;&gt;&gt; stack = prod.stack([NDVI, MNDWI, GREEN], resolution=20)  # In meters
        &gt;&gt;&gt; stack
        &#39;&#39;&#39;
        &lt;xarray.DataArray &#39;NDVI_MNDWI_GREEN&#39; (z: 3, y: 5490, x: 5490)&gt;
        array([[[ 0.949506  ,  0.92181516,  0.9279379 , ...,  1.8002278 ,
                  1.5424857 ,  1.6747767 ],
                [ 0.95369846,  0.91685396,  0.8957871 , ...,  1.5847116 ,
                  1.5248713 ,  1.5011379 ],
                [ 2.9928885 ,  1.3031474 ,  1.0076253 , ...,  1.5969834 ,
                  1.5590671 ,  1.5018653 ],
                ...,
                [ 1.4245619 ,  1.6115025 ,  1.6201663 , ...,  1.2387121 ,
                  1.4025431 ,  1.800678  ],
                [ 1.5627214 ,  1.822388  ,  1.7245892 , ...,  1.1694248 ,
                  1.2573677 ,  1.5767351 ],
                [ 1.653781  ,  1.6424649 ,  1.5923225 , ...,  1.3072611 ,
                  1.2181134 ,  1.2478763 ]],
               [[ 0.27066118,  0.23466069,  0.18792598, ..., -0.4611526 ,
                 -0.49751845, -0.4865216 ],
                [ 0.22425456,  0.28004232,  0.27851456, ..., -0.5032771 ,
                 -0.501796  , -0.502669  ],
                [-0.07466951,  0.06360884,  0.1207174 , ..., -0.50617427,
                 -0.50219285, -0.5034222 ],
                [-0.47076276, -0.4705828 , -0.4747971 , ..., -0.32138503,
                 -0.36619243, -0.37428448],
                [-0.4826967 , -0.5032287 , -0.48544118, ..., -0.278925  ,
                 -0.31404778, -0.36052078],
                [-0.488381  , -0.48253912, -0.4697526 , ..., -0.38105175,
                 -0.30813277, -0.27739233]],
               [[ 0.0615    ,  0.061625  ,  0.061     , ...,  0.12085   ,
                  0.120225  ,  0.113575  ],
                [ 0.061075  ,  0.06045   ,  0.06025   , ...,  0.114625  ,
                  0.119625  ,  0.117625  ],
                [ 0.06475   ,  0.06145   ,  0.060925  , ...,  0.111475  ,
                  0.114925  ,  0.115175  ],
                ...,
                [ 0.1516    ,  0.14195   ,  0.1391    , ...,  0.159975  ,
                  0.14145   ,  0.127075  ],
                [ 0.140325  ,  0.125975  ,  0.131875  , ...,  0.18245   ,
                  0.1565    ,  0.13015   ],
                [ 0.133475  ,  0.1341    ,  0.13345   , ...,  0.15565   ,
                  0.170675  ,  0.16405   ]]], dtype=float32)
        Coordinates:
          * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
          * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
            spatial_ref  int32 0
          * z            (z) MultiIndex
          - variable     (z) object &#39;NDVI&#39; &#39;MNDWI&#39; &#39;GREEN&#39;
          - band         (z) int64 1 1 1
        -Attributes:
            long_name:  [&#39;NDVI&#39;, &#39;MNDWI&#39;, &#39;GREEN&#39;]
        &#39;&#39;&#39;
        ```

        Args:
            bands (list): Bands and index combination
            resolution (float): Stack resolution. . If not specified, use the product resolution.
            stack_path (str): Stack path
            save_as_int (bool): Save stack as integers (uint16 and therefore multiply the values by 10.000)

        Returns:
            xr.DataArray: Stack as a DataArray
        &#34;&#34;&#34;
        if not resolution:
            resolution = self.resolution

        # Create the analysis stack
        band_dict = self.load(bands, resolution)

        # Convert into dataset with str as names
        xds = xr.Dataset(
            data_vars={to_str(key)[0]: val for key, val in band_dict.items()},
            coords=band_dict[bands[0]].coords,
        )

        # Force nodata
        stack = xds.to_stacked_array(new_dim=&#34;z&#34;, sample_dims=(&#34;x&#34;, &#34;y&#34;))
        stack = stack.transpose(&#34;z&#34;, &#34;y&#34;, &#34;x&#34;)

        # Save as integer
        if save_as_int:
            dtype = np.uint16
            stack = (stack * 10000).astype(dtype)
        else:
            dtype = np.float32
            stack = stack.astype(dtype)

        # Some updates
        stack = rasters.set_nodata(stack, self.nodata)
        band_list = to_str(list(band_dict.keys()))
        stack.attrs[&#34;long_name&#34;] = band_list
        stack = stack.rename(&#34;_&#34;.join(band_list))

        # Write on disk
        if stack_path:
            rasters.write(stack, stack_path, dtype=dtype)

        # Close datasets
        for val in band_dict.values():
            val.close()

        return stack</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="eoreader.products.optical.optical_product.OpticalProduct" href="optical/optical_product.html#eoreader.products.optical.optical_product.OpticalProduct">OpticalProduct</a></li>
<li><a title="eoreader.products.sar.sar_product.SarProduct" href="sar/sar_product.html#eoreader.products.sar.sar_product.SarProduct">SarProduct</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="eoreader.products.product.Product.output"><code class="name">var <span class="ident">output</span></code>
</dt>
<dd>
<div class="desc"><p>Output directory of the product, to write orthorectified data for example.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def output(self) -&gt; str:
    &#34;&#34;&#34;Output directory of the product, to write orthorectified data for example.&#34;&#34;&#34;
    return self._output</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.name"><code class="name">var <span class="ident">name</span></code>
</dt>
<dd>
<div class="desc"><p>Product name (its filename without any extension).</p></div>
</dd>
<dt id="eoreader.products.product.Product.split_name"><code class="name">var <span class="ident">split_name</span></code>
</dt>
<dd>
<div class="desc"><p>Split name, to retrieve every information from its filename (dates, tile, product type&hellip;).</p></div>
</dd>
<dt id="eoreader.products.product.Product.archive_path"><code class="name">var <span class="ident">archive_path</span></code>
</dt>
<dd>
<div class="desc"><p>Archive path, same as the product path if not specified.
Useful when you want to know where both the extracted and archived version of your product are stored.</p></div>
</dd>
<dt id="eoreader.products.product.Product.path"><code class="name">var <span class="ident">path</span></code>
</dt>
<dd>
<div class="desc"><p>Usable path to the product, either extracted or archived path, according to the satellite.</p></div>
</dd>
<dt id="eoreader.products.product.Product.is_archived"><code class="name">var <span class="ident">is_archived</span></code>
</dt>
<dd>
<div class="desc"><p>Is the archived product is processed
(a products is considered as archived if its products path is a directory).</p></div>
</dd>
<dt id="eoreader.products.product.Product.needs_extraction"><code class="name">var <span class="ident">needs_extraction</span></code>
</dt>
<dd>
<div class="desc"><p>Does this products needs to be extracted to be processed ? (<code>True</code> by default).</p></div>
</dd>
<dt id="eoreader.products.product.Product.date"><code class="name">var <span class="ident">date</span></code>
</dt>
<dd>
<div class="desc"><p>Acquisition date.</p></div>
</dd>
<dt id="eoreader.products.product.Product.datetime"><code class="name">var <span class="ident">datetime</span></code>
</dt>
<dd>
<div class="desc"><p>Acquisition datetime.</p></div>
</dd>
<dt id="eoreader.products.product.Product.tile_name"><code class="name">var <span class="ident">tile_name</span></code>
</dt>
<dd>
<div class="desc"><p>Tile if possible (for data that can be piled, for example S2 and Landsats).</p></div>
</dd>
<dt id="eoreader.products.product.Product.sensor_type"><code class="name">var <span class="ident">sensor_type</span></code>
</dt>
<dd>
<div class="desc"><p>Sensor type, SAR or optical.</p></div>
</dd>
<dt id="eoreader.products.product.Product.product_type"><code class="name">var <span class="ident">product_type</span></code>
</dt>
<dd>
<div class="desc"><p>Product type, satellite-related field, such as L1C or L2A for Sentinel-2 data.</p></div>
</dd>
<dt id="eoreader.products.product.Product.band_names"><code class="name">var <span class="ident">band_names</span></code>
</dt>
<dd>
<div class="desc"><p>Band mapping between band wrapping names such as <code>GREEN</code> and band real number such as <code>03</code> for Sentinel-2.</p></div>
</dd>
<dt id="eoreader.products.product.Product.is_reference"><code class="name">var <span class="ident">is_reference</span></code>
</dt>
<dd>
<div class="desc"><p>If the product is a reference, used for algorithms that need pre and post data, such as fire detection.</p></div>
</dd>
<dt id="eoreader.products.product.Product.corresponding_ref"><code class="name">var <span class="ident">corresponding_ref</span></code>
</dt>
<dd>
<div class="desc"><p>The corresponding reference products to the current one
(if the product is not a reference but has a reference data corresponding to it).
A list because of multiple ref in case of non-stackable products (S3, S1&hellip;)</p></div>
</dd>
<dt id="eoreader.products.product.Product.nodata"><code class="name">var <span class="ident">nodata</span></code>
</dt>
<dd>
<div class="desc"><p>Product nodata, set to 0 by default. Please do not touch this or all index will fail.</p></div>
</dd>
<dt id="eoreader.products.product.Product.platform"><code class="name">var <span class="ident">platform</span></code>
</dt>
<dd>
<div class="desc"><p>Product platform, such as Sentinel-2</p></div>
</dd>
<dt id="eoreader.products.product.Product.resolution"><code class="name">var <span class="ident">resolution</span></code>
</dt>
<dd>
<div class="desc"><p>Default resolution in meters of the current product.
For SAR product, we use Ground Range resolution as we will automatically orthorectify the tiles.</p></div>
</dd>
<dt id="eoreader.products.product.Product.condensed_name"><code class="name">var <span class="ident">condensed_name</span></code>
</dt>
<dd>
<div class="desc"><p>Condensed name, the filename with only useful data to keep the name unique
(ie. <code>20191215T110441_S2_30TXP_L2A_122756</code>).
Used to shorten names and paths.</p></div>
</dd>
<dt id="eoreader.products.product.Product.sat_id"><code class="name">var <span class="ident">sat_id</span></code>
</dt>
<dd>
<div class="desc"><p>Satellite ID, i.e. <code>S2</code> for Sentinel-2</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="eoreader.products.product.Product.footprint"><code class="name flex">
<p>def <span class="ident">footprint</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get UTM footprint of the products (without nodata, <em>in french == emprise utile</em>)</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.footprint()
   index                                           geometry
0      0  POLYGON ((199980.000 4500000.000, 199980.000 4...
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Footprint as a GeoDataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def footprint(self) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get UTM footprint of the products (without nodata, *in french == emprise utile*)

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.footprint()
       index                                           geometry
    0      0  POLYGON ((199980.000 4500000.000, 199980.000 4...
    ```

    Returns:
        gpd.GeoDataFrame: Footprint as a GeoDataFrame
    &#34;&#34;&#34;
    def_band = self.get_default_band()
    default_xda = self.load(def_band)[
        def_band
    ]  # Forced to load as the nodata may not be positioned by default
    return rasters.get_footprint(default_xda)</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.extent"><code class="name flex">
<p>def <span class="ident">extent</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get UTM extent of the tile</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.utm_extent()
                                            geometry
0  POLYGON ((309780.000 4390200.000, 309780.000 4...
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Footprint in UTM</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def extent(self) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get UTM extent of the tile

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.utm_extent()
                                                geometry
    0  POLYGON ((309780.000 4390200.000, 309780.000 4...
    ```

    Returns:
        gpd.GeoDataFrame: Footprint in UTM
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.crs"><code class="name flex">
<p>def <span class="ident">crs</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get UTM projection of the tile</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.utm_crs()
CRS.from_epsg(32630)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>crs.CRS</code></dt>
<dd>CRS object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def crs(self) -&gt; riocrs.CRS:
    &#34;&#34;&#34;
    Get UTM projection of the tile

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.utm_crs()
    CRS.from_epsg(32630)
    ```

    Returns:
        crs.CRS: CRS object
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.get_datetime"><code class="name flex">
<p>def <span class="ident">get_datetime</span>(</p><p>self, <br>as_datetime=False)</p>
</code></dt>
<dd>
<div class="desc"><p>Get the product's acquisition datetime, with format <code>YYYYMMDDTHHMMSS</code> &lt;-&gt; <code>%Y%m%dT%H%M%S</code></p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_datetime(as_datetime=True)
datetime.datetime(2020, 8, 24, 11, 6, 31)
&gt;&gt;&gt; prod.get_datetime(as_datetime=False)
'20200824T110631'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>as_datetime</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return the date as a datetime.datetime. If false, returns a string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, datetime.datetime]</code></dt>
<dd>Its acquisition datetime</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_datetime(self, as_datetime: bool = False) -&gt; Union[str, dt.datetime]:
    &#34;&#34;&#34;
    Get the product&#39;s acquisition datetime, with format `YYYYMMDDTHHMMSS` &lt;-&gt; `%Y%m%dT%H%M%S`

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_datetime(as_datetime=True)
    datetime.datetime(2020, 8, 24, 11, 6, 31)
    &gt;&gt;&gt; prod.get_datetime(as_datetime=False)
    &#39;20200824T110631&#39;
    ```

    Args:
        as_datetime (bool): Return the date as a datetime.datetime. If false, returns a string.

    Returns:
         Union[str, datetime.datetime]: Its acquisition datetime
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.get_date"><code class="name flex">
<p>def <span class="ident">get_date</span>(</p><p>self, <br>as_date=False)</p>
</code></dt>
<dd>
<div class="desc"><p>Get the product's acquisition date.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_date(as_date=True)
datetime.datetime(2020, 8, 24, 0, 0)
&gt;&gt;&gt; prod.get_date(as_date=False)
'20200824'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>as_date</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return the date as a datetime.date. If false, returns a string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Its acquisition date</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_date(self, as_date: bool = False) -&gt; Union[str, dt.date]:
    &#34;&#34;&#34;
    Get the product&#39;s acquisition date.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_date(as_date=True)
    datetime.datetime(2020, 8, 24, 0, 0)
    &gt;&gt;&gt; prod.get_date(as_date=False)
    &#39;20200824&#39;
    ```

    Args:
        as_date (bool): Return the date as a datetime.date. If false, returns a string.

    Returns:
        str: Its acquisition date
    &#34;&#34;&#34;
    date = self.get_datetime().split(&#34;T&#34;)[0]

    if as_date:
        date = strings.str_to_date(date, date_format=&#34;%Y%m%d&#34;)

    return date</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.get_default_band_path"><code class="name flex">
<p>def <span class="ident">get_default_band_path</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get default band path (among the existing ones).</p>
<p>Usually <code>GREEN</code> band for optical data and the first existing one between <code>VV</code> and <code>HH</code> for SAR data.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_default_band_path()
'zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2'
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Default band path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_default_band_path(self) -&gt; str:
    &#34;&#34;&#34;
    Get default band path (among the existing ones).

    Usually `GREEN` band for optical data and the first existing one between `VV` and `HH` for SAR data.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_default_band_path()
    &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2&#39;
    ```
    Returns:
        str: Default band path
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.get_default_band"><code class="name flex">
<p>def <span class="ident">get_default_band</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Get default band:
Usually <code>GREEN</code> band for optical data and the first existing one between <code>VV</code> and <code>HH</code> for SAR data.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_default_band()
&lt;OpticalBandNames.GREEN: 'GREEN'&gt;
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Default band</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_default_band(self) -&gt; BandNames:
    &#34;&#34;&#34;
    Get default band:
    Usually `GREEN` band for optical data and the first existing one between `VV` and `HH` for SAR data.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_default_band()
    &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;
    ```

    Returns:
        str: Default band
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.get_existing_bands"><code class="name flex">
<p>def <span class="ident">get_existing_bands</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Return the existing bands.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_existing_bands()
[&lt;OpticalBandNames.CA: 'COASTAL_AEROSOL'&gt;,
&lt;OpticalBandNames.BLUE: 'BLUE'&gt;,
&lt;OpticalBandNames.GREEN: 'GREEN'&gt;,
&lt;OpticalBandNames.RED: 'RED'&gt;,
&lt;OpticalBandNames.VRE_1: 'VEGETATION_RED_EDGE_1'&gt;,
&lt;OpticalBandNames.VRE_2: 'VEGETATION_RED_EDGE_2'&gt;,
&lt;OpticalBandNames.VRE_3: 'VEGETATION_RED_EDGE_3'&gt;,
&lt;OpticalBandNames.NIR: 'NIR'&gt;,
&lt;OpticalBandNames.NNIR: 'NARROW_NIR'&gt;,
&lt;OpticalBandNames.WV: 'WATER_VAPOUR'&gt;,
&lt;OpticalBandNames.CIRRUS: 'CIRRUS'&gt;,
&lt;OpticalBandNames.SWIR_1: 'SWIR_1'&gt;,
&lt;OpticalBandNames.SWIR_2: 'SWIR_2'&gt;]
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of existing bands in the products</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_existing_bands(self) -&gt; list:
    &#34;&#34;&#34;
    Return the existing bands.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_existing_bands()
    [&lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;,
    &lt;OpticalBandNames.BLUE: &#39;BLUE&#39;&gt;,
    &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;,
    &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;,
    &lt;OpticalBandNames.VRE_1: &#39;VEGETATION_RED_EDGE_1&#39;&gt;,
    &lt;OpticalBandNames.VRE_2: &#39;VEGETATION_RED_EDGE_2&#39;&gt;,
    &lt;OpticalBandNames.VRE_3: &#39;VEGETATION_RED_EDGE_3&#39;&gt;,
    &lt;OpticalBandNames.NIR: &#39;NIR&#39;&gt;,
    &lt;OpticalBandNames.NNIR: &#39;NARROW_NIR&#39;&gt;,
    &lt;OpticalBandNames.WV: &#39;WATER_VAPOUR&#39;&gt;,
    &lt;OpticalBandNames.CIRRUS: &#39;CIRRUS&#39;&gt;,
    &lt;OpticalBandNames.SWIR_1: &#39;SWIR_1&#39;&gt;,
    &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;]
    ```

    Returns:
        list: List of existing bands in the products
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.get_existing_band_paths"><code class="name flex">
<p>def <span class="ident">get_existing_band_paths</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Return the existing band paths.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_existing_band_paths()
{
    &lt;OpticalBandNames.CA: 'COASTAL_AEROSOL'&gt;: 'zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B01.jp2',
    ...,
    &lt;OpticalBandNames.SWIR_2: 'SWIR_2'&gt;: 'zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B12.jp2'
}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing the path of each queried band</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_existing_band_paths(self) -&gt; dict:
    &#34;&#34;&#34;
    Return the existing band paths.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_existing_band_paths()
    {
        &lt;OpticalBandNames.CA: &#39;COASTAL_AEROSOL&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B01.jp2&#39;,
        ...,
        &lt;OpticalBandNames.SWIR_2: &#39;SWIR_2&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B12.jp2&#39;
    }
    ```

    Returns:
        dict: Dictionary containing the path of each queried band
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.get_band_paths"><code class="name flex">
<p>def <span class="ident">get_band_paths</span>(</p><p>self, <br>band_list, <br>resolution=None)</p>
</code></dt>
<dd>
<div class="desc"><p>Return the paths of required bands.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; from eoreader.bands.alias import *
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
{
    &lt;OpticalBandNames.GREEN: 'GREEN'&gt;: 'zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2',
    &lt;OpticalBandNames.RED: 'RED'&gt;: 'zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B04.jp2'
}
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>band_list</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the wanted bands</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Band resolution</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing the path of each queried band</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_band_paths(self, band_list: list, resolution: float = None) -&gt; dict:
    &#34;&#34;&#34;
    Return the paths of required bands.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; from eoreader.bands.alias import *
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.get_band_paths([GREEN, RED])
    {
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B03.jp2&#39;,
        &lt;OpticalBandNames.RED: &#39;RED&#39;&gt;: &#39;zip+file://S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip!/S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE/GRANULE/L1C_T30TTK_A027018_20200824T111345/IMG_DATA/T30TTK_20200824T110631_B04.jp2&#39;
    }
    ```

    Args:
        band_list (list): List of the wanted bands
        resolution (float): Band resolution

    Returns:
        dict: Dictionary containing the path of each queried band
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.read_mtd"><code class="name flex">
<p>def <span class="ident">read_mtd</span>(</p><p>self)</p>
</code></dt>
<dd>
<div class="desc"><p>Read metadata and outputs the metadata XML root and its namespace most of the time,
except from L8-collection 1 data which outputs a pandas DataFrame</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S1A_IW_GRDH_1SDV_20191215T060906_20191215T060931_030355_0378F7_3696.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.read_mtd()
(&lt;Element product at 0x1832895d788&gt;, '')
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>Metadata XML root and its namespace or pd.DataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def read_mtd(self) -&gt; Any:
    &#34;&#34;&#34;
    Read metadata and outputs the metadata XML root and its namespace most of the time,
    except from L8-collection 1 data which outputs a pandas DataFrame

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S1A_IW_GRDH_1SDV_20191215T060906_20191215T060931_030355_0378F7_3696.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.read_mtd()
    (&lt;Element product at 0x1832895d788&gt;, &#39;&#39;)
    ```

    Returns:
        Any: Metadata XML root and its namespace or pd.DataFrame
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;This method should be implemented by a child class&#34;)</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.load"><code class="name flex">
<p>def <span class="ident">load</span>(</p><p>self, <br>bands, <br>resolution=None, <br>size=None)</p>
</code></dt>
<dd>
<div class="desc"><p>Open the bands and compute the wanted index.</p>
<p>The bands will be purged of nodata and invalid pixels,
the nodata will be set to 0 and the bands will be masked arrays in float.</p>
<p>Bands that come out this function at the same time are collocated and therefore have the same shapes.
This can be broken if you load data separately. Its is best to always load DEM data with some real bands.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; from eoreader.bands.alias import *
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; bands = prod.load([GREEN, NDVI], resolution=20)
&gt;&gt;&gt; bands
'''
{
    &lt;function NDVI at 0x000001EFFFF5DD08&gt;: &lt;xarray.DataArray 'NDVI' (band: 1, y: 5490, x: 5490)&gt;
    array([[[0.949506  , 0.92181516, 0.9279379 , ..., 1.8002278 ,
             1.5424857 , 1.6747767 ],
            [0.95369846, 0.91685396, 0.8957871 , ..., 1.5847116 ,
             1.5248713 , 1.5011379 ],
            [2.9928885 , 1.3031474 , 1.0076253 , ..., 1.5969834 ,
             1.5590671 , 1.5018653 ],
            ...,
            [1.4245619 , 1.6115025 , 1.6201663 , ..., 1.2387121 ,
             1.4025431 , 1.800678  ],
            [1.5627214 , 1.822388  , 1.7245892 , ..., 1.1694248 ,
             1.2573677 , 1.5767351 ],
            [1.653781  , 1.6424649 , 1.5923225 , ..., 1.3072611 ,
             1.2181134 , 1.2478763 ]]], dtype=float32)
    Coordinates:
      * band         (band) int32 1
      * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
      * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
        spatial_ref  int32 0,
    &lt;OpticalBandNames.GREEN: 'GREEN'&gt;: &lt;xarray.DataArray (band: 1, y: 5490, x: 5490)&gt;
    array([[[0.0615  , 0.061625, 0.061   , ..., 0.12085 , 0.120225,
             0.113575],
            [0.061075, 0.06045 , 0.06025 , ..., 0.114625, 0.119625,
             0.117625],
            [0.06475 , 0.06145 , 0.060925, ..., 0.111475, 0.114925,
             0.115175],
            ...,
            [0.1516  , 0.14195 , 0.1391  , ..., 0.159975, 0.14145 ,
             0.127075],
            [0.140325, 0.125975, 0.131875, ..., 0.18245 , 0.1565  ,
             0.13015 ],
            [0.133475, 0.1341  , 0.13345 , ..., 0.15565 , 0.170675,
             0.16405 ]]], dtype=float32)
    Coordinates:
      * band         (band) int32 1
      * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
      * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
        spatial_ref  int32 0
}
'''
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bands</code></strong> :&ensp;<code>Union[list, BandNames, Callable]</code></dt>
<dd>Band list</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Resolution of the band, in meters</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>Union[tuple, list]</code></dt>
<dd>Size of the array (width, height). Not used if resolution is provided.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>{band_name, band xarray}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(
    self,
    bands: Union[list, BandNames, Callable],
    resolution: float = None,
    size: Union[list, tuple] = None,
) -&gt; dict:
    &#34;&#34;&#34;
    Open the bands and compute the wanted index.

    The bands will be purged of nodata and invalid pixels,
    the nodata will be set to 0 and the bands will be masked arrays in float.

    Bands that come out this function at the same time are collocated and therefore have the same shapes.
    This can be broken if you load data separately. Its is best to always load DEM data with some real bands.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; from eoreader.bands.alias import *
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; bands = prod.load([GREEN, NDVI], resolution=20)
    &gt;&gt;&gt; bands
    &#39;&#39;&#39;
    {
        &lt;function NDVI at 0x000001EFFFF5DD08&gt;: &lt;xarray.DataArray &#39;NDVI&#39; (band: 1, y: 5490, x: 5490)&gt;
        array([[[0.949506  , 0.92181516, 0.9279379 , ..., 1.8002278 ,
                 1.5424857 , 1.6747767 ],
                [0.95369846, 0.91685396, 0.8957871 , ..., 1.5847116 ,
                 1.5248713 , 1.5011379 ],
                [2.9928885 , 1.3031474 , 1.0076253 , ..., 1.5969834 ,
                 1.5590671 , 1.5018653 ],
                ...,
                [1.4245619 , 1.6115025 , 1.6201663 , ..., 1.2387121 ,
                 1.4025431 , 1.800678  ],
                [1.5627214 , 1.822388  , 1.7245892 , ..., 1.1694248 ,
                 1.2573677 , 1.5767351 ],
                [1.653781  , 1.6424649 , 1.5923225 , ..., 1.3072611 ,
                 1.2181134 , 1.2478763 ]]], dtype=float32)
        Coordinates:
          * band         (band) int32 1
          * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
          * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
            spatial_ref  int32 0,
        &lt;OpticalBandNames.GREEN: &#39;GREEN&#39;&gt;: &lt;xarray.DataArray (band: 1, y: 5490, x: 5490)&gt;
        array([[[0.0615  , 0.061625, 0.061   , ..., 0.12085 , 0.120225,
                 0.113575],
                [0.061075, 0.06045 , 0.06025 , ..., 0.114625, 0.119625,
                 0.117625],
                [0.06475 , 0.06145 , 0.060925, ..., 0.111475, 0.114925,
                 0.115175],
                ...,
                [0.1516  , 0.14195 , 0.1391  , ..., 0.159975, 0.14145 ,
                 0.127075],
                [0.140325, 0.125975, 0.131875, ..., 0.18245 , 0.1565  ,
                 0.13015 ],
                [0.133475, 0.1341  , 0.13345 , ..., 0.15565 , 0.170675,
                 0.16405 ]]], dtype=float32)
        Coordinates:
          * band         (band) int32 1
          * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
          * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
            spatial_ref  int32 0
    }
    &#39;&#39;&#39;
    ```

    Args:
        bands (Union[list, BandNames, Callable]): Band list
        resolution (float): Resolution of the band, in meters
        size (Union[tuple, list]): Size of the array (width, height). Not used if resolution is provided.

    Returns:
        dict: {band_name, band xarray}
    &#34;&#34;&#34;
    if not resolution and not size:
        resolution = self.resolution

    # Check if all bands are valid
    if not isinstance(bands, list):
        bands = [bands]

    band_dict = self._load(bands, resolution, size)

    # Manage the case of arrays of different size -&gt; collocate arrays if needed
    band_dict = self._collocate_bands(band_dict)

    # Convert to xarray dataset when all the bands have the same size
    # TODO: cannot convert as we have non-string index
    # xds = xr.Dataset(band_dict)

    # Sort bands to the asked order
    # xds.reindex({&#34;band&#34;: bands})

    return band_dict</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.has_band"><code class="name flex">
<p>def <span class="ident">has_band</span>(</p><p>self, <br>band)</p>
</code></dt>
<dd>
<div class="desc"><p>Does this products has the specified band ?</p>
<p>By band, we mean:</p>
<ul>
<li>satellite band</li>
<li>index</li>
<li>DEM band</li>
<li>cloud band</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; from eoreader.bands.alias import *
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; prod.has_band(GREEN)
True
&gt;&gt;&gt; prod.has_band(TIR_2)
False
&gt;&gt;&gt; prod.has_band(NDVI)
True
&gt;&gt;&gt; prod.has_band(SHADOWS)
False
&gt;&gt;&gt; prod.has_band(HILLSHADE)
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>band</code></strong> :&ensp;<code>Union[obn, sbn]</code></dt>
<dd>Optical or SAR band</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the products has the specified band</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_band(self, band: Union[BandNames, Callable]) -&gt; bool:
    &#34;&#34;&#34;
    Does this products has the specified band ?

    By band, we mean:

    - satellite band
    - index
    - DEM band
    - cloud band

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; from eoreader.bands.alias import *
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; prod.has_band(GREEN)
    True
    &gt;&gt;&gt; prod.has_band(TIR_2)
    False
    &gt;&gt;&gt; prod.has_band(NDVI)
    True
    &gt;&gt;&gt; prod.has_band(SHADOWS)
    False
    &gt;&gt;&gt; prod.has_band(HILLSHADE)
    True
    ```

    Args:
        band (Union[obn, sbn]): Optical or SAR band

    Returns:
        bool: True if the products has the specified band
    &#34;&#34;&#34;
    if is_dem(band):
        if self.sensor_type == SensorType.SAR and band == HILLSHADE:
            has_band = False
        else:
            has_band = True
    elif is_clouds(band):
        has_band = self._has_cloud_band(band)
    elif is_index(band):
        has_band = self._has_index(band)
    else:
        has_band = band in self.get_existing_bands()

    return has_band</code></pre>
</details>
</dd>
<dt id="eoreader.products.product.Product.stack"><code class="name flex">
<p>def <span class="ident">stack</span>(</p><p>self, <br>bands, <br>resolution=None, <br>stack_path=None, <br>save_as_int=False)</p>
</code></dt>
<dd>
<div class="desc"><p>Stack bands and index of a products.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; from eoreader.bands.alias import *
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; prod = Reader().open(path)
&gt;&gt;&gt; stack = prod.stack([NDVI, MNDWI, GREEN], resolution=20)  # In meters
&gt;&gt;&gt; stack
'''
&lt;xarray.DataArray 'NDVI_MNDWI_GREEN' (z: 3, y: 5490, x: 5490)&gt;
array([[[ 0.949506  ,  0.92181516,  0.9279379 , ...,  1.8002278 ,
          1.5424857 ,  1.6747767 ],
        [ 0.95369846,  0.91685396,  0.8957871 , ...,  1.5847116 ,
          1.5248713 ,  1.5011379 ],
        [ 2.9928885 ,  1.3031474 ,  1.0076253 , ...,  1.5969834 ,
          1.5590671 ,  1.5018653 ],
        ...,
        [ 1.4245619 ,  1.6115025 ,  1.6201663 , ...,  1.2387121 ,
          1.4025431 ,  1.800678  ],
        [ 1.5627214 ,  1.822388  ,  1.7245892 , ...,  1.1694248 ,
          1.2573677 ,  1.5767351 ],
        [ 1.653781  ,  1.6424649 ,  1.5923225 , ...,  1.3072611 ,
          1.2181134 ,  1.2478763 ]],
       [[ 0.27066118,  0.23466069,  0.18792598, ..., -0.4611526 ,
         -0.49751845, -0.4865216 ],
        [ 0.22425456,  0.28004232,  0.27851456, ..., -0.5032771 ,
         -0.501796  , -0.502669  ],
        [-0.07466951,  0.06360884,  0.1207174 , ..., -0.50617427,
         -0.50219285, -0.5034222 ],
        [-0.47076276, -0.4705828 , -0.4747971 , ..., -0.32138503,
         -0.36619243, -0.37428448],
        [-0.4826967 , -0.5032287 , -0.48544118, ..., -0.278925  ,
         -0.31404778, -0.36052078],
        [-0.488381  , -0.48253912, -0.4697526 , ..., -0.38105175,
         -0.30813277, -0.27739233]],
       [[ 0.0615    ,  0.061625  ,  0.061     , ...,  0.12085   ,
          0.120225  ,  0.113575  ],
        [ 0.061075  ,  0.06045   ,  0.06025   , ...,  0.114625  ,
          0.119625  ,  0.117625  ],
        [ 0.06475   ,  0.06145   ,  0.060925  , ...,  0.111475  ,
          0.114925  ,  0.115175  ],
        ...,
        [ 0.1516    ,  0.14195   ,  0.1391    , ...,  0.159975  ,
          0.14145   ,  0.127075  ],
        [ 0.140325  ,  0.125975  ,  0.131875  , ...,  0.18245   ,
          0.1565    ,  0.13015   ],
        [ 0.133475  ,  0.1341    ,  0.13345   , ...,  0.15565   ,
          0.170675  ,  0.16405   ]]], dtype=float32)
Coordinates:
  * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
  * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
    spatial_ref  int32 0
  * z            (z) MultiIndex
  - variable     (z) object 'NDVI' 'MNDWI' 'GREEN'
  - band         (z) int64 1 1 1
-Attributes:
    long_name:  ['NDVI', 'MNDWI', 'GREEN']
'''
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bands</code></strong> :&ensp;<code>list</code></dt>
<dd>Bands and index combination</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>float</code></dt>
<dd>Stack resolution. . If not specified, use the product resolution.</dd>
<dt><strong><code>stack_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Stack path</dd>
<dt><strong><code>save_as_int</code></strong> :&ensp;<code>bool</code></dt>
<dd>Save stack as integers (uint16 and therefore multiply the values by 10.000)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>xr.DataArray</code></dt>
<dd>Stack as a DataArray</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stack(
    self,
    bands: list,
    resolution: float = None,
    stack_path: str = None,
    save_as_int: bool = False,
) -&gt; xr.DataArray:
    &#34;&#34;&#34;
    Stack bands and index of a products.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; from eoreader.bands.alias import *
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; prod = Reader().open(path)
    &gt;&gt;&gt; stack = prod.stack([NDVI, MNDWI, GREEN], resolution=20)  # In meters
    &gt;&gt;&gt; stack
    &#39;&#39;&#39;
    &lt;xarray.DataArray &#39;NDVI_MNDWI_GREEN&#39; (z: 3, y: 5490, x: 5490)&gt;
    array([[[ 0.949506  ,  0.92181516,  0.9279379 , ...,  1.8002278 ,
              1.5424857 ,  1.6747767 ],
            [ 0.95369846,  0.91685396,  0.8957871 , ...,  1.5847116 ,
              1.5248713 ,  1.5011379 ],
            [ 2.9928885 ,  1.3031474 ,  1.0076253 , ...,  1.5969834 ,
              1.5590671 ,  1.5018653 ],
            ...,
            [ 1.4245619 ,  1.6115025 ,  1.6201663 , ...,  1.2387121 ,
              1.4025431 ,  1.800678  ],
            [ 1.5627214 ,  1.822388  ,  1.7245892 , ...,  1.1694248 ,
              1.2573677 ,  1.5767351 ],
            [ 1.653781  ,  1.6424649 ,  1.5923225 , ...,  1.3072611 ,
              1.2181134 ,  1.2478763 ]],
           [[ 0.27066118,  0.23466069,  0.18792598, ..., -0.4611526 ,
             -0.49751845, -0.4865216 ],
            [ 0.22425456,  0.28004232,  0.27851456, ..., -0.5032771 ,
             -0.501796  , -0.502669  ],
            [-0.07466951,  0.06360884,  0.1207174 , ..., -0.50617427,
             -0.50219285, -0.5034222 ],
            [-0.47076276, -0.4705828 , -0.4747971 , ..., -0.32138503,
             -0.36619243, -0.37428448],
            [-0.4826967 , -0.5032287 , -0.48544118, ..., -0.278925  ,
             -0.31404778, -0.36052078],
            [-0.488381  , -0.48253912, -0.4697526 , ..., -0.38105175,
             -0.30813277, -0.27739233]],
           [[ 0.0615    ,  0.061625  ,  0.061     , ...,  0.12085   ,
              0.120225  ,  0.113575  ],
            [ 0.061075  ,  0.06045   ,  0.06025   , ...,  0.114625  ,
              0.119625  ,  0.117625  ],
            [ 0.06475   ,  0.06145   ,  0.060925  , ...,  0.111475  ,
              0.114925  ,  0.115175  ],
            ...,
            [ 0.1516    ,  0.14195   ,  0.1391    , ...,  0.159975  ,
              0.14145   ,  0.127075  ],
            [ 0.140325  ,  0.125975  ,  0.131875  , ...,  0.18245   ,
              0.1565    ,  0.13015   ],
            [ 0.133475  ,  0.1341    ,  0.13345   , ...,  0.15565   ,
              0.170675  ,  0.16405   ]]], dtype=float32)
    Coordinates:
      * y            (y) float64 4.5e+06 4.5e+06 4.5e+06 ... 4.39e+06 4.39e+06
      * x            (x) float64 2e+05 2e+05 2e+05 ... 3.097e+05 3.098e+05 3.098e+05
        spatial_ref  int32 0
      * z            (z) MultiIndex
      - variable     (z) object &#39;NDVI&#39; &#39;MNDWI&#39; &#39;GREEN&#39;
      - band         (z) int64 1 1 1
    -Attributes:
        long_name:  [&#39;NDVI&#39;, &#39;MNDWI&#39;, &#39;GREEN&#39;]
    &#39;&#39;&#39;
    ```

    Args:
        bands (list): Bands and index combination
        resolution (float): Stack resolution. . If not specified, use the product resolution.
        stack_path (str): Stack path
        save_as_int (bool): Save stack as integers (uint16 and therefore multiply the values by 10.000)

    Returns:
        xr.DataArray: Stack as a DataArray
    &#34;&#34;&#34;
    if not resolution:
        resolution = self.resolution

    # Create the analysis stack
    band_dict = self.load(bands, resolution)

    # Convert into dataset with str as names
    xds = xr.Dataset(
        data_vars={to_str(key)[0]: val for key, val in band_dict.items()},
        coords=band_dict[bands[0]].coords,
    )

    # Force nodata
    stack = xds.to_stacked_array(new_dim=&#34;z&#34;, sample_dims=(&#34;x&#34;, &#34;y&#34;))
    stack = stack.transpose(&#34;z&#34;, &#34;y&#34;, &#34;x&#34;)

    # Save as integer
    if save_as_int:
        dtype = np.uint16
        stack = (stack * 10000).astype(dtype)
    else:
        dtype = np.float32
        stack = stack.astype(dtype)

    # Some updates
    stack = rasters.set_nodata(stack, self.nodata)
    band_list = to_str(list(band_dict.keys()))
    stack.attrs[&#34;long_name&#34;] = band_list
    stack = stack.rename(&#34;_&#34;.join(band_list))

    # Write on disk
    if stack_path:
        rasters.write(stack, stack_path, dtype=dtype)

    # Close datasets
    for val in band_dict.values():
        val.close()

    return stack</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Home" href="/eoreader/">
<img src="https://github.com/sertit/eoreader/blob/master/docs/eoreader.png?raw=True"
alt="logo"
style="width:40%;"/>
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eoreader.products" href="index.html">eoreader.products</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="eoreader.products.product.path_or_dst" href="#eoreader.products.product.path_or_dst">path_or_dst</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eoreader.products.product.SensorType" href="#eoreader.products.product.SensorType">SensorType</a></code></h4>
<ul>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.product.SensorType.OPTICAL" href="#eoreader.products.product.SensorType.OPTICAL">OPTICAL</a></code></li>
<li><code><a title="eoreader.products.product.SensorType.SAR" href="#eoreader.products.product.SensorType.SAR">SAR</a></code></li>
</ul>
</li>
</ul>
</li>
<li>
<h4><code><a title="eoreader.products.product.Product" href="#eoreader.products.product.Product">Product</a></code></h4>
<ul>
<li>
<h4><code>Functions</code></h4>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.products.product.Product.footprint" href="#eoreader.products.product.Product.footprint">footprint</a></code></li>
<li><code><a title="eoreader.products.product.Product.extent" href="#eoreader.products.product.Product.extent">extent</a></code></li>
<li><code><a title="eoreader.products.product.Product.crs" href="#eoreader.products.product.Product.crs">crs</a></code></li>
<li><code><a title="eoreader.products.product.Product.get_datetime" href="#eoreader.products.product.Product.get_datetime">get_datetime</a></code></li>
<li><code><a title="eoreader.products.product.Product.get_date" href="#eoreader.products.product.Product.get_date">get_date</a></code></li>
<li><code><a title="eoreader.products.product.Product.get_default_band_path" href="#eoreader.products.product.Product.get_default_band_path">get_default_band_path</a></code></li>
<li><code><a title="eoreader.products.product.Product.get_default_band" href="#eoreader.products.product.Product.get_default_band">get_default_band</a></code></li>
<li><code><a title="eoreader.products.product.Product.get_existing_bands" href="#eoreader.products.product.Product.get_existing_bands">get_existing_bands</a></code></li>
<li><code><a title="eoreader.products.product.Product.get_existing_band_paths" href="#eoreader.products.product.Product.get_existing_band_paths">get_existing_band_paths</a></code></li>
<li><code><a title="eoreader.products.product.Product.get_band_paths" href="#eoreader.products.product.Product.get_band_paths">get_band_paths</a></code></li>
<li><code><a title="eoreader.products.product.Product.read_mtd" href="#eoreader.products.product.Product.read_mtd">read_mtd</a></code></li>
<li><code><a title="eoreader.products.product.Product.load" href="#eoreader.products.product.Product.load">load</a></code></li>
<li><code><a title="eoreader.products.product.Product.has_band" href="#eoreader.products.product.Product.has_band">has_band</a></code></li>
<li><code><a title="eoreader.products.product.Product.stack" href="#eoreader.products.product.Product.stack">stack</a></code></li>
</ul>
</li>
<li>
<h4><code>Variables</code></h4>
</li>
<li>
<ul class="two-column">
<li><code><a title="eoreader.products.product.Product.output" href="#eoreader.products.product.Product.output">output</a></code></li>
<li><code><a title="eoreader.products.product.Product.name" href="#eoreader.products.product.Product.name">name</a></code></li>
<li><code><a title="eoreader.products.product.Product.split_name" href="#eoreader.products.product.Product.split_name">split_name</a></code></li>
<li><code><a title="eoreader.products.product.Product.archive_path" href="#eoreader.products.product.Product.archive_path">archive_path</a></code></li>
<li><code><a title="eoreader.products.product.Product.path" href="#eoreader.products.product.Product.path">path</a></code></li>
<li><code><a title="eoreader.products.product.Product.is_archived" href="#eoreader.products.product.Product.is_archived">is_archived</a></code></li>
<li><code><a title="eoreader.products.product.Product.needs_extraction" href="#eoreader.products.product.Product.needs_extraction">needs_extraction</a></code></li>
<li><code><a title="eoreader.products.product.Product.date" href="#eoreader.products.product.Product.date">date</a></code></li>
<li><code><a title="eoreader.products.product.Product.datetime" href="#eoreader.products.product.Product.datetime">datetime</a></code></li>
<li><code><a title="eoreader.products.product.Product.tile_name" href="#eoreader.products.product.Product.tile_name">tile_name</a></code></li>
<li><code><a title="eoreader.products.product.Product.sensor_type" href="#eoreader.products.product.Product.sensor_type">sensor_type</a></code></li>
<li><code><a title="eoreader.products.product.Product.product_type" href="#eoreader.products.product.Product.product_type">product_type</a></code></li>
<li><code><a title="eoreader.products.product.Product.band_names" href="#eoreader.products.product.Product.band_names">band_names</a></code></li>
<li><code><a title="eoreader.products.product.Product.is_reference" href="#eoreader.products.product.Product.is_reference">is_reference</a></code></li>
<li><code><a title="eoreader.products.product.Product.corresponding_ref" href="#eoreader.products.product.Product.corresponding_ref">corresponding_ref</a></code></li>
<li><code><a title="eoreader.products.product.Product.nodata" href="#eoreader.products.product.Product.nodata">nodata</a></code></li>
<li><code><a title="eoreader.products.product.Product.platform" href="#eoreader.products.product.Product.platform">platform</a></code></li>
<li><code><a title="eoreader.products.product.Product.resolution" href="#eoreader.products.product.Product.resolution">resolution</a></code></li>
<li><code><a title="eoreader.products.product.Product.condensed_name" href="#eoreader.products.product.Product.condensed_name">condensed_name</a></code></li>
<li><code><a title="eoreader.products.product.Product.sat_id" href="#eoreader.products.product.Product.sat_id">sat_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>