<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc 0.9.2"/>
<title>eoreader.reader API documentation</title>
<meta name="description" content="Product Factory, class creating products according to their names"/>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/darcula.min.css"
crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100%;padding:3em 4em;border-left:1px solid #ddd;overflow-x:hidden}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}table{display:block;overflow-x:auto;word-break:keep-all;border-collapse:separate;border-spacing:0}th{background-color:#c4d5e780;padding:5px;border-bottom:0.1px solid gray;border-right:0.1px solid gray;border-top:0.1px solid gray}td,th{margin:0}td{white-space:nowrap;border-bottom:0.1px solid gray;border-right:0.1px solid gray}td:empty{background-color:#ececec}th:nth-child(1){border-left:0.1px solid gray}td:nth-child(1){border-left:0.1px solid gray;border-right:0.1px solid gray}th:nth-child(1),td:nth-child(1){background-color:#c4d5e7;position:-webkit-sticky;position:sticky;left:0}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML"
integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"
integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eoreader.reader</code></h1>
</header>
<section id="section-intro">
<p>Product Factory, class creating products according to their names</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright 2021, SERTIT-ICube - France, https://sertit.unistra.fr/
# This file is part of eoreader project
#     https://github.com/sertit/eoreader
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&#34;&#34;&#34; Product Factory, class creating products according to their names &#34;&#34;&#34;

from __future__ import annotations

import importlib
import logging
import os
import re
from enum import unique
from typing import Union

from eoreader.utils import EOREADER_NAME
from sertit import files, strings
from sertit.misc import ListEnum

LOGGER = logging.getLogger(EOREADER_NAME)


@unique
class CheckMethod(ListEnum):
    &#34;&#34;&#34;Methods to recognize a product&#34;&#34;&#34;

    MTD = &#34;Metadata&#34;
    &#34;&#34;&#34;Check the metadata: faster method&#34;&#34;&#34;

    NAME = &#34;Filename&#34;
    &#34;&#34;&#34;
    Check the filename:

    Safer method that allows modified product names as it recursively looks for the metadata name in the product files.
    For products that have generic metadata files (ie. RS2 that as mtd named `product.xml`),
    it also checks the band name.
    &#34;&#34;&#34;

    BOTH = &#34;Both&#34;
    &#34;&#34;&#34;Check the metadata and the filename: Double check if you have a doubt.&#34;&#34;&#34;


@unique
class Platform(ListEnum):
    &#34;&#34;&#34;Platforms supported by EOReader&#34;&#34;&#34;

    S1 = &#34;Sentinel-1&#34;
    &#34;&#34;&#34;Sentinel-1&#34;&#34;&#34;

    S2 = &#34;Sentinel-2&#34;
    &#34;&#34;&#34;Sentinel-2&#34;&#34;&#34;

    S2_THEIA = &#34;Sentinel-2 Theia&#34;
    &#34;&#34;&#34;Sentinel-2 Theia&#34;&#34;&#34;

    S3 = &#34;Sentinel-3&#34;
    &#34;&#34;&#34;Sentinel-3&#34;&#34;&#34;

    L8 = &#34;Landsat-8&#34;
    &#34;&#34;&#34;Landsat-8&#34;&#34;&#34;

    L7 = &#34;Landsat-7&#34;
    &#34;&#34;&#34;Landsat-7&#34;&#34;&#34;

    L5 = &#34;Landsat-5&#34;
    &#34;&#34;&#34;Landsat-5&#34;&#34;&#34;

    L4 = &#34;Landsat-4&#34;
    &#34;&#34;&#34;Landsat-4&#34;&#34;&#34;

    L3 = &#34;Landsat-3&#34;
    &#34;&#34;&#34;Landsat-3&#34;&#34;&#34;

    L2 = &#34;Landsat-2&#34;
    &#34;&#34;&#34;Landsat-2&#34;&#34;&#34;

    L1 = &#34;Landsat-1&#34;
    &#34;&#34;&#34;Landsat-1&#34;&#34;&#34;

    PLA = &#34;PlanetScope&#34;
    &#34;&#34;&#34;PlanetScope&#34;&#34;&#34;

    # RPD = &#34;RapidEye&#34;
    # &#34;&#34;&#34;RapidEye&#34;&#34;&#34;
    #
    # SKY = &#34;SkySat&#34;
    # &#34;&#34;&#34;SkySat&#34;&#34;&#34;

    CSK = &#34;COSMO-SkyMed&#34;
    &#34;&#34;&#34;COSMO-SkyMed&#34;&#34;&#34;

    TSX = &#34;TerraSAR-X&#34;
    &#34;&#34;&#34;TerraSAR-X&#34;&#34;&#34;

    RS2 = &#34;RADARSAT-2&#34;
    &#34;&#34;&#34;RADARSAT-2&#34;&#34;&#34;


PLATFORM_REGEX = {
    Platform.S1: r&#34;S1[AB]_(IW|EW|SM|WV)_(RAW|SLC|GRD|OCN)[FHM_]_[0-2]S[SD][HV]_\d{8}T\d{6}_\d{8}T\d{6}_\d{6}_.{11}&#34;,
    Platform.S2: r&#34;S2[AB]_MSIL(1C|2A)_\d{8}T\d{6}_N\d{4}_R\d{3}_T\d{2}\w{3}_\d{8}T\d{6}&#34;,
    Platform.S2_THEIA: r&#34;SENTINEL2[AB]_\d{8}-\d{6}-\d{3}_L(2A|1C)_T\d{2}\w{3}_[CDH](_V\d-\d|)&#34;,
    Platform.S3: r&#34;S3[AB]_[OS]L_[012]_\w{6}_\d{8}T\d{6}_\d{8}T\d{6}_\d{8}T\d{6}_\w{17}_\w{3}_[OFDR]_(NR|ST|NT)_\d{3}&#34;,
    Platform.L8: r&#34;LC08_L1(GT|TP)_\d{6}_\d{8}_\d{8}_\d{2}_(RT|T1|T2)&#34;,
    Platform.L7: r&#34;LE07_L1(GT|TP|GS)_\d{6}_\d{8}_\d{8}_\d{2}_(RT|T1|T2)&#34;,
    Platform.L5: r&#34;L[TM]05_L1(TP|GS)_\d{6}_\d{8}_\d{8}_\d{2}_(T1|T2)&#34;,
    Platform.L4: r&#34;L[TM]04_L1(TP|GS)_\d{6}_\d{8}_\d{8}_\d{2}_(T1|T2)&#34;,
    Platform.L3: r&#34;LM03_L1(TP|GS)_\d{6}_\d{8}_\d{8}_\d{2}_T2&#34;,
    Platform.L2: r&#34;LM02_L1(TP|GS)_\d{6}_\d{8}_\d{8}_\d{2}_T2&#34;,
    Platform.L1: r&#34;LM01_L1(TP|GS)_\d{6}_\d{8}_\d{8}_\d{2}_T2&#34;,
    Platform.PLA: r&#34;\d{8}_\d{6}_(\d{2}_|)\w{4}&#34;,
    Platform.CSK: [
        r&#34;.+&#34;,  # Need to check inside as the folder does not have any recognizable name
        r&#34;CSKS[1-4]_(RAW|SCS|DGM|GEC|GTC)_[UB]_(HI|PP|WR|HR|S2)_&#34;
        r&#34;\w{2}_(HH|VV|VH|HV|CO|CH|CV)_[LR][AD]_[FS][NF]_\d{14}_\d{14}\.h5&#34;,
    ],
    Platform.TSX: r&#34;T[SD]X1_SAR__(SSC|MGD|GEC|EEC)_[SR]E___[SH][MCLS]_[SDTQ]_[SD]RA_\d{8}T\d{6}_\d{8}T\d{6}&#34;,
    Platform.RS2: r&#34;RS2_OK\d+_PK\d+_DK\d+_.{2,}_\d{8}_\d{6}(_(HH|VV|VH|HV)){1,4}_S(LC|GX|GF|CN|CW|CF|CS|SG|PG)&#34;,
}

# Not used for now
MTD_REGEX = {
    Platform.S1: r&#34;.*s1[ab]-(iw|ew|sm|wv)\d*-(raw|slc|grd|ocn)-[hv]{2}-\d{8}t\d{6}-\d{8}t\d{6}-\d{6}-\w{6}-\d{3}\.xml&#34;,
    Platform.S2: [
        r&#34;MTD_MSIL(1C|2A)\.xml&#34;,  # Too generic name, check also a band
        r&#34;T\d{2}\w{3}_\d{8}T\d{6}_B\d{2}(_\d0m|).jp2&#34;,
    ],
    Platform.S2_THEIA: f&#34;{PLATFORM_REGEX[Platform.S2_THEIA]}_MTD_ALL\.xml&#34;,
    Platform.S3: [
        r&#34;xfdumanifest\.xml&#34;,  # Not the real metadata...
        r&#34;(S\d|Oa\d{2})_radiance(_an|).nc&#34;,
    ],
    Platform.L8: f&#34;{PLATFORM_REGEX[Platform.L8]}_MTL\.txt&#34;,
    Platform.L7: f&#34;{PLATFORM_REGEX[Platform.L7]}_MTL\.txt&#34;,
    Platform.L5: f&#34;{PLATFORM_REGEX[Platform.L5]}_MTL\.txt&#34;,
    Platform.L4: f&#34;{PLATFORM_REGEX[Platform.L4]}_MTL\.txt&#34;,
    Platform.L3: f&#34;{PLATFORM_REGEX[Platform.L3]}_MTL\.txt&#34;,
    Platform.L2: f&#34;{PLATFORM_REGEX[Platform.L2]}_MTL\.txt&#34;,
    Platform.L1: f&#34;{PLATFORM_REGEX[Platform.L1]}_MTL\.txt&#34;,
    Platform.PLA: r&#34;\d{8}_\d{6}_(\d{2}_|)\w{4}_[13][AB]_.*\.xml&#34;,
    Platform.CSK: f&#34;{PLATFORM_REGEX[Platform.CSK][1]}\.xml&#34;,
    Platform.TSX: f&#34;{PLATFORM_REGEX[Platform.TSX]}\.xml&#34;,
    Platform.RS2: [
        r&#34;product\.xml&#34;,  # Too generic name, check also a band
        r&#34;imagery_[HV]{2}.tif&#34;,
    ],
}
&#34;&#34;&#34;Platform XML regex, mapping every metadata XML to a regex allowing the reader to recognize them (as a fallback).&#34;&#34;&#34;


class Reader:
    &#34;&#34;&#34;
    Factory class creating satellite products according to their names.

    It creates a singleton that you can call only on,e time per file.
    &#34;&#34;&#34;

    def __init__(self):
        self._platform_regex = {}
        self._mtd_regex = {}

        # Register platforms
        for platform, regex in PLATFORM_REGEX.items():
            self._platform_regex[platform] = self._compile(regex, prefix=&#34;&#34;, suffix=&#34;&#34;)

        # Register metadata
        for platform, regex in MTD_REGEX.items():
            self._mtd_regex[platform] = self._compile(regex, prefix=&#34;.*&#34;, suffix=&#34;&#34;)

    def _compile(self, regex: Union[str, list], prefix=&#34;^&#34;, suffix=&#34;&amp;&#34;) -&gt; list:
        &#34;&#34;&#34;
        Compile regex or list of regex

        Args:
            regex (Union[str, list]): Regex in `re` sense
            prefix (str): Prefix of regex, ^ by default (means start of the string)
            suffix (str): Prefix of regex, &amp; by default (means end of the string)

        Returns:
            list: List of compiled pattern
        &#34;&#34;&#34;

        def _compile_(regex_str: str):
            return re.compile(f&#34;{prefix}{regex_str}{suffix}&#34;)

        # Case folder is not enough to identify the products (ie. COSMO Skymed)
        if isinstance(regex, list):
            comp = [_compile_(regex) for regex in regex]
        else:
            comp = [_compile_(regex)]

        return comp

    def open(
        self,
        product_path: str,
        archive_path: str = None,
        output_path: str = None,
        method=CheckMethod.MTD,
    ) -&gt; &#34;Product&#34;:  # noqa: F821
        &#34;&#34;&#34;
        Open the product.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; Reader().open(path)
        &lt;eoreader.products.optical.s2_product.S2Product object at 0x000001984986FAC8&gt;
        ```

        Args:
            product_path (str): Product path
            archive_path (str): Archive path
            output_path (str): Output Path
            look_for_mtd (bool): Look for the metadata. If false, only check the

        Returns:
            Product: Correct products

        &#34;&#34;&#34;
        prod = None
        for platform in Platform.list_names():
            if method == CheckMethod.MTD:
                is_valid = self.valid_mtd(product_path, platform)
            elif method == CheckMethod.NAME:
                is_valid = self.valid_name(product_path, platform)
            else:
                is_valid = self.valid_name(product_path, platform) and self.valid_mtd(
                    product_path, platform
                )

            if is_valid:
                sat_class = platform.lower() + &#34;_product&#34;

                # Manage both optical and SAR
                try:
                    mod = importlib.import_module(f&#34;eoreader.products.sar.{sat_class}&#34;)
                except ModuleNotFoundError:
                    mod = importlib.import_module(
                        f&#34;eoreader.products.optical.{sat_class}&#34;
                    )

                class_ = getattr(mod, strings.snake_to_camel_case(sat_class))
                prod = class_(product_path, archive_path, output_path)
                break

        if not prod:
            LOGGER.warning(
                &#34;There is no existing products in EOReader corresponding to %s&#34;,
                product_path,
            )

        return prod

    def valid_name(self, product_path: str, platform: Union[str, Platform]) -&gt; bool:
        &#34;&#34;&#34;
        Check if the product&#39;s name is valid for the given satellite

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader, Platform
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; With IDs
        &gt;&gt;&gt; Reader().valid_name(path, &#34;S1&#34;)
        False
        &gt;&gt;&gt; Reader().valid_name(path, &#34;S2&#34;)
        True

        &gt;&gt;&gt; # With names
        &gt;&gt;&gt; Reader().valid_name(path, &#34;Sentinel-1&#34;)
        False
        &gt;&gt;&gt; Reader().valid_name(path, &#34;Sentinel-2&#34;)
        True

        &gt;&gt;&gt; # With Platform
        &gt;&gt;&gt; Reader().valid_name(path, Platform.S1)
        False
        &gt;&gt;&gt; Reader().valid_name(path, Platform.S2)
        True
        ```

        Args:
            product_path (str): Product path
            platform (str): Platform&#39;s name or ID

        Returns:
            bool: True if valid name

        &#34;&#34;&#34;
        platform = Platform.convert_from(platform)[0]
        regex = self._platform_regex[platform]
        return self._is_filename_valid(product_path, regex)

    def valid_mtd(self, product_path: str, platform: Union[str, Platform]) -&gt; bool:
        &#34;&#34;&#34;
        Check if the product&#39;s mtd is in the product folder/archive

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader, Platform
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; With IDs
        &gt;&gt;&gt; Reader().valid_mtd(path, &#34;S1&#34;)
        False
        &gt;&gt;&gt; Reader().valid_mtd(path, &#34;S2&#34;)
        True

        &gt;&gt;&gt; # With names
        &gt;&gt;&gt; Reader().valid_mtd(path, &#34;Sentinel-1&#34;)
        False
        &gt;&gt;&gt; Reader().valid_mtd(path, &#34;Sentinel-2&#34;)
        True

        &gt;&gt;&gt; # With Platform
        &gt;&gt;&gt; Reader().valid_mtd(path, Platform.S1)
        False
        &gt;&gt;&gt; Reader().valid_mtd(path, Platform.S2)
        True
        ```

        Args:
            product_path (str): Product path
            platform (str): Platform&#39;s name or ID

        Returns:
            bool: True if valid name

        &#34;&#34;&#34;
        platform = Platform.convert_from(platform)[0]

        # Here the list is a check of several files
        regex_list = self._mtd_regex[platform]

        # False by default
        is_valid = [False for idx in regex_list]

        for idx, regex in enumerate(regex_list):
            # Folder
            if os.path.isdir(product_path):
                for root, dirs, fls in os.walk(product_path):
                    for fle in fls:
                        if regex.match(fle):
                            is_valid[idx] = True
                            break

            # Archive
            else:
                if os.path.isfile(product_path):
                    fls = files.get_archived_file_list(product_path)
                    for fle in fls:
                        if regex.match(fle):
                            is_valid[idx] = True
                            break

        return all(is_valid)

    @staticmethod
    def _is_filename_valid(product_path: str, regex: Union[list, re.Pattern]) -&gt; bool:
        &#34;&#34;&#34;
        Check if the filename corresponds to the given satellite regex.

        Checks also if a file inside the directory is correct.

        .. WARNING::
            Two level max for the moment

        Args:
            product_path (str): Product path
            regex (Union[list, re.Pattern]): Regex or list of regex

        Returns:
            bool: True if the filename corresponds to the given satellite regex
        &#34;&#34;&#34;
        product_file_name = files.get_filename(product_path)

        # Case folder is not enough to identify the products (ie. COSMO Skymed)
        # WARNING: Two level max for the moment
        is_valid = bool(regex[0].match(product_file_name))
        if is_valid and len(regex) &gt; 1:
            is_valid = False  # Reset
            if os.path.isdir(product_path):
                file_list = os.listdir(product_path)
                for file in file_list:
                    if regex[1].match(file):
                        is_valid = True
                        break
            else:
                LOGGER.debug(&#34;The product should be a folder.&#34;)

        return is_valid</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="eoreader.reader.MTD_REGEX"><code class="name">var <span class="ident">MTD_REGEX</span></code></dt>
<dd>
<div class="desc"><p>Platform XML regex, mapping every metadata XML to a regex allowing the reader to recognize them (as a fallback).</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eoreader.reader.CheckMethod"><code class="flex name class">
<span>class <span class="ident">CheckMethod</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Methods to recognize a product</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckMethod(ListEnum):
    &#34;&#34;&#34;Methods to recognize a product&#34;&#34;&#34;

    MTD = &#34;Metadata&#34;
    &#34;&#34;&#34;Check the metadata: faster method&#34;&#34;&#34;

    NAME = &#34;Filename&#34;
    &#34;&#34;&#34;
    Check the filename:

    Safer method that allows modified product names as it recursively looks for the metadata name in the product files.
    For products that have generic metadata files (ie. RS2 that as mtd named `product.xml`),
    it also checks the band name.
    &#34;&#34;&#34;

    BOTH = &#34;Both&#34;
    &#34;&#34;&#34;Check the metadata and the filename: Double check if you have a doubt.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sertit.misc.ListEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eoreader.reader.CheckMethod.MTD"><code class="name">var <span class="ident">MTD</span></code>
</dt>
<dd>
<div class="desc"><p>Check the metadata: faster method</p></div>
</dd>
<dt id="eoreader.reader.CheckMethod.NAME"><code class="name">var <span class="ident">NAME</span></code>
</dt>
<dd>
<div class="desc"><p>Check the filename:</p>
<p>Safer method that allows modified product names as it recursively looks for the metadata name in the product files.
For products that have generic metadata files (ie. RS2 that as mtd named <code>product.xml</code>),
it also checks the band name.</p></div>
</dd>
<dt id="eoreader.reader.CheckMethod.BOTH"><code class="name">var <span class="ident">BOTH</span></code>
</dt>
<dd>
<div class="desc"><p>Check the metadata and the filename: Double check if you have a doubt.</p></div>
</dd>
</dl>
</dd>
<dt id="eoreader.reader.Platform"><code class="flex name class">
<span>class <span class="ident">Platform</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Platforms supported by EOReader</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Platform(ListEnum):
    &#34;&#34;&#34;Platforms supported by EOReader&#34;&#34;&#34;

    S1 = &#34;Sentinel-1&#34;
    &#34;&#34;&#34;Sentinel-1&#34;&#34;&#34;

    S2 = &#34;Sentinel-2&#34;
    &#34;&#34;&#34;Sentinel-2&#34;&#34;&#34;

    S2_THEIA = &#34;Sentinel-2 Theia&#34;
    &#34;&#34;&#34;Sentinel-2 Theia&#34;&#34;&#34;

    S3 = &#34;Sentinel-3&#34;
    &#34;&#34;&#34;Sentinel-3&#34;&#34;&#34;

    L8 = &#34;Landsat-8&#34;
    &#34;&#34;&#34;Landsat-8&#34;&#34;&#34;

    L7 = &#34;Landsat-7&#34;
    &#34;&#34;&#34;Landsat-7&#34;&#34;&#34;

    L5 = &#34;Landsat-5&#34;
    &#34;&#34;&#34;Landsat-5&#34;&#34;&#34;

    L4 = &#34;Landsat-4&#34;
    &#34;&#34;&#34;Landsat-4&#34;&#34;&#34;

    L3 = &#34;Landsat-3&#34;
    &#34;&#34;&#34;Landsat-3&#34;&#34;&#34;

    L2 = &#34;Landsat-2&#34;
    &#34;&#34;&#34;Landsat-2&#34;&#34;&#34;

    L1 = &#34;Landsat-1&#34;
    &#34;&#34;&#34;Landsat-1&#34;&#34;&#34;

    PLA = &#34;PlanetScope&#34;
    &#34;&#34;&#34;PlanetScope&#34;&#34;&#34;

    # RPD = &#34;RapidEye&#34;
    # &#34;&#34;&#34;RapidEye&#34;&#34;&#34;
    #
    # SKY = &#34;SkySat&#34;
    # &#34;&#34;&#34;SkySat&#34;&#34;&#34;

    CSK = &#34;COSMO-SkyMed&#34;
    &#34;&#34;&#34;COSMO-SkyMed&#34;&#34;&#34;

    TSX = &#34;TerraSAR-X&#34;
    &#34;&#34;&#34;TerraSAR-X&#34;&#34;&#34;

    RS2 = &#34;RADARSAT-2&#34;
    &#34;&#34;&#34;RADARSAT-2&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sertit.misc.ListEnum</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="eoreader.reader.Platform.S1"><code class="name">var <span class="ident">S1</span></code>
</dt>
<dd>
<div class="desc"><p>Sentinel-1</p></div>
</dd>
<dt id="eoreader.reader.Platform.S2"><code class="name">var <span class="ident">S2</span></code>
</dt>
<dd>
<div class="desc"><p>Sentinel-2</p></div>
</dd>
<dt id="eoreader.reader.Platform.S2_THEIA"><code class="name">var <span class="ident">S2_THEIA</span></code>
</dt>
<dd>
<div class="desc"><p>Sentinel-2 Theia</p></div>
</dd>
<dt id="eoreader.reader.Platform.S3"><code class="name">var <span class="ident">S3</span></code>
</dt>
<dd>
<div class="desc"><p>Sentinel-3</p></div>
</dd>
<dt id="eoreader.reader.Platform.L8"><code class="name">var <span class="ident">L8</span></code>
</dt>
<dd>
<div class="desc"><p>Landsat-8</p></div>
</dd>
<dt id="eoreader.reader.Platform.L7"><code class="name">var <span class="ident">L7</span></code>
</dt>
<dd>
<div class="desc"><p>Landsat-7</p></div>
</dd>
<dt id="eoreader.reader.Platform.L5"><code class="name">var <span class="ident">L5</span></code>
</dt>
<dd>
<div class="desc"><p>Landsat-5</p></div>
</dd>
<dt id="eoreader.reader.Platform.L4"><code class="name">var <span class="ident">L4</span></code>
</dt>
<dd>
<div class="desc"><p>Landsat-4</p></div>
</dd>
<dt id="eoreader.reader.Platform.L3"><code class="name">var <span class="ident">L3</span></code>
</dt>
<dd>
<div class="desc"><p>Landsat-3</p></div>
</dd>
<dt id="eoreader.reader.Platform.L2"><code class="name">var <span class="ident">L2</span></code>
</dt>
<dd>
<div class="desc"><p>Landsat-2</p></div>
</dd>
<dt id="eoreader.reader.Platform.L1"><code class="name">var <span class="ident">L1</span></code>
</dt>
<dd>
<div class="desc"><p>Landsat-1</p></div>
</dd>
<dt id="eoreader.reader.Platform.PLA"><code class="name">var <span class="ident">PLA</span></code>
</dt>
<dd>
<div class="desc"><p>PlanetScope</p></div>
</dd>
<dt id="eoreader.reader.Platform.CSK"><code class="name">var <span class="ident">CSK</span></code>
</dt>
<dd>
<div class="desc"><p>COSMO-SkyMed</p></div>
</dd>
<dt id="eoreader.reader.Platform.TSX"><code class="name">var <span class="ident">TSX</span></code>
</dt>
<dd>
<div class="desc"><p>TerraSAR-X</p></div>
</dd>
<dt id="eoreader.reader.Platform.RS2"><code class="name">var <span class="ident">RS2</span></code>
</dt>
<dd>
<div class="desc"><p>RADARSAT-2</p></div>
</dd>
</dl>
</dd>
<dt id="eoreader.reader.Reader"><code class="flex name class">
<span>class <span class="ident">Reader</span></span>
</code></dt>
<dd>
<div class="desc"><p>Factory class creating satellite products according to their names.</p>
<p>It creates a singleton that you can call only on,e time per file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Reader:
    &#34;&#34;&#34;
    Factory class creating satellite products according to their names.

    It creates a singleton that you can call only on,e time per file.
    &#34;&#34;&#34;

    def __init__(self):
        self._platform_regex = {}
        self._mtd_regex = {}

        # Register platforms
        for platform, regex in PLATFORM_REGEX.items():
            self._platform_regex[platform] = self._compile(regex, prefix=&#34;&#34;, suffix=&#34;&#34;)

        # Register metadata
        for platform, regex in MTD_REGEX.items():
            self._mtd_regex[platform] = self._compile(regex, prefix=&#34;.*&#34;, suffix=&#34;&#34;)

    def _compile(self, regex: Union[str, list], prefix=&#34;^&#34;, suffix=&#34;&amp;&#34;) -&gt; list:
        &#34;&#34;&#34;
        Compile regex or list of regex

        Args:
            regex (Union[str, list]): Regex in `re` sense
            prefix (str): Prefix of regex, ^ by default (means start of the string)
            suffix (str): Prefix of regex, &amp; by default (means end of the string)

        Returns:
            list: List of compiled pattern
        &#34;&#34;&#34;

        def _compile_(regex_str: str):
            return re.compile(f&#34;{prefix}{regex_str}{suffix}&#34;)

        # Case folder is not enough to identify the products (ie. COSMO Skymed)
        if isinstance(regex, list):
            comp = [_compile_(regex) for regex in regex]
        else:
            comp = [_compile_(regex)]

        return comp

    def open(
        self,
        product_path: str,
        archive_path: str = None,
        output_path: str = None,
        method=CheckMethod.MTD,
    ) -&gt; &#34;Product&#34;:  # noqa: F821
        &#34;&#34;&#34;
        Open the product.

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; Reader().open(path)
        &lt;eoreader.products.optical.s2_product.S2Product object at 0x000001984986FAC8&gt;
        ```

        Args:
            product_path (str): Product path
            archive_path (str): Archive path
            output_path (str): Output Path
            look_for_mtd (bool): Look for the metadata. If false, only check the

        Returns:
            Product: Correct products

        &#34;&#34;&#34;
        prod = None
        for platform in Platform.list_names():
            if method == CheckMethod.MTD:
                is_valid = self.valid_mtd(product_path, platform)
            elif method == CheckMethod.NAME:
                is_valid = self.valid_name(product_path, platform)
            else:
                is_valid = self.valid_name(product_path, platform) and self.valid_mtd(
                    product_path, platform
                )

            if is_valid:
                sat_class = platform.lower() + &#34;_product&#34;

                # Manage both optical and SAR
                try:
                    mod = importlib.import_module(f&#34;eoreader.products.sar.{sat_class}&#34;)
                except ModuleNotFoundError:
                    mod = importlib.import_module(
                        f&#34;eoreader.products.optical.{sat_class}&#34;
                    )

                class_ = getattr(mod, strings.snake_to_camel_case(sat_class))
                prod = class_(product_path, archive_path, output_path)
                break

        if not prod:
            LOGGER.warning(
                &#34;There is no existing products in EOReader corresponding to %s&#34;,
                product_path,
            )

        return prod

    def valid_name(self, product_path: str, platform: Union[str, Platform]) -&gt; bool:
        &#34;&#34;&#34;
        Check if the product&#39;s name is valid for the given satellite

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader, Platform
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; With IDs
        &gt;&gt;&gt; Reader().valid_name(path, &#34;S1&#34;)
        False
        &gt;&gt;&gt; Reader().valid_name(path, &#34;S2&#34;)
        True

        &gt;&gt;&gt; # With names
        &gt;&gt;&gt; Reader().valid_name(path, &#34;Sentinel-1&#34;)
        False
        &gt;&gt;&gt; Reader().valid_name(path, &#34;Sentinel-2&#34;)
        True

        &gt;&gt;&gt; # With Platform
        &gt;&gt;&gt; Reader().valid_name(path, Platform.S1)
        False
        &gt;&gt;&gt; Reader().valid_name(path, Platform.S2)
        True
        ```

        Args:
            product_path (str): Product path
            platform (str): Platform&#39;s name or ID

        Returns:
            bool: True if valid name

        &#34;&#34;&#34;
        platform = Platform.convert_from(platform)[0]
        regex = self._platform_regex[platform]
        return self._is_filename_valid(product_path, regex)

    def valid_mtd(self, product_path: str, platform: Union[str, Platform]) -&gt; bool:
        &#34;&#34;&#34;
        Check if the product&#39;s mtd is in the product folder/archive

        ```python
        &gt;&gt;&gt; from eoreader.reader import Reader, Platform
        &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
        &gt;&gt;&gt; With IDs
        &gt;&gt;&gt; Reader().valid_mtd(path, &#34;S1&#34;)
        False
        &gt;&gt;&gt; Reader().valid_mtd(path, &#34;S2&#34;)
        True

        &gt;&gt;&gt; # With names
        &gt;&gt;&gt; Reader().valid_mtd(path, &#34;Sentinel-1&#34;)
        False
        &gt;&gt;&gt; Reader().valid_mtd(path, &#34;Sentinel-2&#34;)
        True

        &gt;&gt;&gt; # With Platform
        &gt;&gt;&gt; Reader().valid_mtd(path, Platform.S1)
        False
        &gt;&gt;&gt; Reader().valid_mtd(path, Platform.S2)
        True
        ```

        Args:
            product_path (str): Product path
            platform (str): Platform&#39;s name or ID

        Returns:
            bool: True if valid name

        &#34;&#34;&#34;
        platform = Platform.convert_from(platform)[0]

        # Here the list is a check of several files
        regex_list = self._mtd_regex[platform]

        # False by default
        is_valid = [False for idx in regex_list]

        for idx, regex in enumerate(regex_list):
            # Folder
            if os.path.isdir(product_path):
                for root, dirs, fls in os.walk(product_path):
                    for fle in fls:
                        if regex.match(fle):
                            is_valid[idx] = True
                            break

            # Archive
            else:
                if os.path.isfile(product_path):
                    fls = files.get_archived_file_list(product_path)
                    for fle in fls:
                        if regex.match(fle):
                            is_valid[idx] = True
                            break

        return all(is_valid)

    @staticmethod
    def _is_filename_valid(product_path: str, regex: Union[list, re.Pattern]) -&gt; bool:
        &#34;&#34;&#34;
        Check if the filename corresponds to the given satellite regex.

        Checks also if a file inside the directory is correct.

        .. WARNING::
            Two level max for the moment

        Args:
            product_path (str): Product path
            regex (Union[list, re.Pattern]): Regex or list of regex

        Returns:
            bool: True if the filename corresponds to the given satellite regex
        &#34;&#34;&#34;
        product_file_name = files.get_filename(product_path)

        # Case folder is not enough to identify the products (ie. COSMO Skymed)
        # WARNING: Two level max for the moment
        is_valid = bool(regex[0].match(product_file_name))
        if is_valid and len(regex) &gt; 1:
            is_valid = False  # Reset
            if os.path.isdir(product_path):
                file_list = os.listdir(product_path)
                for file in file_list:
                    if regex[1].match(file):
                        is_valid = True
                        break
            else:
                LOGGER.debug(&#34;The product should be a folder.&#34;)

        return is_valid</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="eoreader.reader.Reader.open"><code class="name flex">
<p>def <span class="ident">open</span>(</p><p>self, <br>product_path, <br>archive_path=None, <br>output_path=None, <br>method=CheckMethod.MTD)</p>
</code></dt>
<dd>
<div class="desc"><p>Open the product.</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; Reader().open(path)
&lt;eoreader.products.optical.s2_product.S2Product object at 0x000001984986FAC8&gt;
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>product_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Product path</dd>
<dt><strong><code>archive_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Archive path</dd>
<dt><strong><code>output_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Output Path</dd>
<dt><strong><code>look_for_mtd</code></strong> :&ensp;<code>bool</code></dt>
<dd>Look for the metadata. If false, only check the</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Product</code></dt>
<dd>Correct products</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(
    self,
    product_path: str,
    archive_path: str = None,
    output_path: str = None,
    method=CheckMethod.MTD,
) -&gt; &#34;Product&#34;:  # noqa: F821
    &#34;&#34;&#34;
    Open the product.

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; Reader().open(path)
    &lt;eoreader.products.optical.s2_product.S2Product object at 0x000001984986FAC8&gt;
    ```

    Args:
        product_path (str): Product path
        archive_path (str): Archive path
        output_path (str): Output Path
        look_for_mtd (bool): Look for the metadata. If false, only check the

    Returns:
        Product: Correct products

    &#34;&#34;&#34;
    prod = None
    for platform in Platform.list_names():
        if method == CheckMethod.MTD:
            is_valid = self.valid_mtd(product_path, platform)
        elif method == CheckMethod.NAME:
            is_valid = self.valid_name(product_path, platform)
        else:
            is_valid = self.valid_name(product_path, platform) and self.valid_mtd(
                product_path, platform
            )

        if is_valid:
            sat_class = platform.lower() + &#34;_product&#34;

            # Manage both optical and SAR
            try:
                mod = importlib.import_module(f&#34;eoreader.products.sar.{sat_class}&#34;)
            except ModuleNotFoundError:
                mod = importlib.import_module(
                    f&#34;eoreader.products.optical.{sat_class}&#34;
                )

            class_ = getattr(mod, strings.snake_to_camel_case(sat_class))
            prod = class_(product_path, archive_path, output_path)
            break

    if not prod:
        LOGGER.warning(
            &#34;There is no existing products in EOReader corresponding to %s&#34;,
            product_path,
        )

    return prod</code></pre>
</details>
</dd>
<dt id="eoreader.reader.Reader.valid_name"><code class="name flex">
<p>def <span class="ident">valid_name</span>(</p><p>self, <br>product_path, <br>platform)</p>
</code></dt>
<dd>
<div class="desc"><p>Check if the product's name is valid for the given satellite</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader, Platform
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; With IDs
&gt;&gt;&gt; Reader().valid_name(path, &quot;S1&quot;)
False
&gt;&gt;&gt; Reader().valid_name(path, &quot;S2&quot;)
True

&gt;&gt;&gt; # With names
&gt;&gt;&gt; Reader().valid_name(path, &quot;Sentinel-1&quot;)
False
&gt;&gt;&gt; Reader().valid_name(path, &quot;Sentinel-2&quot;)
True

&gt;&gt;&gt; # With Platform
&gt;&gt;&gt; Reader().valid_name(path, Platform.S1)
False
&gt;&gt;&gt; Reader().valid_name(path, Platform.S2)
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>product_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Product path</dd>
<dt><strong><code>platform</code></strong> :&ensp;<code>str</code></dt>
<dd>Platform's name or ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if valid name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valid_name(self, product_path: str, platform: Union[str, Platform]) -&gt; bool:
    &#34;&#34;&#34;
    Check if the product&#39;s name is valid for the given satellite

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader, Platform
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; With IDs
    &gt;&gt;&gt; Reader().valid_name(path, &#34;S1&#34;)
    False
    &gt;&gt;&gt; Reader().valid_name(path, &#34;S2&#34;)
    True

    &gt;&gt;&gt; # With names
    &gt;&gt;&gt; Reader().valid_name(path, &#34;Sentinel-1&#34;)
    False
    &gt;&gt;&gt; Reader().valid_name(path, &#34;Sentinel-2&#34;)
    True

    &gt;&gt;&gt; # With Platform
    &gt;&gt;&gt; Reader().valid_name(path, Platform.S1)
    False
    &gt;&gt;&gt; Reader().valid_name(path, Platform.S2)
    True
    ```

    Args:
        product_path (str): Product path
        platform (str): Platform&#39;s name or ID

    Returns:
        bool: True if valid name

    &#34;&#34;&#34;
    platform = Platform.convert_from(platform)[0]
    regex = self._platform_regex[platform]
    return self._is_filename_valid(product_path, regex)</code></pre>
</details>
</dd>
<dt id="eoreader.reader.Reader.valid_mtd"><code class="name flex">
<p>def <span class="ident">valid_mtd</span>(</p><p>self, <br>product_path, <br>platform)</p>
</code></dt>
<dd>
<div class="desc"><p>Check if the product's mtd is in the product folder/archive</p>
<pre><code class="language-python">&gt;&gt;&gt; from eoreader.reader import Reader, Platform
&gt;&gt;&gt; path = r&quot;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&quot;
&gt;&gt;&gt; With IDs
&gt;&gt;&gt; Reader().valid_mtd(path, &quot;S1&quot;)
False
&gt;&gt;&gt; Reader().valid_mtd(path, &quot;S2&quot;)
True

&gt;&gt;&gt; # With names
&gt;&gt;&gt; Reader().valid_mtd(path, &quot;Sentinel-1&quot;)
False
&gt;&gt;&gt; Reader().valid_mtd(path, &quot;Sentinel-2&quot;)
True

&gt;&gt;&gt; # With Platform
&gt;&gt;&gt; Reader().valid_mtd(path, Platform.S1)
False
&gt;&gt;&gt; Reader().valid_mtd(path, Platform.S2)
True
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>product_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Product path</dd>
<dt><strong><code>platform</code></strong> :&ensp;<code>str</code></dt>
<dd>Platform's name or ID</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if valid name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valid_mtd(self, product_path: str, platform: Union[str, Platform]) -&gt; bool:
    &#34;&#34;&#34;
    Check if the product&#39;s mtd is in the product folder/archive

    ```python
    &gt;&gt;&gt; from eoreader.reader import Reader, Platform
    &gt;&gt;&gt; path = r&#34;S2A_MSIL1C_20200824T110631_N0209_R137_T30TTK_20200824T150432.SAFE.zip&#34;
    &gt;&gt;&gt; With IDs
    &gt;&gt;&gt; Reader().valid_mtd(path, &#34;S1&#34;)
    False
    &gt;&gt;&gt; Reader().valid_mtd(path, &#34;S2&#34;)
    True

    &gt;&gt;&gt; # With names
    &gt;&gt;&gt; Reader().valid_mtd(path, &#34;Sentinel-1&#34;)
    False
    &gt;&gt;&gt; Reader().valid_mtd(path, &#34;Sentinel-2&#34;)
    True

    &gt;&gt;&gt; # With Platform
    &gt;&gt;&gt; Reader().valid_mtd(path, Platform.S1)
    False
    &gt;&gt;&gt; Reader().valid_mtd(path, Platform.S2)
    True
    ```

    Args:
        product_path (str): Product path
        platform (str): Platform&#39;s name or ID

    Returns:
        bool: True if valid name

    &#34;&#34;&#34;
    platform = Platform.convert_from(platform)[0]

    # Here the list is a check of several files
    regex_list = self._mtd_regex[platform]

    # False by default
    is_valid = [False for idx in regex_list]

    for idx, regex in enumerate(regex_list):
        # Folder
        if os.path.isdir(product_path):
            for root, dirs, fls in os.walk(product_path):
                for fle in fls:
                    if regex.match(fle):
                        is_valid[idx] = True
                        break

        # Archive
        else:
            if os.path.isfile(product_path):
                fls = files.get_archived_file_list(product_path)
                for fle in fls:
                    if regex.match(fle):
                        is_valid[idx] = True
                        break

    return all(is_valid)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Home" href="/eoreader/">
<img src="https://github.com/sertit/eoreader/blob/master/docs/eoreader.png?raw=True"
alt="logo"
style="width:40%;"/>
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eoreader" href="index.html">eoreader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="eoreader.reader.MTD_REGEX" href="#eoreader.reader.MTD_REGEX">MTD_REGEX</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eoreader.reader.CheckMethod" href="#eoreader.reader.CheckMethod">CheckMethod</a></code></h4>
<ul>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.reader.CheckMethod.MTD" href="#eoreader.reader.CheckMethod.MTD">MTD</a></code></li>
<li><code><a title="eoreader.reader.CheckMethod.NAME" href="#eoreader.reader.CheckMethod.NAME">NAME</a></code></li>
<li><code><a title="eoreader.reader.CheckMethod.BOTH" href="#eoreader.reader.CheckMethod.BOTH">BOTH</a></code></li>
</ul>
</li>
</ul>
</li>
<li>
<h4><code><a title="eoreader.reader.Platform" href="#eoreader.reader.Platform">Platform</a></code></h4>
<ul>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
<ul class="two-column">
<li><code><a title="eoreader.reader.Platform.S1" href="#eoreader.reader.Platform.S1">S1</a></code></li>
<li><code><a title="eoreader.reader.Platform.S2" href="#eoreader.reader.Platform.S2">S2</a></code></li>
<li><code><a title="eoreader.reader.Platform.S2_THEIA" href="#eoreader.reader.Platform.S2_THEIA">S2_THEIA</a></code></li>
<li><code><a title="eoreader.reader.Platform.S3" href="#eoreader.reader.Platform.S3">S3</a></code></li>
<li><code><a title="eoreader.reader.Platform.L8" href="#eoreader.reader.Platform.L8">L8</a></code></li>
<li><code><a title="eoreader.reader.Platform.L7" href="#eoreader.reader.Platform.L7">L7</a></code></li>
<li><code><a title="eoreader.reader.Platform.L5" href="#eoreader.reader.Platform.L5">L5</a></code></li>
<li><code><a title="eoreader.reader.Platform.L4" href="#eoreader.reader.Platform.L4">L4</a></code></li>
<li><code><a title="eoreader.reader.Platform.L3" href="#eoreader.reader.Platform.L3">L3</a></code></li>
<li><code><a title="eoreader.reader.Platform.L2" href="#eoreader.reader.Platform.L2">L2</a></code></li>
<li><code><a title="eoreader.reader.Platform.L1" href="#eoreader.reader.Platform.L1">L1</a></code></li>
<li><code><a title="eoreader.reader.Platform.PLA" href="#eoreader.reader.Platform.PLA">PLA</a></code></li>
<li><code><a title="eoreader.reader.Platform.CSK" href="#eoreader.reader.Platform.CSK">CSK</a></code></li>
<li><code><a title="eoreader.reader.Platform.TSX" href="#eoreader.reader.Platform.TSX">TSX</a></code></li>
<li><code><a title="eoreader.reader.Platform.RS2" href="#eoreader.reader.Platform.RS2">RS2</a></code></li>
</ul>
</li>
</ul>
</li>
<li>
<h4><code><a title="eoreader.reader.Reader" href="#eoreader.reader.Reader">Reader</a></code></h4>
<ul>
<li>
</li>
<li>
<ul class="">
<li><code><a title="eoreader.reader.Reader.open" href="#eoreader.reader.Reader.open">open</a></code></li>
<li><code><a title="eoreader.reader.Reader.valid_name" href="#eoreader.reader.Reader.valid_name">valid_name</a></code></li>
<li><code><a title="eoreader.reader.Reader.valid_mtd" href="#eoreader.reader.Reader.valid_mtd">valid_mtd</a></code></li>
</ul>
</li>
<li>
</li>
<li>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>