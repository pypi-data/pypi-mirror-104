{"version":3,"sources":["webpack://katscript-jupyterlab/./lib/codemirror-katscript-python.js","webpack://katscript-jupyterlab/./lib/codemirror-katscript-types.js","webpack://katscript-jupyterlab/./lib/codemirror-katscript.js","webpack://katscript-jupyterlab/./lib/codemirror-katscript2.js","webpack://katscript-jupyterlab/./lib/codemirror-my-multiplex.js","webpack://katscript-jupyterlab/./lib/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAmE;AACJ;AACF;AACtD;AACP;AACA,IAAI,gFAAsB;AAC1B,IAAI,4EAAoB;AACxB,IAAI,0EAAmB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;AC7BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;;;;;;;;;;;;;;;AC/K4F;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAQ;AACpC,2CAA2C,iEAAQ;AACnD,4BAA4B,iEAAQ;AACpC,2CAA2C,iEAAQ;AACnD,6BAA6B,kEAAS;AACtC,4CAA4C,kEAAS;AACrD,4BAA4B,iEAAQ;AACpC,2CAA2C,iEAAQ;AACnD,+BAA+B,kEAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,yBAAyB,gDAAgD;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/JyD;AACJ;AACR;AAC4B;AACzE;AACA;AACA;AACA,eAAe,kEAAgB,EAAE,+DAAW;AAC5C;AACA;AACA;AACA,IAAI,sFAAwB;AAC5B;AACA;AACA,mCAAmC,uCAAuC,EAAE;AAC5E;AACA;AACA;AACA;AACA;AACA,4BAA4B,uDAAQ;AACpC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,iEAAe,MAAM,EAAC","file":"lib_index_js.b8b304e116fe498155ca.js","sourcesContent":["import { defineMultiplexingMode } from './codemirror-my-multiplex';\nimport { defineKatScript2Mode } from './codemirror-katscript2';\nimport { defineKatScriptMode } from './codemirror-katscript';\nexport function setupKatScriptCodeMirror(codemirror) {\n    const cm = codemirror.CodeMirror;\n    defineMultiplexingMode(codemirror);\n    defineKatScript2Mode(codemirror);\n    defineKatScriptMode(codemirror);\n    cm.defineMode('katscript-python', (config) => {\n        const pmode = cm.getMode(config, 'python');\n        return cm.myMultiplexingMode(pmode, {\n            open: /(?=#kat2)/,\n            close: /(?=\"\"\")/,\n            mode: cm.getMode(config, 'text/x-katscript2'),\n            delimStyle: 'delim',\n        }, {\n            open: /(?=#kat)/,\n            close: /(?=\"\"\")/,\n            mode: cm.getMode(config, 'text/x-katscript'),\n            delimStyle: 'delim',\n        });\n    });\n    cm.defineMIME('text/x-katscript-python', 'katscript-python');\n    cm.modeInfo.push({\n        name: 'KatScript Python',\n        mime: 'text/x-katscript-python',\n        mode: 'katscript-python',\n        ext: [],\n    });\n}\n","export const commands = ['opt_rf_readout_phase',\n    'propagate_beam_astig',\n    'frequency_response',\n    'sensing_matrix_dc',\n    'noise_projection',\n    'print_model_attr',\n    'noise_analysis',\n    'propagate_beam',\n    'print_model',\n    'beam_trace',\n    'run_locks',\n    'freqresp',\n    'parallel',\n    'noxaxis',\n    'change',\n    'intrix',\n    'lambda',\n    'series',\n    'x2axis',\n    'x3axis',\n    'debug',\n    'modes',\n    'print',\n    'sweep',\n    'xaxis',\n    'abcd',\n    'fsig',\n    'link',\n    'plot',\n    'tem'];\nexport const elements = ['quantum_shot_noise_detector_demod_1',\n    'quantum_shot_noise_detector_demod_2',\n    'quantum_noise_detector_demod_1',\n    'quantum_noise_detector_demod_2',\n    'quantum_shot_noise_detector',\n    'directional_beamsplitter',\n    'beam_property_detector',\n    'power_detector_demod_1',\n    'power_detector_demod_2',\n    'quantum_noise_detector',\n    'amplitude_detector',\n    'degree_of_freedom',\n    'power_detector_dc',\n    'optical_bandpass',\n    'signal_generator',\n    'motion_detector',\n    'readout_dc_qpd',\n    'filter_butter',\n    'filter_cheby1',\n    'beamsplitter',\n    'zpk_actuator',\n    'ligo_triple',\n    'filter_zpk',\n    'readout_dc',\n    'readout_rf',\n    'amplifier',\n    'free_mass',\n    'ligo_quad',\n    'modulator',\n    'actuator',\n    'isolator',\n    'pendulum',\n    'qnoised1',\n    'qnoised2',\n    'squeezer',\n    'variable',\n    'ccdline',\n    'nothing',\n    'qnoised',\n    'splitpd',\n    'astigd',\n    'butter',\n    'cavity',\n    'cheby1',\n    'mirror',\n    'qshot1',\n    'qshot2',\n    'ccdpx',\n    'fline',\n    'gauss',\n    'laser',\n    'noise',\n    'qshot',\n    'space',\n    'fcam',\n    'gouy',\n    'isol',\n    'knmd',\n    'lens',\n    'lock',\n    'sgen',\n    'amp',\n    'cav',\n    'ccd',\n    'dbs',\n    'dof',\n    'fpx',\n    'mmd',\n    'mod',\n    'obp',\n    'pd1',\n    'pd2',\n    'var',\n    'zpk',\n    'ad',\n    'bp',\n    'bs',\n    'cp',\n    'pd',\n    'sq',\n    'xd',\n    'l',\n    'm',\n    's'];\nexport const functions = ['geomspace',\n    'linspace',\n    'logspace',\n    'arctan2',\n    'deg2rad',\n    'degrees',\n    'rad2deg',\n    'radians',\n    'arccos',\n    'arcsin',\n    'conj',\n    'imag',\n    'real',\n    'sqrt',\n    'abs',\n    'cos',\n    'exp',\n    'neg',\n    'pos',\n    'sin',\n    'tan'];\nexport const keywords = ['resolution',\n    'stability',\n    'bandpass',\n    'bandstop',\n    'highpass',\n    'finesse',\n    'lowpass',\n    'modesep',\n    'length',\n    'xsplit',\n    'ysplit',\n    'abcd',\n    'even',\n    'fwhm',\n    'gouy',\n    'loss',\n    'none',\n    'pole',\n    'div',\n    'fsr',\n    'lin',\n    'log',\n    'odd',\n    'off',\n    'tau',\n    'am',\n    'c0',\n    'pi',\n    'pm',\n    'rc',\n    'w0',\n    'zr',\n    'g',\n    'l',\n    'q',\n    's',\n    'w',\n    'x',\n    'y',\n    'z'];\nexport const operators = ['+', '/', '*', '&', '-'];\n","import { commands, elements, functions, keywords, operators, } from './codemirror-katscript-types';\nconst booleans = ['True', 'true', 'False', 'false'];\nfunction wordListRegexp(words) {\n    return new RegExp('((' + words.join(')|(') + '))');\n}\nfunction symbolListRegexp(words) {\n    return new RegExp('[' + words.join('') + ']');\n}\nfunction fullString(re) {\n    return new RegExp('^' + re.source + '$');\n}\nconst regex = {\n    command: wordListRegexp(commands),\n    fullcommand: fullString(wordListRegexp(commands)),\n    element: wordListRegexp(elements),\n    fullelement: fullString(wordListRegexp(elements)),\n    function: wordListRegexp(functions),\n    fullfunction: fullString(wordListRegexp(functions)),\n    keyword: wordListRegexp(keywords),\n    fullkeyword: fullString(wordListRegexp(keywords)),\n    operator: symbolListRegexp(operators),\n    name: /[a-zA-Z_][a-zA-Z0-9._-]*/,\n    number: /(([+-]?inf)|([+-]?(\\d+\\.\\d*|\\d*\\.\\d+|\\d+)([eE]-?\\d*\\.?\\d*)?j?([pnumkMGT])?))/,\n    boolean: wordListRegexp(booleans),\n    fullboolean: fullString(wordListRegexp(booleans)),\n    bracket: /[()]/,\n};\n/*\n * Available tokens:\n *\n * keyword\n * atom\n * number\n * def\n * variable\n * variable-2\n * variable-3\n * property\n * operator\n * comment\n * string\n * string-2\n * meta\n * qualifier\n * builtin\n * bracket\n * tag\n * attribute\n * header\n * quote\n * hr\n * link\n */\nexport function defineKatScriptMode(codemirror) {\n    const cm = codemirror.CodeMirror;\n    cm.defineMode('katscript', () => {\n        function tokenBase(stream, state) {\n            // Give each line a slight background, to differentiate from Python code.\n            return 'line-background-katscript ' + tokenLex(stream, state);\n        }\n        function tokenLex(stream, state) {\n            if (stream.sol()) {\n                state.firstOnLine = true;\n            }\n            // Skip to the next non-space character\n            if (stream.eatSpace()) {\n                return;\n            }\n            // If it's a comment, skip the rest of the line\n            if (/#/.test(stream.peek())) {\n                stream.skipToEnd();\n                return 'comment';\n            }\n            // Strings can be either single or double quoted, and quotes can be\n            // escaped inside them\n            if (/[\"']/.test(stream.peek())) {\n                const char = stream.next();\n                const re = RegExp('[^' + char + ']');\n                stream.eatWhile(re);\n                let cur = stream.current();\n                while (cur[cur.length - 1] === '\\\\') {\n                    if (!stream.next()) {\n                        break;\n                    }\n                    stream.eatWhile(re);\n                    cur = stream.current();\n                }\n                stream.eat(char);\n                return 'string';\n            }\n            let style = null;\n            if (state.firstOnLine) {\n                // Only check for component definitions and commands at the start of\n                // the line.\n                if (stream.match(regex['element']) || stream.match(regex['command'])) {\n                    // Some elements can be substrings of commands, and vice versa e.g.\n                    // \"l\" (element) and \"link\" (command). To choose the correct one, we\n                    // first continue grabbing the rest of the current word (if there is\n                    // any more), then test the entire word against element/command\n                    // names.\n                    stream.eatWhile(/\\w/);\n                    const cur = stream.current();\n                    if (regex['fullelement'].test(cur)) {\n                        // Component definition\n                        style = 'variable-3';\n                        state.nextIsDef = true;\n                    }\n                    else if (regex['fullcommand'].test(cur)) {\n                        // Command\n                        style = 'builtin';\n                    }\n                }\n            }\n            if (style === null) {\n                if (state.nextIsDef && stream.match(regex['name'])) {\n                    // Component name\n                    style = 'def';\n                    state.nextIsDef = false;\n                }\n                else if (stream.match(regex['keyword']) ||\n                    stream.match(regex['boolean']) ||\n                    stream.match(regex['function'])) {\n                    // Same reasoning as before, grab the rest of the word then check the\n                    // whole thing.\n                    stream.eatWhile(/\\w/);\n                    const cur = stream.current();\n                    if (regex['fullkeyword'].test(cur)) {\n                        style = 'keyword';\n                    }\n                    else if (regex['fullboolean'].test(cur)) {\n                        style = 'keyword';\n                    }\n                    else if (regex['fullfunction'].test(cur)) {\n                        style = 'builtin';\n                    }\n                    else {\n                        // We accidentally grabbed a variable.\n                        style = 'variable';\n                    }\n                }\n                else if (stream.match(regex['number'])) {\n                    style = 'number';\n                }\n                else if (stream.match(regex['operator'])) {\n                    style = 'operator';\n                }\n                else if (stream.match(regex['bracket'])) {\n                    style = 'bracket';\n                }\n                else if (stream.match(regex['name'])) {\n                    style = 'variable';\n                }\n            }\n            if (style !== null) {\n                state.firstOnLine = false;\n                return style;\n            }\n            stream.next();\n        }\n        return {\n            startState: function () {\n                return {\n                    tokenize: tokenBase,\n                    firstOnLine: true,\n                    nextIsDef: false,\n                };\n            },\n            blankLine: function (state) {\n                return 'line-background-katscript';\n            },\n            token: function (stream, state) {\n                return state.tokenize(stream, state);\n            },\n        };\n    });\n    cm.defineMIME('text/x-katscript', 'katscript');\n}\n","const components = [\n    'bs[12]?',\n    'dbs',\n    'grd*',\n    'isol',\n    'l',\n    'lens',\n    'm[12]?',\n    'mod',\n    's',\n    'sq',\n];\nconst detectors = [\n    'ad',\n    'beam',\n    'bp',\n    'cp',\n    'guoy',\n    'hd',\n    'pd[SN]?d*',\n    'pgaind',\n    'qd',\n    'qd*hd?',\n    'qhd[SN]?',\n    'qnoised[SN]?',\n    'qshot',\n    'qshot[SN]?',\n    'sd',\n    'xd',\n];\nconst commands = [\n    'attr',\n    'cav',\n    'conf',\n    'fadd',\n    'fsig',\n    'gauss',\n    'knm',\n    'lambda',\n    'map',\n    'mask',\n    'maxtem',\n    'pdtype',\n    'phase',\n    'retrace',\n    'smotion',\n    'startnode',\n    'tem',\n    'tf2?',\n    'vacuum',\n    // Plotting:\n    'const',\n    'deriv_h',\n    'diff',\n    'func',\n    'lock',\n    'noplot',\n    'noxaxis',\n    'put',\n    'scale',\n    'set',\n    'trace',\n    'var',\n    'x2?axis',\n    'yaxis',\n    // Auxiliary\n    'gnuterm',\n    'multi',\n    'pause',\n    'pyterm',\n];\nconst reserved = ['dump'];\nfunction wordListRegexp(words) {\n    return new RegExp('^((' + words.join(')|(') + '))$');\n}\nconst regex = {\n    command: wordListRegexp(commands),\n    component: wordListRegexp(components),\n    detector: wordListRegexp(detectors),\n    name: /[a-zA-Z_][a-zA-Z0-9_-]/,\n    number: /^(([+-]?inf)|([+-]?(\\d+\\.\\d*|\\d*\\.\\d+|\\d+)([eE]-?\\d*\\.?\\d*)?j?([pnumkMGT])?))$/,\n    reserved: wordListRegexp(reserved),\n    variable: /\\$\\w+/,\n};\n/*\n * Available tokens:\n *\n * keyword\n * atom\n * number\n * def\n * variable\n * variable-2\n * variable-3\n * property\n * operator\n * comment\n * string\n * string-2\n * meta\n * qualifier\n * builtin\n * bracket\n * tag\n * attribute\n * header\n * quote\n * hr\n * link\n */\nexport function defineKatScript2Mode(codemirror) {\n    const cm = codemirror.CodeMirror;\n    cm.defineMode('katscript2', () => {\n        function tokenBase(stream, state) {\n            return 'line-background-katscript ' + tokenLex(stream, state);\n        }\n        function tokenLex(stream, state) {\n            if (stream.sol()) {\n                state.firstOnLine = true;\n            }\n            if (stream.eatSpace()) {\n                return;\n            }\n            if (/[#%]/.test(stream.peek())) {\n                stream.skipToEnd();\n                return 'comment';\n            }\n            if (stream.peek() === '$') {\n                stream.next();\n            }\n            stream.eatWhile(/[^\\s]/);\n            let style = null;\n            const cur = stream.current();\n            if (state.firstOnLine) {\n                if (regex['component'].test(cur) || regex['detector'].test(cur)) {\n                    // Component definition\n                    style = 'keyword';\n                    state.nextIsDef = true;\n                }\n                else if (regex['command'].test(cur)) {\n                    // Command\n                    style = 'builtin';\n                }\n            }\n            else if (state.nextIsDef && regex['name'].test(cur)) {\n                // Component name\n                style = 'def';\n                state.nextIsDef = false;\n            }\n            else if (regex['number'].test(cur)) {\n                // Number\n                style = 'number';\n            }\n            else if (regex['reserved'].test(cur)) {\n                // Reserved keyword\n                style = 'keyword';\n            }\n            else if (regex['variable'].test(cur)) {\n                style = 'variable-2';\n            }\n            if (style !== null) {\n                state.firstOnLine = false;\n                return style;\n            }\n            stream.next();\n        }\n        return {\n            startState: function () {\n                return {\n                    tokenize: tokenBase,\n                    firstOnLine: true,\n                    nextIsDef: false,\n                };\n            },\n            blankLine: function (state) {\n                return 'line-background-katscript';\n            },\n            token: function (stream, state) {\n                return state.tokenize(stream, state);\n            },\n        };\n    });\n    cm.defineMIME('text/x-katscript2', 'katscript2');\n}\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n//\n// This is a clone of addon/mode/multiplexingMode.js from CodeMirror. The\n// original blankLine function doesn't return the style returned by its\n// sub-modes, so we have to copy the whole thing in here -_-\n\nexport function defineMultiplexingMode(codemirror) {\n  const cm = codemirror.CodeMirror;\n  cm.myMultiplexingMode = function (outer /*, others */) {\n    // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects\n    var others = Array.prototype.slice.call(arguments, 1);\n\n    function indexOf(string, pattern, from, returnEnd) {\n      if (typeof pattern == 'string') {\n        var found = string.indexOf(pattern, from);\n        return returnEnd && found > -1 ? found + pattern.length : found;\n      }\n      var m = pattern.exec(from ? string.slice(from) : string);\n      return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;\n    }\n\n    return {\n      startState: function () {\n        return {\n          outer: cm.startState(outer),\n          innerActive: null,\n          inner: null,\n          startingInner: false\n        };\n      },\n\n      copyState: function (state) {\n        return {\n          outer: cm.copyState(outer, state.outer),\n          innerActive: state.innerActive,\n          inner:\n            state.innerActive &&\n            cm.copyState(state.innerActive.mode, state.inner),\n          startingInner: state.startingInner\n        };\n      },\n\n      token: function (stream, state) {\n        if (!state.innerActive) {\n          var cutOff = Infinity,\n            oldContent = stream.string;\n          for (var i = 0; i < others.length; ++i) {\n            var other = others[i];\n            var found = indexOf(oldContent, other.open, stream.pos);\n            if (found == stream.pos) {\n              if (!other.parseDelimiters) stream.match(other.open);\n              state.startingInner = !!other.parseDelimiters;\n              state.innerActive = other;\n\n              // Get the outer indent, making sure to handle cm.Pass\n              var outerIndent = 0;\n              if (outer.indent) {\n                var possibleOuterIndent = outer.indent(state.outer, '', '');\n                if (possibleOuterIndent !== cm.Pass)\n                  outerIndent = possibleOuterIndent;\n              }\n\n              state.inner = cm.startState(other.mode, outerIndent);\n              return (\n                other.delimStyle &&\n                other.delimStyle + ' ' + other.delimStyle + '-open'\n              );\n            } else if (found != -1 && found < cutOff) {\n              cutOff = found;\n            }\n          }\n          if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\n          var outerToken = outer.token(stream, state.outer);\n          if (cutOff != Infinity) stream.string = oldContent;\n          return outerToken;\n        } else {\n          var curInner = state.innerActive,\n            oldContent = stream.string;\n          if (!curInner.close && stream.sol()) {\n            state.innerActive = state.inner = null;\n            return this.token(stream, state);\n          }\n          var found =\n            curInner.close && !state.startingInner\n              ? indexOf(\n                  oldContent,\n                  curInner.close,\n                  stream.pos,\n                  curInner.parseDelimiters\n                )\n              : -1;\n          if (found == stream.pos && !curInner.parseDelimiters) {\n            stream.match(curInner.close);\n            state.innerActive = state.inner = null;\n            return (\n              curInner.delimStyle &&\n              curInner.delimStyle + ' ' + curInner.delimStyle + '-close'\n            );\n          }\n          if (found > -1) stream.string = oldContent.slice(0, found);\n          var innerToken = curInner.mode.token(stream, state.inner);\n          if (found > -1) stream.string = oldContent;\n          else if (stream.pos > stream.start) state.startingInner = false;\n\n          if (found == stream.pos && curInner.parseDelimiters)\n            state.innerActive = state.inner = null;\n\n          if (curInner.innerStyle) {\n            if (innerToken) innerToken = innerToken + ' ' + curInner.innerStyle;\n            else innerToken = curInner.innerStyle;\n          }\n\n          return innerToken;\n        }\n      },\n\n      indent: function (state, textAfter, line) {\n        var mode = state.innerActive ? state.innerActive.mode : outer;\n        if (!mode.indent) return cm.Pass;\n        return mode.indent(\n          state.innerActive ? state.inner : state.outer,\n          textAfter,\n          line\n        );\n      },\n\n      blankLine: function (state) {\n        var mode = state.innerActive ? state.innerActive.mode : outer;\n        var ret = null;\n        if (mode.blankLine) {\n          ret = mode.blankLine(state.innerActive ? state.inner : state.outer);\n        }\n        if (!state.innerActive) {\n          for (var i = 0; i < others.length; ++i) {\n            var other = others[i];\n            if (other.open === '\\n') {\n              state.innerActive = other;\n              state.inner = cm.startState(\n                other.mode,\n                mode.indent ? mode.indent(state.outer, '', '') : 0\n              );\n            }\n          }\n        } else if (state.innerActive.close === '\\n') {\n          state.innerActive = state.inner = null;\n        }\n        return ret;\n      },\n\n      electricChars: outer.electricChars,\n\n      innerMode: function (state) {\n        return state.inner\n          ? { state: state.inner, mode: state.innerActive.mode }\n          : { state: state.outer, mode: outer };\n      }\n    };\n  };\n}\n","import { INotebookTracker, } from '@jupyterlab/notebook';\nimport { ICodeMirror } from '@jupyterlab/codemirror';\nimport { CodeCell } from '@jupyterlab/cells';\nimport { setupKatScriptCodeMirror } from './codemirror-katscript-python';\nconst plugin = {\n    id: 'katscript-jupyter',\n    autoStart: true,\n    requires: [INotebookTracker, ICodeMirror],\n    activate,\n};\nfunction activate(app, tracker, codemirror) {\n    setupKatScriptCodeMirror(codemirror);\n    const style = document.createElement('style');\n    style.type = 'text/css';\n    style.innerHTML = '.katscript { background-color: rgba(0, 0, 0, 0.04); }';\n    document.getElementsByTagName('head')[0].appendChild(style);\n    tracker.widgetAdded.connect(activate_katscript);\n}\nfunction check_all(sender) {\n    sender.content.widgets.forEach(cell => {\n        if (cell instanceof CodeCell &&\n            cell.model.mimeType !== 'text/x-katscript-python') {\n            cell.model.mimeType = 'text/x-katscript-python';\n        }\n    });\n}\nfunction set_mime(model) {\n    // Jupyter seems to have some weirdness related to setup of the\n    // mime type of each cell. To avoid having timeouts everywhere,\n    // everytime we select a new cell, we attach a function that checks the\n    // mime type on each content change and sets it if required, otherwise\n    // disconnects itself.\n    if (model.mimeType === 'text/x-katscript-python') {\n        model.contentChanged.disconnect(set_mime);\n    }\n    else {\n        model.mimeType = 'text/x-katscript-python';\n    }\n}\nfunction check_cell(sender, cell) {\n    if (cell instanceof CodeCell) {\n        cell.model.contentChanged.connect(set_mime);\n    }\n}\nfunction activate_katscript(sender, panel) {\n    panel.content.activeCellChanged.connect(check_cell);\n    // I ain't proud of this, but it's the sanest way I could find to get\n    // the syntax highlighting to change on startup without selecting a\n    // different cell\n    setTimeout(() => {\n        check_all(panel);\n    }, 500);\n    setTimeout(() => {\n        check_all(panel);\n    }, 2000);\n    setTimeout(() => {\n        check_all(panel);\n    }, 5000);\n}\nexport default plugin;\n"],"sourceRoot":""}