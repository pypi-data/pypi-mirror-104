"""
eui means easy UI. It is a fast and simple micro-framework for small browser-based applications.
Python and JS communicate through websocket protocol.
"""

import base64
import hashlib
import json
import logging
import os
import queue
import random
import socket
import struct
import threading
import time
from concurrent import futures

log = logging.getLogger('eui')
_SEND_QUEUE = queue.Queue()
PORT = None
HANDLERS = {}
_WORKERS = None
_MAX_RECEIVE_MESSAGE_SIZE = 1 * 1024 * 1024
_WS_CONNECTION = None

# eui.js code template
_JS_TEMPLATE = '''/**
* This file is automatically generated every time eui starts. Please do not modify it manually.
 */
if ('WebSocket' in window) {
   window.eui = {};
   //init websocket
   eui.ws = new WebSocket("ws://localhost:%s");
   eui.ws.onopen = function () {
      console.log('connect to eui server!');
   };

   eui.ws.onmessage = function (evt) {
      try {
         var data = JSON.parse(evt.data);
         data = data['handler'] + '.apply(null, ' + JSON.stringify(data['args']) + ')';
         eval(data);
      } catch (e) {
         eui.errorHandler(e);
      }
   };

   eui.ws.onclose = function () {
      alert('Connection closed, APP will exit!');
      window.location.href = "about:blank";
      window.close();
   };

   eui.ws.onerror = function (e) {
      alert('Connection error, please restart it again!');
      window.location.href = "about:blank";
      window.close();
   };

   /**
    * It is used to execute Python handler. 
    * 
    * @param {string} handler Python handler
    * @param {...} ___args args for Python handler. If there are multiple args, separate them with commas.
    */
   eui.py = function (handler, ___args) {
      if (eui.ws.readyState != 1) {
         setTimeout(eui.py, 100, handler, ___args);
      } else {
         var args = [];
         for (var i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
         }
         eui.ws.send(JSON.stringify({ 'handler': handler, 'args': args }));
      }
   };

   /**
    * Default error handler. It will be executed when an exception occurs and can be overridden if necessary.
    * 
    * @param {string} e error message
    */
   eui.errorHandler = function (e) {
      alert(e);
      console.error(e);
   };

} else {
   alert("your browser don't support WebSocket");
}

'''


def _init_log(file, level):
    """
    init log config
    :param file: log file
    :param level: log level
    :return:
    """
    log.setLevel(level)
    formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(pathname)s [line:%(lineno)d] %(message)s",
                                  '%Y-%m-%d %H:%M:%S')
    console_log_handler = logging.StreamHandler()
    console_log_handler.setFormatter(formatter)
    file_log_handler = logging.FileHandler(file, mode='w')
    file_log_handler.setFormatter(formatter)

    log.addHandler(console_log_handler)
    log.addHandler(file_log_handler)


def _get_headers(payload):
    """
    get headers from data
    :param payload: received connection message
    :return: headers
    """
    headers = {}
    if not payload:
        return headers
    header_str, body = str(payload, encoding="utf-8").split("\r\n\r\n", 1)
    header_list = header_str.split("\r\n")
    headers['method'], headers['uri'], headers['protocol'] = header_list[0].split(' ')
    for row in header_list[1:]:
        key, value = row.split(":", 1)
        headers[str(key).lower()] = value.strip()

    return headers


def _parse_payload(payload):
    """
    parse payload message

    :param payload: bytes message
    :return: parsed string message
    """
    payload_len = payload[1] & 127
    if payload_len == 126:
        mask = payload[4:8]
        decoded = payload[8:]

    elif payload_len == 127:
        mask = payload[10:14]
        decoded = payload[14:]
    else:
        mask = payload[2:6]
        decoded = payload[6:]

    byte_list = bytearray()
    for i, b in enumerate(decoded):
        chunk = b ^ mask[i % 4]
        byte_list.append(chunk)
    # ui close
    if byte_list == bytearray(b'\x03\xe9'):
        log.info('lost connection, APP will quit soon!')
        time.sleep(3)
        _exit(0)

    return str(byte_list, encoding='utf-8')


def _init_js(static_dir):
    """
    generate js file

    :param static_dir: dir for eui.js
    :return:
    """
    os.makedirs(static_dir, exist_ok=True)
    path = (static_dir if static_dir.endswith('/') else static_dir + '/') + 'eui.js'
    with open(path, 'w', encoding='utf-8') as f:
        f.write(_JS_TEMPLATE % PORT)


def _task(handler, args):
    """
    task is a handler wrapper to execute handler with Exception handling
    :param handler: target handler
    :param args: handler args
    :return:
    """
    try:
        if args:
            handler(*args)
        else:
            handler()
    except Exception as e:
        default_error_handler(str(e), e)


def _startup_receive_message_worker():
    """
    startup a worker to receive message

    """

    def run():
        while True:
            try:
                payload = _WS_CONNECTION.recv(_MAX_RECEIVE_MESSAGE_SIZE)
                data = json.loads(_parse_payload(payload))
                handler_name = data.get('handler', '')
                if handler_name not in HANDLERS:
                    default_error_handler(
                        "handler '%s' not found, please check Python handlers config" % handler_name)
                    continue
                handler = HANDLERS[handler_name]
                args = data.get('args', None)
                _WORKERS.submit(_task, handler, args)
            except ConnectionResetError:
                log.info('lost connection, APP will quit soon!')
                time.sleep(3)
                _exit(0)

    # send message worker is a daemon thread
    send_thread = threading.Thread(target=run)
    send_thread.setDaemon(True)
    send_thread.start()


def _startup_send_message_worker():
    """
    startup a worker to send message

    """

    def run():
        while True:
            data = _SEND_QUEUE.get().encode('utf-8')
            # assemble message
            token = b"\x81"
            length = len(data)
            if length < 126:
                token += struct.pack("B", length)
            elif length <= 0xFFFF:
                token += struct.pack("!BH", 126, length)
            else:
                token += struct.pack("!BQ", 127, length)

            msg = token + data
            _WS_CONNECTION.sendall(msg)

    # send message worker is a daemon thread
    send_thread = threading.Thread(target=run)
    send_thread.setDaemon(True)
    send_thread.start()


def _startup_callback(fn):
    """
    startup callback function, when eui startup, fn will be execute
    :param fn: callback function
    :return:
    """
    if not fn:
        return
    callback_thread = threading.Thread(target=fn)
    callback_thread.setDaemon(True)
    callback_thread.start()


def default_error_handler(error_message, error=None):
    """
    default error handler
    :param error_message: error message
    :param error: error object
    :return:
    """
    js('eui.errorHandler', error_message)
    log.exception(msg=error_message, exc_info=error)


def js(handler, *args):
    """
    call js function

    :param handler: js function
    :param args: js function args
    :return:
    """
    _SEND_QUEUE.put(json.dumps({'handler': handler, 'args': args}, ensure_ascii=True))


def _dispatch_connection(connection):
    """
    dispatch connection to websocket or HTTP handler
    :param connection: connection
    :return:
    """
    payload = connection.recv(_MAX_RECEIVE_MESSAGE_SIZE)
    headers = _get_headers(payload)
    if not headers:
        connection.sendall(b"HTTP/1.1 200 OK")
        connection.close()
        return

    # websocket connection
    global _WS_CONNECTION
    if headers.get('upgrade', '').lower() == 'websocket':
        response_tpl = "HTTP/1.1 101 Switching Protocols\r\n" \
                       "Upgrade: websocket\r\n" \
                       "Connection: Upgrade\r\n" \
                       "Sec-WebSocket-Accept: %s\r\n" \
                       "WebSocket-Location: ws://%s\r\n\r\n"

        value = ''
        if headers.get('sec-websocket-key'):
            value = headers['sec-websocket-key'] + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
        ac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest())
        response = response_tpl % (ac.decode('utf-8'), headers.get("host"))
        connection.sendall(bytes(response, encoding="utf-8"))

        # if eui has not been initialized, initialize it
        if _WS_CONNECTION is None:
            _WS_CONNECTION = connection
            # startup workers
            _startup_receive_message_worker()
            _startup_send_message_worker()
        else:  # eui has been initialized
            log.error(
                "Note that the websocket connection can only be established once and cannot be established repeatedly")
            _exit(1)

    else:  # HTTP connection
        path = '.' + headers.get('uri', '')
        if os.path.exists(path) and os.path.isfile(path):
            with open(path, 'rb') as f:
                data = f.read()
                response = "HTTP/1.1 200 OK\r\n" \
                           "Content-Length: %s\r\n\r\n" % len(data)
                connection.sendall(bytes(response, encoding='utf-8') + data)
        else:
            log.error("can't read file '%s'" % path)
            connection.sendall(b"HTTP/1.1 404 Not Found")
        connection.close()


def start(host="0.0.0.0", port=None, handlers=None, static_dir='./static', startup_callback=None, max_workers=10,
          log_file='eui.log', log_level='DEBUG'):
    """
    start eui

    :param host: host
    :param port: port, if port is None, port will be a random int value
    :param handlers: python function for js call
    :param static_dir: dir for output eui.js
    :param startup_callback: the function after eui startup to run
    :param max_workers: max workers to execute handlers
    :param log_file: log file path
    :param log_level: log level, 'CRITICAL', 'FATAL', 'ERROR', 'WARN', 'WARNING', 'INFO', 'DEBUG', 'NOTSET'
    :return:
    """

    global PORT, HANDLERS, _WORKERS

    # init log
    _init_log(log_file, log_level)

    # init port
    if port is None:
        port = random.randint(5000, 60000)
    PORT = port

    # init handlers
    if handlers:
        HANDLERS = handlers

    # init js file
    _init_js(static_dir)

    # init workers
    _WORKERS = futures.ThreadPoolExecutor(max_workers=max_workers)

    # init socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((host, PORT))
    sock.listen(6)

    # startup callback function
    _startup_callback(startup_callback)
    print('******************** eui start up at port %s ********************' % PORT)

    # accept connection
    while True:
        try:
            connection, addr = sock.accept()
            _WORKERS.submit(_dispatch_connection, connection)
        except Exception as e:
            log.exception('connect error', e)


def _exit(code):
    """
    exit process
    :param code: error code
    :return:
    """
    os._exit(code)
